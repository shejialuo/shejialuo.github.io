<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="CS144: Introduction to Computer Networking Lab 3" />


<!-- Website keywords -->

<meta name="keywords" content="技术, 学习, 洛的藏书阁" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="洛的藏书阁" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://luolibrary.com/2022/11/23/CS144-Introduction-to-Computer-Networking-Lab-3/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7M238H24L4"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-7M238H24L4');
</script>

  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>CS144: Introduction to Computer Networking Lab 3 - 洛的藏书阁</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">洛的藏书阁</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">洛的藏书阁</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      CS144: Introduction to Computer Networking Lab 3
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-11-23
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/CS144/">CS144</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Retransmission-timer"><span class="toc-number">1.</span> <span class="toc-text">Retransmission timer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-sender"><span class="toc-number">2.</span> <span class="toc-text">TCP sender</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-data-structure-of-outstanding-segments"><span class="toc-number">2.1.</span> <span class="toc-text">The data structure of outstanding segments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Some-private-members"><span class="toc-number">2.2.</span> <span class="toc-text">Some private members</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill-window"><span class="toc-number">2.3.</span> <span class="toc-text">fill_window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ack-received"><span class="toc-number">2.4.</span> <span class="toc-text">ack_received</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tick"><span class="toc-number">2.5.</span> <span class="toc-text">tick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send-empty-segment"><span class="toc-number">2.6.</span> <span class="toc-text">send_empty_segment</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p>
<hr>
<p>First, you should read carefully read the docs provided by the lab.</p>
<blockquote>
<p>It will be your <code>TCPSender</code>‘s responsibility to:</p>
<ul>
<li>Keep track of the receiver’s window</li>
<li>Fill the window when possible, by reading from the <code>ByteStream</code>, creating new TCP segments, and sending them. The sender should keep sending segments until either the window is full or the <code>ByteStream</code> is empty.</li>
<li>Keep track of which segments have been sent but not yet acknowledged by the receiver——we call these “outstanding” segments.</li>
<li>Re-send outstanding segments if enough time passes since they were sent, and they haven’t been acknowledged yet.</li>
</ul>
</blockquote>
<h2 id="Retransmission-timer"><a href="#Retransmission-timer" class="headerlink" title="Retransmission timer"></a>Retransmission timer</h2><p>According to the docs, the first thing we need to do is to implement a class for retransmission timer. So I have created two files <code>retransmission_timer.hh</code> and <code>retransmission_timer.cc</code>. However, before we implement this class in action, we should understand the requirements:</p>
<ul>
<li><code>tick(const size_t ms_since_last_tick)</code> method is aimed at simulating the time. So every time the <code>tick</code> is called, we need to add the <code>ms_since_last_tick</code> to the <code>_accumulate_time</code>. When the <code>_accumulate_time</code> is greater than the <code>_rto</code>, the timer has elapsed. So we need to call a function called <code>tick_callback</code> every time <code>tick</code> is called.</li>
<li>If the timer has elapsed, and the window size is not zero: double the value of the <code>_rto</code>, so we need a function called <code>handle_expired</code>. Also, we need to set the <code>_accumulate_time</code> to be 0.</li>
<li>Every time a segment <em>containing data</em> is sent, if the timer is not running, start it running. So we need to maintain a state. I use a function called <code>start_timer</code> to start the timer.</li>
<li>When receiver gives the sender an <code>ackno</code> that acknowledges the successful receipt of <em>new</em> data: we use <code>reset_timer</code> to set the <code>_rto</code> to its initial value and clear the <code>_accumulate_timer</code>. If all the outstanding segments are received, we should stop the timer called <code>stop_timer</code>.</li>
</ul>
<p>At now, we can code.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: retransmission_timer.hh</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TimerState</span> &#123; running, stop &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RetransmissionTimer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    TimerState state;             <span class="comment">//! the state of the timer</span></span><br><span class="line">    <span class="type">size_t</span> _initial_rto;          <span class="comment">//! the initial retransmission timeout</span></span><br><span class="line">    <span class="type">size_t</span> _rto;                  <span class="comment">//! current retransmission timeout</span></span><br><span class="line">    <span class="type">size_t</span> _accumulate_time = <span class="number">0</span>;  <span class="comment">//! the accumulate time</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! \brief constructor</span></span><br><span class="line">    <span class="built_in">RetransmissionTimer</span>(<span class="type">const</span> <span class="type">size_t</span> retx_timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief check whether the time is expired</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">tick_callback</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief when receiving a valid ack, reset the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset_timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief when the timer is expired we should handle this situation</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_expired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief start the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief stop the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop_timer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: retransmission_timer.cc</span></span><br><span class="line">RetransmissionTimer::<span class="built_in">RetransmissionTimer</span>(<span class="type">const</span> <span class="type">size_t</span> retx_timeout)</span><br><span class="line">    : state&#123;TimerState::stop&#125;, _initial_rto&#123;retx_timeout&#125;, _rto&#123;retx_timeout&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RetransmissionTimer::tick_callback</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//! Only when the timer is running, we add the `_accumulate_time`.</span></span><br><span class="line">    <span class="keyword">if</span> (state == TimerState::running) &#123;</span><br><span class="line">        _accumulate_time += ms_since_last_tick;</span><br><span class="line">        <span class="comment">//! Check whether the timer has elapsed.</span></span><br><span class="line">        <span class="keyword">return</span> _rto &lt;= _accumulate_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::reset_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _rto = _initial_rto;</span><br><span class="line">    _accumulate_time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::start_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == TimerState::stop) &#123;</span><br><span class="line">        state = TimerState::running;</span><br><span class="line">        <span class="built_in">reset_timer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::stop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == TimerState::running) &#123;</span><br><span class="line">        state = TimerState::stop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::handle_expired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _rto *= <span class="number">2</span>;</span><br><span class="line">    _accumulate_time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP-sender"><a href="#TCP-sender" class="headerlink" title="TCP sender"></a>TCP sender</h2><p>There are four public interfaces we need to implement for <code>TCPSender</code>:</p>
<ul>
<li><code>void fill_window()</code>.</li>
<li><code>void ack_received(const WrappingInt32 ackno, const uint16_t window_size)</code>.</li>
<li><code>void tick(const size_t ms_since_last_tick)</code>.</li>
<li><code>void send_empty_segment()</code>.</li>
</ul>
<p>Well, the main purpose for <code>fill_window()</code> is to translate ByteStream to TCPSegment. And we need to push these segments to <code>_segments_out</code>. And writes a reference copy to <code>_outstanding_segments</code> .In this process, there are some many things we need to consider:</p>
<ul>
<li>We should record the receiver’s acknowledge number <code>_receiver_ack</code> and window size <code>_receiver_window_size</code> to know whether we could transmit the new segments to the receiver.</li>
<li>We also need to consider about the ByteStream size.</li>
<li>We need to think about the data structure of the <code>_outstanding_segments</code>. In <code>full_window()</code>, it should support insertion.</li>
</ul>
<p>For <code>ack_received()</code>, when we receiving the acknowledge number from the receiver, first we update <code>_receiver_ack</code> and delete the fully acknowledged segments from <code>_outstanding_segments</code> and calls <code>fill_window()</code>. So the data structure for <code>_outstanding_segments</code> should support deletion.</p>
<p>For <code>tick()</code>, it should check whether the retransmission timer has expired. If so, it should retransmit the <em>earliest</em> (lowest sequence number) segment. So we need to make the <code>_outstanding_segments</code> sorted.</p>
<h3 id="The-data-structure-of-outstanding-segments"><a href="#The-data-structure-of-outstanding-segments" class="headerlink" title="The data structure of outstanding segments"></a>The data structure of outstanding segments</h3><p>I decide to use <code>list</code> to represent the data structure of outstanding segments. The reasons are as follows:</p>
<ul>
<li>We could easily make it sorted.</li>
<li>We could add and delete a segment fast.</li>
</ul>
<h3 id="Some-private-members"><a href="#Some-private-members" class="headerlink" title="Some private members"></a>Some private members</h3><p>Before implementing the interfaces, we can define the following fields:</p>
<ul>
<li><code>_retransmission_timer</code>: the timer defined above.</li>
<li><code>_receiver_ack</code>: the absolute receiver ack.</li>
<li><code>_receiver_window_size</code>: the receiver window size which should be 1 when initialized.</li>
<li><code>_outstanding_segments</code>: the outstanding segments</li>
<li><code>_consecutive_retransmissions</code>: the consecutive retransmissions.</li>
<li><code>window_not_full</code>: a helper function to tell whether the window is not full.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//! the retransmission timer</span></span><br><span class="line">    RetransmissionTimer _retransmission_timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the (absolute) receiver ack.</span></span><br><span class="line">    <span class="type">uint64_t</span> _receiver_ack&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the initial window size should be 1</span></span><br><span class="line">    <span class="type">uint64_t</span> _receiver_window_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the outstanding segments</span></span><br><span class="line">    std::list&lt;TCPSegment&gt; _outstanding_segments&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the consecutive retransmissions</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _consecutive_retransmissions&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! a helper function to tell whether the window is not full</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">window_not_full</span><span class="params">(<span class="type">uint64_t</span> window_size)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> window_size &gt; <span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a>fill_window</h3><p>There are two special cases we should consider for the <code>fill_window</code> functions:</p>
<ul>
<li>TCP connection</li>
<li>TCP disconnection</li>
</ul>
<p>For the TCP connection where <code>_next_seqno == 0</code>, we should set the <code>syn</code> to be <code>true</code> and sends the datagram out.</p>
<p>For the TCP disconnection, things could be much more complicated. There are two cases:</p>
<ul>
<li>An empty payload which indicates the disconnection where <code>stream_in().eof()</code> is <code>true</code>.</li>
<li>Nonempty payload which indicates the disconnection where <code>stream_in().eof()</code> is <code>true</code>.</li>
</ul>
<p>For transferring the data, we want to transfer as much as we want. We should consider about the following three things:</p>
<ul>
<li>For a TCP segment, the length which should not exceed <code>TCPConfig::MAX_PAYLOAD_SIZE</code>.</li>
<li>We can only transfer the length which should not exceed <code>_receiver_window_size - bytes_in_flight()</code>.</li>
<li>We can only transfer the length which should not exceed <code>stream_in().buffer_size()</code>.</li>
</ul>
<p>At the end, we need to start the timer.</p>
<p>Well, It may seem easy, however, there are some many corner cases. Please look at the following code for details.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Special case: we have already sent the `FIN`.</span></span><br><span class="line">    <span class="keyword">if</span> (end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCPSegment segment&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case: when the `_receiver_window_size` equals 0</span></span><br><span class="line">    <span class="type">uint64_t</span> window_size = _receiver_window_size == <span class="number">0</span> ? <span class="number">1</span> : _receiver_window_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case : TCP connection</span></span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">        _next_seqno += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find the length to read from the `stream_in()`</span></span><br><span class="line">        <span class="type">uint64_t</span> length =</span><br><span class="line">            std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(window_size - <span class="built_in">bytes_in_flight</span>(), <span class="built_in">stream_in</span>().<span class="built_in">buffer_size</span>()), TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">        segment.<span class="built_in">payload</span>() = Buffer&#123;std::<span class="built_in">move</span>(<span class="built_in">stream_in</span>().<span class="built_in">read</span>(length))&#125;;</span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">        _next_seqno += length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When the `stream_in` is end of file,  we need to set the `fin` to `true`.</span></span><br><span class="line">        <span class="comment">// Pay attention, we should check whether there is an enough window size</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; <span class="built_in">window_not_full</span>(window_size)) &#123;</span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            end = <span class="literal">true</span>;</span><br><span class="line">            _next_seqno++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We should do nothing</span></span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> &amp;&amp; !end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segments_out</span>().<span class="built_in">push</span>(segment);</span><br><span class="line">    _outstanding_segments.<span class="built_in">push_back</span>(segment);</span><br><span class="line">    _retransmission_timer.<span class="built_in">start_timer</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window_not_full</span>(window_size)) &#123;</span><br><span class="line">        <span class="built_in">fill_window</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a>ack_received</h3><p>For receiving new acknowledge number from the receiver, which means the <code>ackno</code> is greater than the next sequence number need to be sent. And <code>ackno</code> is less than the current <code>_receiver_ack</code>. We just return.</p>
<p>And next we need to step by step to check the <code>_outstanding_segments</code>, if the <code>ackno</code> can accept the full segments, we update the <code>_receiver_ack</code> value. If not, we break the loop. Also, we need to update the value of <code>_receiver_window_size</code>. However, there would be a corner case: <em>what if the window size is zero</em>:</p>
<blockquote>
<p>If the receiver has announced a window size of zero, the fill window method should act like the window size is one. The sender might end up sending a single byte that gets rejected (and not acknowledged) by the receiver, but this can also provoke the receiver into sending a new acknowledgment segment where it reveals that more space has opened up in its window. Without this, the sender would never learn that it was allowed to start sending again.</p>
</blockquote>
<p>And also we should not double the retransmission timeout in this case. So we need to test whether the <code>_receiver_window_size</code> equals to 0 in <code>tick</code> method.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When receiving unneeded ack, just return.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unwrap</span>(ackno, _isn, <span class="built_in">next_seqno_absolute</span>()) &gt; _next_seqno ||</span><br><span class="line">        <span class="built_in">unwrap</span>(ackno, _isn, <span class="built_in">next_seqno_absolute</span>()) &lt; _receiver_ack) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> absolute_ack = <span class="built_in">unwrap</span>(ackno, _isn, <span class="built_in">next_seqno_absolute</span>());</span><br><span class="line">    _receiver_window_size = window_size;</span><br><span class="line">    <span class="type">bool</span> is_ack_update = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = _outstanding_segments.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != _outstanding_segments.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> sequence_num = <span class="built_in">unwrap</span>(iter-&gt;<span class="built_in">header</span>().seqno, _isn, <span class="built_in">next_seqno_absolute</span>());</span><br><span class="line">        <span class="keyword">if</span> (sequence_num + iter-&gt;<span class="built_in">length_in_sequence_space</span>() &lt;= absolute_ack) &#123;</span><br><span class="line">            _receiver_ack = sequence_num + iter-&gt;<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            iter = _outstanding_segments.<span class="built_in">erase</span>(iter);</span><br><span class="line">            is_ack_update = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When there is no outstanding segments, we should stop the timer</span></span><br><span class="line">    <span class="keyword">if</span> (_outstanding_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _retransmission_timer.<span class="built_in">stop_timer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the receiver gives the sender an ackno that acknowledges</span></span><br><span class="line">    <span class="comment">// the successful receipt of new data</span></span><br><span class="line">    <span class="keyword">if</span> (is_ack_update) &#123;</span><br><span class="line">        _retransmission_timer.<span class="built_in">reset_timer</span>();</span><br><span class="line">        _consecutive_retransmissions = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><p><code>tick</code> is easy, because the most important logic we have already implemented:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_retransmission_timer.<span class="built_in">tick_callback</span>(ms_since_last_tick)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver_window_size == <span class="number">0</span>) &#123;</span><br><span class="line">            _retransmission_timer.<span class="built_in">reset_timer</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _retransmission_timer.<span class="built_in">handle_expired</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _consecutive_retransmissions++;</span><br><span class="line">        <span class="built_in">segments_out</span>().<span class="built_in">push</span>(_outstanding_segments.<span class="built_in">front</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="send-empty-segment"><a href="#send-empty-segment" class="headerlink" title="send_empty_segment"></a>send_empty_segment</h3><p>It is easy to implement <code>send_empty_segment</code>. Just change the <code>seq</code> of the segment.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment empty&#123;&#125;;</span><br><span class="line">    empty.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">    <span class="built_in">segments_out</span>().<span class="built_in">push</span>(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://luolibrary.com">shejialuo</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://luolibrary.com/2022/11/23/CS144-Introduction-to-Computer-Networking-Lab-3/">https://luolibrary.com/2022/11/23/CS144-Introduction-to-Computer-Networking-Lab-3/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
      
      <a href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/11/28/CS144-Introduction-to-Computer-Networking-Lab-4/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">CS144: Introduction to Computer Networking Lab 4</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2022/11/22/CS144-Introduction-to-Computer-Networking-Lab-2/">  
        <span class="next-text nav-default">CS144: Introduction to Computer Networking Lab 2</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="utterances-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:shejialuo@gmail.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://twitter.com/luo_hope" class="iconfont icon-twitter" title="twitter"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/jialuo-she-913873289/" class="iconfont icon-linkedin" title="linkedin"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/shejialuo" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2020 - 2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">shejialuo</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
  
<script>
  var container = document.getElementById('utterances-container');
  var script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', 'shejialuo/shejialuo.github.io');
  script.setAttribute('issue-term', 'pathname');
  script.setAttribute('theme', 'github-light');
  script.setAttribute('label', 'Comment');
  script.crossorigin = 'anonymous';
  script.async = true;

  container.appendChild(script);
</script>
  
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



<!-- mermaid -->

  <script src='https://unpkg.com/mermaid@9.2.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>