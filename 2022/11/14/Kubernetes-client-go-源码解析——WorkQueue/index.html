<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="Kubernetes client-go 源码解析——WorkQueue" />


<!-- Website keywords -->

<meta name="keywords" content="技术, 洛的藏书阁" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="洛的藏书阁" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://luolibrary.com/2022/11/14/Kubernetes-client-go-源码解析——WorkQueue/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7M238H24L4"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-7M238H24L4');
</script>

  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>Kubernetes client-go 源码解析——WorkQueue - 洛的藏书阁</title>

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">洛的藏书阁</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">洛的藏书阁</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      Kubernetes client-go 源码解析——WorkQueue
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-11-14
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Kubernetes%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Kubernetes源码解析</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#FIFO%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">FIFO队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%85%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">队列初始化及其生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">set方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Type%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.</span> <span class="toc-text">Type方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">同步机制总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%A0%87"><span class="toc-number">1.5.</span> <span class="toc-text">指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">延迟队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E9%80%9F%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">限速队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-number">4.</span> <span class="toc-text">令牌桶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Limiter%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">Limiter数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-go%E5%B0%81%E8%A3%85"><span class="toc-number">4.5.</span> <span class="toc-text">Client-go封装</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p>WorkQueue称为工作队列，支持如下的特性：</p>
<ul>
<li>有序：按照添加顺序处理元素</li>
<li>去重：相同元素在同一时间不会被重复处理，例如一个元素在处理之前被添加了多次，它只会被处理一次。</li>
<li>并发性：多生产者与多消费者。</li>
<li>标记机制：支持标记功能，标记一个元素是否被处理，也允许元素在处理时重新排队。</li>
<li>通知机制：<code>ShutDown</code>方法通过信号量通知队列不再接收新的元素，并通过<code>metric goroutine</code>退出。</li>
<li>延迟：支持延迟队列，延迟一段时间后再将元素存入队列。</li>
<li>限速：支持限速队列，元素存入队列时进行速率限制。限制一个元素被重新排队的次数。</li>
<li>Metric：支持metric监控指标，可用于Prometheus监控。</li>
</ul>
<p>WorkQueue支持3种队列，并提供了3种接口，不同队列实现可应对不同的使用场景：</p>
<ul>
<li><code>Interface</code>：FIFO队列接口，支持去重机制。</li>
<li><code>DelayingInterface</code>：延迟队列接口，基于<code>Interface</code>封装，延迟一段时间后再将元素存入队列。</li>
<li><code>RateLimitingInterface</code>：限速队列接口，基于<code>DelayingInterface</code>封装，支持元素存入队列时进行速率限制。</li>
</ul>
<h2 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h2><p>此部分代码实现位于<code>util/workqueue/queue.go</code>中。首先，client-go定义了一个<code>Type</code>类型作为FIFO队列的数据结构实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">  queue []t</span><br><span class="line">  dirty set</span><br><span class="line">  processing set</span><br><span class="line">  cond *sync.Cond</span><br><span class="line">  shuttingDown <span class="type">bool</span></span><br><span class="line">  drain <span class="type">bool</span></span><br><span class="line">  metrics queueMetrics</span><br><span class="line">  unfinishedWorkUpdatePeriod time.Duration</span><br><span class="line">  clock clock.WithTicker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些重要字段的含义如下：</p>
<ul>
<li><code>queue</code>：包含按照顺序需要处理的事件。类型<code>t</code>只是一个别名<code>type t interface&#123;&#125;</code>。其本质的目的在于用于保证元素的有序。</li>
<li><code>dirty</code>：包含所有需要处理的事件，按照这个定义所有在<code>queue</code>的事件必然在<code>dirty</code>中。类型<code>set</code>也是一个别名 <code>type set map[t]empty</code>，<code>empty</code>也是一个别名，<code>type empty struct&#123;&#125;</code>。既保证了去重，还能保证在处理一个元素之前哪怕其被添加了多次，但也只会被处理一次。</li>
<li><code>processing</code>：包含正在处理的事件。<code>dirty</code>也可能包含某些<code>processing</code>中的事件。</li>
<li><code>cond</code>：条件变量。</li>
<li><code>shuttingDown</code>：是否关闭队列。</li>
<li><code>drain</code>：关闭队列时是否立即消耗完仍然存在的元素。</li>
<li><code>metrics</code>：指标接口，定义在<code>util/workqueue/metrics.go</code>。</li>
<li><code>unfinishedWorkUpdatePeriod</code>：每次时钟更新的时间，用于初始化时钟。</li>
<li><code>clock</code>：时钟。</li>
</ul>
<p>然后，client-go定义了用于FIFO队列的接口<code>Interface</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  Len() <span class="type">int</span></span><br><span class="line">  Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>)</span><br><span class="line">  Done(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  ShutDown()</span><br><span class="line">  ShutDownWithDrain()</span><br><span class="line">  ShuttingDown() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Add</code>：给队列添加元素。</li>
<li><code>Len</code>：返回当前队列的长度。</li>
<li><code>Get</code>：获取队列头部的一个元素。</li>
<li><code>Done</code>：标记队列中该元素已被处理。</li>
<li><code>ShutDown</code>：关闭队列。</li>
<li><code>ShutDownWithDrain</code>：关闭队列并立即处理完在<code>processing</code>中的元素。</li>
<li><code>ShuttingDown</code>：查询队列是否正在关闭。</li>
</ul>
<p>为了更好地理解FIFO队列，我们首先对两个场景进行描述。一个场景是无并发环境，一个是存在并发的环境。</p>
<p>场景一：通过<code>Add</code>方法往FIFO队列中分别插入1、2、3三个元素，此时队列中的<code>queue</code>和<code>dirty</code>字段分别存有1、2、3元素，<code>processing</code>字段为空。元素1被放入<code>processing</code>字段，表示该元素正在被处理。最后，当处理完1元素时，通过<code>Done</code>方法标记该元素已经处理完成，此时队列中的<code>processing</code>字段中的1元素会被删除。</p>
<p><img src="https://s2.loli.net/2022/07/19/s5NhxylkIJX2CUm.png" alt="FIFO无并发场景下存储过程"></p>
<p>场景二：在并发场景下，假设goroutine A通过<code>Get</code>方法获取1元素，1元素此时被添加到<code>processing</code>字段中，同一时间，goroutine B通过<code>Add</code>方法插入另一个元素，由于<code>processing</code>已经有元素1，故不会存入<code>queue</code>中而是存入<code>dirty</code>中。当元素1处理完成后，则将1元素追加到<code>queue</code>字段中的尾部。</p>
<p><img src="https://s2.loli.net/2022/07/19/ypdvTi47Um1Vwfn.png" alt="FIFO并发场景下存储过程"></p>
<h3 id="队列初始化及其生命周期"><a href="#队列初始化及其生命周期" class="headerlink" title="队列初始化及其生命周期"></a>队列初始化及其生命周期</h3><p><code>queue.go</code>首先定义了一个辅助函数<code>updateUnfinishedWorkLoop</code>用于对整个队列的生命周期进行管理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> updateUnfinishedWorkLoop() &#123;</span><br><span class="line">  t := q.clock.NewTicker(q.unfinishedWorkUpdatePeriod)</span><br><span class="line">  <span class="keyword">defer</span> t.Stop()</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">range</span> t.C() &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      q.cond.L.Lock()</span><br><span class="line">      <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">      <span class="keyword">if</span> !q.shuttingDown &#123;</span><br><span class="line">        q.metrics.updateUnfinishedWork()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;() &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法利用<code>for range t.C()</code>，每隔<code>q.unfinishedWorkUpdatePeriod</code>秒，都会判断队列是否被关闭，如果队列没有被关闭，则返回<code>true</code>，继续执行循环。如果队列被关闭，则直接返回<code>false</code>，然后退出循环，结束函数执行。</p>
<p>然后是对其进行初始化。首先定义了一个基本的<code>New</code>函数。然后层层抽象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Type &#123;</span><br><span class="line">  <span class="keyword">return</span> NewNamed(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamed</span><span class="params">(name <span class="type">string</span>)</span></span> *Type &#123;</span><br><span class="line">  rc := clock.RealClock&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> newQueue(</span><br><span class="line">    rc,</span><br><span class="line">    globalMetricsFactory.newQueueMetrics(name, rc),</span><br><span class="line">    defaultUnfinishedWorkUpdatePeriod,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>defaultUnfinishedWorkUpdatePeriod</code>只是一个常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultUnfinishedWorkUpdatePeriod = <span class="number">500</span> * time.Millisecond</span><br></pre></td></tr></table></figure>

<p>然后就是最关键的就是<code>newQueue</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newQueue</span><span class="params">(c clock.WithTicker, metrics queueMetrics,updatePeriod time.Duration)</span></span> *Type &#123;</span><br><span class="line">  t := &amp;Type&#123;</span><br><span class="line">    clock: c,</span><br><span class="line">    dirty: set&#123;&#125;,</span><br><span class="line">    processing: set&#123;&#125;,</span><br><span class="line">    cond: sync.NewCond(&amp;sync.Mutex&#123;&#125;),</span><br><span class="line">    metrics: metrics,</span><br><span class="line">    unfinishedWorkUpdatePeriod: updatePeriod,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _, ok := metrics.(noMetrics); !ok &#123;</span><br><span class="line">    <span class="keyword">go</span> t.updateUnfinishedWorkLoop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，当定义了一个FIFO队列后，<code>updateUnfinishedWorkLoop</code>将会一直运行然后每隔一定的时间检测队列的<code>shuttingDown</code>的值。可见，利用该值作为信号来传递。</p>
<h3 id="set方法定义"><a href="#set方法定义" class="headerlink" title="set方法定义"></a>set方法定义</h3><p>为了更加方便地对<code>set</code>，即<code>map[t]empty</code>类型进行操作。<code>queue.go</code>定义了一系列方法简化，把基本的<code>map</code>方法封装了一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> has(item t) <span class="type">bool</span>&#123;</span><br><span class="line">  _, exists := s[item]</span><br><span class="line">  <span class="keyword">return</span> exists</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> insert(item t) &#123;</span><br><span class="line">  s[item] = empty&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> <span class="built_in">delete</span>(item t) &#123;</span><br><span class="line">  <span class="built_in">delete</span>(s, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> <span class="built_in">len</span>() <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type方法定义"><a href="#Type方法定义" class="headerlink" title="Type方法定义"></a>Type方法定义</h3><p>首先是实现<code>Interface</code>的<code>Add</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Add(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q.metrics.add(item)</span><br><span class="line"></span><br><span class="line">  q.dirty.insert(item)</span><br><span class="line">  <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">  q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保持互斥首先需要上锁，然后判断队列是否已经被关闭。如果没有被关闭，首先添加到<code>dirty</code>中，然后判断<code>item</code>是否位于<code>processing</code>中，如果没有添加到<code>queue</code>中。然后释放信号用于同步。这是一个典型的生产者与消费者的问题。生产者是<code>Add</code>方法，消费者是<code>Get</code>方法。</p>
<p>同样实现<code>Interface</code>的<code>Len</code>方法。很简单，加个锁即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(q.queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现<code>Interface</code>的<code>Get</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">    q.cond.Wait()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  item = q.queue[<span class="number">0</span>]</span><br><span class="line">  q.queue[<span class="number">0</span>] = <span class="literal">nil</span></span><br><span class="line">  q.queue = q.queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">  q.metrics.get(item)</span><br><span class="line"></span><br><span class="line">  q.processing.insert(item)</span><br><span class="line">  q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，<code>Get</code>方法作为一个消费者当队列为空时，应该等待故调用了<code>q.cond.Wait</code>。然后取出第一个元素，置<code>queue[0]</code>为空以便进行垃圾回收，插入到<code>processing</code>中，然后从<code>dirty</code>中删除。</p>
<p><code>Done</code>方法用于告知队列该元素已被处理，如果该元素存在<code>dirty</code>中，我们需要将其重新加入到<code>queue</code>中来处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Done(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  q.metrics.done(item)</span><br><span class="line"></span><br><span class="line">  q.processing.<span class="built_in">delete</span>(item)</span><br><span class="line">  <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">    q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> q.processing.<span class="built_in">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ShutDown</code>方法让队列忽略所有需要新增的item然后立即告知worker goroutine退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q* Type)</span></span> ShutDown() &#123;</span><br><span class="line">  q.setDrain(<span class="literal">false</span>)</span><br><span class="line">  q.shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个辅助函数<code>setDrain</code>和<code>shutdown</code>进行抽象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q* Type)</span></span> setDrain(shouldDrain <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  q.drain = shouldDrain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q* Type)</span></span> shutdown() &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  q.shuttingDown = <span class="literal">true</span></span><br><span class="line">  q.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>q.cond.Broadcast</code>的使用，尽管关闭了队列，但我们仍然可以使用<code>Get</code>方法去获取元素。可能此时<code>q.queue</code>有元素或者没有，但我们必须使用避免阻塞了其他函数。</p>
<p>然后<code>queue.go</code>定义了<code>ShutDownWithDrain</code>关闭队列并立即处理<code>q.queue</code>中的元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> ShutDownWithDrain() &#123;</span><br><span class="line">  q.setDrain(<span class="literal">true</span>)</span><br><span class="line">  q.shutdown()</span><br><span class="line">  <span class="keyword">for</span> q.isProcessing() &amp;&amp; q.shouldDrain() &#123;</span><br><span class="line">    q.waitForProcessing()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> isProcessing() <span class="type">bool</span> &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">return</span> q.processing.<span class="built_in">len</span>() != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> shouldDrain() <span class="type">bool</span> &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">return</span> q.drain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> waitForProcessing() &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> q.processing.<span class="built_in">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.cond.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步机制总结"><a href="#同步机制总结" class="headerlink" title="同步机制总结"></a>同步机制总结</h3><p>在FIFO队列中，存在许多同步的东西，总结如下：</p>
<ul>
<li>基本的生产者-消费者模型。<code>Add</code>方法需要调用<code>q.cond.Signal</code>通知等待的<code>Get</code>方法。<code>Done</code>方法可能也会添加新的item。故如果新增了新的item，也需要调用<code>q.cond.Signal</code>通知等待的<code>Get</code>方法。</li>
<li><code>Done</code>方法在<code>q.processing.len() == 0</code>时也会调用<code>q.cond.Signal</code>实现同步，这是因为<code>ShutDownWithDrain</code>方法会调用<code>waitForProcessing</code>然后再调用<code>q.cond.Wait</code>阻塞自身。显然对于<code>drain</code>来说，开发者必须对每个方法item调用<code>Done</code>方法，以便在<code>q.processing</code>的长度为0时，唤醒<code>ShutDownWithDrain</code>方法。</li>
</ul>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>指标定义在<code>metrics.go</code>中，可以看见我们在处理item的时候，也会对其的指标进行操作，由于该部分不是核心代码，此处不进行分析。</p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>此部分代码定义在<code>util/workqueue/delaying_queue.go</code>中。延迟队列基于FIFO队列接口封装，在原有的功能上增加了<code>AddAfter</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DelayingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  Interface</span><br><span class="line">  AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先看延迟队列的<code>AddAfter</code>方法是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span></span> AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration) &#123;</span><br><span class="line">  <span class="keyword">if</span> q.ShuttingDown() &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q.metrics.retry()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> duration &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    q.Add(item)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">    <span class="keyword">case</span> q.waitingForAddCh &lt;- &amp;waitFor&#123;data: item, readyAt: q.clock.Now().Add(duration)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这个函数就做了一个极其简单的事情，当<code>duration</code>小于0时，直接加入队列中。</p>
<p>我们首先需要看<code>delayingType</code>这个类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> delayingType <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interface</span><br><span class="line">  clock           clock.Clock</span><br><span class="line">  stopCh          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  stopOnce        sync.Once</span><br><span class="line">  heartbeat       clock.Ticker</span><br><span class="line">  waitingForAddCh <span class="keyword">chan</span>* waitFor</span><br><span class="line">  metrics         retryMetrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些重要的字段含义如下：</p>
<ul>
<li><code>stopCh</code>：利用channel作信号量。</li>
<li><code>stopOnce</code>：只能Stop一次。</li>
<li><code>waitingForAddCh</code>：用来存储待加入的<code>item</code>。</li>
</ul>
<p>其中<code>waitFor</code>的类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitFor <span class="keyword">struct</span> &#123;</span><br><span class="line">  data    t</span><br><span class="line">  readyAt time.Time</span><br><span class="line">  index   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码维护了一个优先队列<code>waitForPriorityQueue</code>，其本质的思路在于实现<code>heap</code>的接口，内容比较简单，此处忽略细节。</p>
<p><code>newDelayingQueue</code>函数创建了一个新的延迟队列，然后启用<code>waitingLoop</code> goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDelayingQueue</span><span class="params">(clock clock.WithTicker, q Interface, name <span class="type">string</span>)</span></span> *delayingType &#123;</span><br><span class="line">  ret := &amp;delayingType&#123;</span><br><span class="line">    Interface:       q,</span><br><span class="line">    clock:           clock,</span><br><span class="line">    heartbeat:       clock.NewTicker(maxWait),</span><br><span class="line">    stopCh:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    waitingForAddCh: <span class="built_in">make</span>(<span class="keyword">chan</span> *waitFor, <span class="number">1000</span>),</span><br><span class="line">    metrics:         newRetryMetrics(name),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> ret.waitingLoop()</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>waitingLoop</code>是延迟队列实现的核心所在。其本质的思路仍然是实现同步，此处忽略细节。</p>
<h2 id="限速队列"><a href="#限速队列" class="headerlink" title="限速队列"></a>限速队列</h2><p>限速队列在延迟队列接口的基础上增加了<code>AddRateLimited</code>, <code>Forget</code>, <code>NumRequeues</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimitingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  DelayingInterface</span><br><span class="line"></span><br><span class="line">  AddRateLimited(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这三个方法都是调用<code>RateLimiter</code>的接口方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">  When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration</span><br><span class="line"></span><br><span class="line">  Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>When</code>：获取指定元素应该等待的时间。</li>
<li><code>Forget</code>：释放指定元素。</li>
<li><code>NumRequeues</code>：返回元素的失败数。</li>
</ul>
<p>WorkQueue提供了4种限速算法：</p>
<ul>
<li>令牌桶算法：下节单独介绍</li>
<li>排队指数算法：将相同元素的排队数作为指数，排队数增大，速率限制呈指数级增长。</li>
<li>计数器算法：限制一段时间内允许通过的元素数量。</li>
<li>混合模式</li>
</ul>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>client-go使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Token_bucket">令牌桶</a>作为限流算法。</p>
<h3 id="Limiter数据结构定义"><a href="#Limiter数据结构定义" class="headerlink" title="Limiter数据结构定义"></a>Limiter数据结构定义</h3><p>Go语言标准库提供了令牌桶算法的实现。首先在<code>rate.go</code>中定义了<code>Limiter</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu     sync.Mutex</span><br><span class="line">  limit  Limit</span><br><span class="line">  burst  <span class="type">int</span></span><br><span class="line">  tokens <span class="type">float64</span></span><br><span class="line">  last time.Time</span><br><span class="line">  lastEvent time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>Limit</code>仅仅只是一个类型Wrapper：<code>type Limit float64</code>。字段的含义如下：</p>
<ul>
<li><code>mu</code>：互斥锁</li>
<li><code>limit</code>：每秒下发令牌的个数</li>
<li><code>burst</code>：桶的最大令牌数量</li>
<li><code>tokens</code>：当前令牌数量</li>
<li><code>last</code>：最后一次<code>tokens</code>字段更新时间</li>
<li><code>lastEvent</code>：最近一次限流事件发生的时间</li>
</ul>
<p>目前<code>limit</code>的定义为每秒下发令牌的个数，故<code>rate.go</code>定义了<code>Every</code>函数将事件之间的最小时间间隔转换为<code>Limit</code>。当<code>limit = Inf</code>时，<code>burst</code>可以被忽略，允许任何事件通过，因为下发令牌的个数是无限的。同时，<code>limit</code>也可以为0，代表不允许任何事件通过。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Every</span><span class="params">(interval time.Duration)</span></span> Limit &#123;</span><br><span class="line">  <span class="keyword">if</span> interval &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Inf</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> / Limit(interval.Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rate.go</code>定义了一些基本的getter和setter方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> lim.Limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span> &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> lim.burst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Limiter&#123;</span><br><span class="line">    limit: r,</span><br><span class="line">    burst: b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>为了更加好的抽象，<code>rate.go</code>定义了一系列的辅助函数。根据令牌桶的概念我们可以知道，随着时间的变化，令牌桶中的令牌数量会增加。故为了实现时间间隔和令牌桶的令牌数量相互的转化，<code>rate.go</code>定义了<code>tokensFromDuration</code>和<code>durationFromTokens</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个时间段会产生多少个令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limit Limit)</span></span> tokensFromDuration(d time.Duration) <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> limit &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d.Seconds() * <span class="type">float64</span>(limit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前令牌桶中的令牌代表了多少时间段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limit Limit)</span></span> durationFromTokens(tokens <span class="type">float64</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> limit &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> InfDuration</span><br><span class="line">  &#125;</span><br><span class="line">  seconds := tokens / <span class="type">float64</span>(limit)</span><br><span class="line">  <span class="keyword">return</span> time.Duration(<span class="type">float64</span>(time.Second) * seconds)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着时间的变化，需要对令牌桶中的令牌也就是<code>token</code>进行更新，故定义了<code>advance</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> advance(now time.Time) (newNow time.Time, newLast time.Time, newTokens <span class="type">float64</span>) &#123;</span><br><span class="line">  last := lim.last</span><br><span class="line">  <span class="keyword">if</span> now.Before(last) &#123;</span><br><span class="line">    last = now</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  elapsed := now.Sub(last)</span><br><span class="line">  delta := lim.limit.tokensFromDuration(elapsed)</span><br><span class="line">  tokens := lim.tokens + delta</span><br><span class="line">  <span class="keyword">if</span> burst := <span class="type">float64</span>(lim.burst); tokens &gt; burst &#123;</span><br><span class="line">    tokens = burst</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> now, last, tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Limiter还包含一些setter方法，介绍了辅助函数后，对于这些setter方法就比较容易理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit) &#123;</span><br><span class="line">  lim.SetLimitAt(time.Now(), newLimit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit) &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  now, _, tokens := lim.advance(now)</span><br><span class="line"></span><br><span class="line">  lim.last = now</span><br><span class="line">  lim.tokens = tokens</span><br><span class="line">  lim.limit = newLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>) &#123;</span><br><span class="line">  lim.SetBurstAt(time.Now(), newBurst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetBurstAt sets a new burst size for the limiter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>) &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  now, _, tokens := lim.advance(now)</span><br><span class="line"></span><br><span class="line">  lim.last = now</span><br><span class="line">  lim.tokens = tokens</span><br><span class="line">  lim.burst = newBurst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Limiter主要有三个方法：<code>Allow</code>, <code>Reserve</code>和<code>Wait</code>。这三个方法在被调用时，都会消耗掉一个令牌。这三个方法分别被<code>AllowN</code>，<code>ReserveN</code>以及<code>WaitN</code>抽象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.AllowN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.ReserveN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.WaitN(ctx, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>rate.go</code>定义了<code>Reservation</code>数据结构，包含了已经被限流器所允许的事件的信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reservation <span class="keyword">struct</span> &#123;</span><br><span class="line">  ok        <span class="type">bool</span></span><br><span class="line">  lim       *Limiter</span><br><span class="line">  tokens    <span class="type">int</span></span><br><span class="line">  timeToAct time.Time</span><br><span class="line">  limit Limit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段的含义如下：</p>
<ul>
<li><code>ok</code>：表示事件能否发生</li>
<li><code>lim</code>: 属于哪个Limiter</li>
<li><code>tokens</code>：表示该事件需要消耗的令牌数量</li>
<li><code>timeToAct</code>：执行的时间</li>
<li><code>limit</code>：在<code>Reserve</code>操作的时候定义</li>
</ul>
<p>我们首先看函数<code>AllowN</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.reserveN(now, n, <span class="number">0</span>).ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看函数<code>ReserveN</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation &#123;</span><br><span class="line">  r := lim.reserveN(now, n, InfDuration)</span><br><span class="line">  <span class="keyword">return</span> &amp;r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>AllowN</code>和<code>ReserveN</code>都是通过<code>reserveN</code>进行抽象的。首先<code>reserveN</code>处理特殊情况，即<code>limit = Inf</code>（允许任何事件通过）和<code>limit = 0</code>（不允许任何事件通过），虽然不允许任何事件通过，但是本身令牌桶初始化時有<code>burst</code>个令牌数，故还是可以允许通过<code>burst</code>个令牌。</p>
<p>再处理完特殊情况后，首先通过<code>advance</code>计算出现在时刻的令牌桶中的令牌数量的个数，减去该事件所消耗的令牌个数。当令牌数小于0证明该事件需要等待，故通过<code>durationFromTokens</code>计算需要等待的时间。</p>
<p>其次，判断事件能否发生。事件能发生需要满足两个条件，一是事件发生消耗的令牌数量不能超过令牌桶最大的令牌数量，二是等待时间不能超过参数<code>maxFutureReserve</code>的值。</p>
<p>后面的操作就是更新字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> reserveN(now time.Time, n <span class="type">int</span>, maxFutureReserve time.Duration) Reservation &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> lim.limit = Inf &#123;</span><br><span class="line">    <span class="keyword">return</span> Reservation&#123;</span><br><span class="line">      ok:        <span class="literal">true</span>,</span><br><span class="line">      lim:       lim,</span><br><span class="line">      tokens:    n,</span><br><span class="line">      timeToAct: now,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> lim.limit == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> lim.burst &gt;= n &#123;</span><br><span class="line">      ok = <span class="literal">true</span></span><br><span class="line">      lim.burst -= n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Reservation&#123;</span><br><span class="line">      ok:        <span class="literal">true</span>,</span><br><span class="line">      lim:       lim,</span><br><span class="line">      tokens:    lim.burst,</span><br><span class="line">      timeToAct: now,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  now, last, tokens := lim.advance(now)</span><br><span class="line"></span><br><span class="line">  tokens -= <span class="type">float64</span>(n)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> waitDuration time.Duration</span><br><span class="line">  <span class="keyword">if</span> tokens &lt; <span class="number">0</span> &#123;</span><br><span class="line">    waitDuration = lim.limit.durationFromTokens(-tokens)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ok := n &lt;= lim.burst &amp;&amp; waitDuration &lt;= maxFutureReserve</span><br><span class="line"></span><br><span class="line">  r := Reservation&#123;</span><br><span class="line">    ok:    ok,</span><br><span class="line">    lim:   lim,</span><br><span class="line">    limit: lim.limit,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    r.tokens = n</span><br><span class="line">    r.timeToAct = now.Add(waitDuration)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    lim.last = now</span><br><span class="line">    lim.tokens = tokens</span><br><span class="line">    lim.lastEvent = r.timeToAct</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lim.last = last</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>reserveN</code>作为一个核心的函数，无非就是查询令牌桶中的令牌数量足不足以支持一个消耗<code>n</code>个令牌的任务，为了维持这个任务的状态必须定义一个数据结构来维持。</p>
<p>在讲<code>WaitN</code>函数之前，我们先看看<code>DelayFrom</code>函数，这个函数很简单，对于已经ok的任务，得到其延迟发生的时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> DelayFrom(now time.Time) time.Duration &#123;</span><br><span class="line">  <span class="keyword">if</span> !r.ok &#123;</span><br><span class="line">    <span class="keyword">return</span> InfDuration</span><br><span class="line">  &#125;</span><br><span class="line">  delay := r.timeToAct.Sub(now)</span><br><span class="line">  <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delay</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以去看<code>WaitN</code>函数，很显然对于一个任务来说，其可以通过调用<code>WaitN</code>来实现限流。</p>
<ul>
<li>当所需的令牌数目大于令牌桶所能包含的最大令牌，直接返回error。</li>
<li>如果在调用时，任务已经结束了，直接返回error。</li>
<li>计算<code>waitLimit</code>其值为任务结束的时间和现在的时间的差值，然后使用<code>reserveN</code>得到任务的状态。</li>
<li>然后使用<code>DelayFrom</code>计算需要延迟的时间，如果有必要延迟的话，通过一个定时器来延时。如果定时器完成了，就继续。如果定时器结束之前，<code>Context</code>被取消了，返回错误。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  burst := lim.burst</span><br><span class="line">  limit := lim.limit</span><br><span class="line">  lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> n &gt; burst &amp;&amp; limit != Inf &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;rate: Wait(n=%d) exceeds limiter&#x27;s burst %d&quot;</span>, n, burst)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    <span class="keyword">return</span> ctx.Err()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  now := time.Now()</span><br><span class="line">  waitLimit := InfDuration</span><br><span class="line">  <span class="keyword">if</span> deadline, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">    waitLimit = deadline.Sub(now)</span><br><span class="line">  &#125;</span><br><span class="line">  r := lim.reserveN(now, n, waitLimit)</span><br><span class="line">  <span class="keyword">if</span> !r.ok &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;rate: Wait(n=%d) would exceed context deadline&quot;</span>, n)</span><br><span class="line">  &#125;</span><br><span class="line">  delay := r.DelayFrom(now)</span><br><span class="line">  <span class="keyword">if</span> delay == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  t := time.NewTimer(delay)</span><br><span class="line">  <span class="keyword">defer</span> t.Stop()</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    r.Cancel()</span><br><span class="line">    <span class="keyword">return</span> ctx.Err()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>r.Cancel()</code>的使用，既然我们已经给了令牌给一个任务而这个任务并没有实际的执行，我们应该还给令牌桶相应的数目。由于此时已经介绍了大部分的函数，此处忽略其细节。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>令牌桶的实现与时间有很大的关系，看似需要每隔1s就需要更新令牌桶中的令牌数目，实则上是完全没有必要的。因为可以从未来借。当每一次调用主要方法时，都会通过现在的时间减去上一次令牌桶数目更新的时间来更新令牌桶中的令牌数目，令牌桶中的令牌数目是负的也根本无所谓，很棒的设计。</p>
<h3 id="Client-go封装"><a href="#Client-go封装" class="headerlink" title="Client-go封装"></a>Client-go封装</h3><p>Client-go在<code>util/workqueue/default_rate_limiters.go</code>中定义了<code>BucketRateLimiter</code>用于封装标准库中的<code>Limiter</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">  *rate.Limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span></span> When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration &#123;</span><br><span class="line">  <span class="keyword">return</span> r.Limiter.Reserve().Delay()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span></span> NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span></span> Forget(item <span class="keyword">interface</span>&#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://luolibrary.com">shejialuo</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://luolibrary.com/2022/11/14/Kubernetes-client-go-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94WorkQueue/">https://luolibrary.com/2022/11/14/Kubernetes-client-go-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94WorkQueue/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/11/21/CS144-Introduction-to-Computer-Networking-initial-source-code-reading/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">CS144: Introduction to Computer Networking initial source code reading</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2022/11/08/Rewrite-%E7%BD%9A%E6%8A%84/">  
        <span class="next-text nav-default">Rewrite(罚抄)</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="utterances-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:shejialuo@gmail.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://twitter.com/luo_hope" class="iconfont icon-twitter" title="twitter"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/jialuo-she-913873289/" class="iconfont icon-linkedin" title="linkedin"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/shejialuo" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2020 - 2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">shejialuo</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
  
<script>
  var container = document.getElementById('utterances-container');
  var script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', 'shejialuo/shejialuo.github.io');
  script.setAttribute('issue-term', 'pathname');
  script.setAttribute('theme', 'github-light');
  script.setAttribute('label', 'Comment');
  script.crossorigin = 'anonymous';
  script.async = true;

  container.appendChild(script);
</script>
  
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



<!-- mermaid -->

  <script src='https://unpkg.com/mermaid@9.2.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>