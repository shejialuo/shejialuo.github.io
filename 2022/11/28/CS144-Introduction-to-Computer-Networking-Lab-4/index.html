<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="CS144: Introduction to Computer Networking Lab 4" />


<!-- Website keywords -->

<meta name="keywords" content="技术, 学习, 洛的藏书阁" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="洛的藏书阁" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://luolibrary.com/2022/11/28/CS144-Introduction-to-Computer-Networking-Lab-4/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7M238H24L4"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-7M238H24L4');
</script>

  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>CS144: Introduction to Computer Networking Lab 4 - 洛的藏书阁</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">洛的藏书阁</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">洛的藏书阁</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      CS144: Introduction to Computer Networking Lab 4
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-11-28
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/CS144/">CS144</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Easy-functions"><span class="toc-number">1.</span> <span class="toc-text">Easy functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-Connection"><span class="toc-number">2.</span> <span class="toc-text">TCP Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Connect"><span class="toc-number">2.1.</span> <span class="toc-text">Connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Close"><span class="toc-number">2.2.</span> <span class="toc-text">Close</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Auxiliary-functions"><span class="toc-number">3.</span> <span class="toc-text">Auxiliary functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#connect"><span class="toc-number">4.</span> <span class="toc-text">connect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#segment-received"><span class="toc-number">5.</span> <span class="toc-text">segment_received</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write"><span class="toc-number">6.</span> <span class="toc-text">write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#end-input-stream"><span class="toc-number">7.</span> <span class="toc-text">end_input_stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tick"><span class="toc-number">8.</span> <span class="toc-text">tick</span></a></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p>
<hr>
<p>Before we write the code, we should think what would <code>TCPConnection</code> do. If you carefully read the docs provided by lab. You will understand the requirements easily. But the most important thing is to understand how <code>TCPConnection</code> combines the <code>TCPReceiver</code> and <code>TCPSender</code> and achieves the functionality.</p>
<p>Here, I give an example to illustrate the process. I named the two instances of <code>TCPConnection</code> called <code>TCPConnectionA</code> and <code>TCPConnectionB</code>. And the <code>TCPConnectionA</code> has two classes <code>TCPReceiverA</code> and <code>TCPSenderA</code>, respectively, the <code>TCPConnectionB</code> has two classes <code>TCPReceiverB</code> and <code>TCPSenderB</code>.</p>
<p>When <code>TCPConnectionA</code> sends the segment to <code>TCPConnectionB</code>, it will calls the <code>TCPSenderA</code>‘s <code>fill_window()</code> method to extract the data to the segments. It will maintain the absolute sequence number for the next byte to be sent. However, <em>there is one thing we do not consider, how about the acknowledge number in the header?</em>. We need to do this in the <code>TCPConnection</code> class.</p>
<p>And when <code>TCPConnectionB</code> using <code>segment_received</code> method to handle the received segments. It should do the following things:</p>
<ul>
<li>It should uses <code>TCPReceiverB</code>‘s method <code>segment_received</code> method which updates its acknowledge number which should later be sent to the <code>TCPConnectionA</code>. Now we can understand the above question: the acknowledge number comes from itself receiver’s stored acknowledge number.</li>
<li>Next it should use <code>TCPSenderB</code>‘s <code>ack_received</code> to update the <code>TCPSenderA</code>‘s acknowledge number and its window size.</li>
<li>Then we should call the <code>fill_window</code> method and pops the <code>TCPSenderB</code>‘s <code>_segments_out</code> to <code>TCPConnectionB</code>‘s <code>_segments_out</code>. And also we need to change the header part, set the acknowledge number to the <code>TCPReceiverB</code>‘s acknowledge number.</li>
</ul>
<p>I am really appreciating the nice abstraction for this design. You can look at the following picture for better understanding.</p>
<p><img src="https://s2.loli.net/2022/11/28/Hcbp5rQ6qK8fCzF.png" alt="TCPConnection Example"></p>
<h2 id="Easy-functions"><a href="#Easy-functions" class="headerlink" title="Easy functions"></a>Easy functions</h2><p>There are some easy functions which just some getters. We can implement these functions immediately.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPConnection</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! the flag to indicate whether it is alive</span></span><br><span class="line">    <span class="type">bool</span> _active&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the time interval since last segment received.</span></span><br><span class="line">    <span class="type">size_t</span> _time_since_last_segment_received&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP-Connection"><a href="#TCP-Connection" class="headerlink" title="TCP Connection"></a>TCP Connection</h2><p>It’s not hard to write the code about sending the data or receiving the data. I have already talked about a lot above. However, we need to handle the connection and close carefully.</p>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>In the <code>TCPSender</code> class, we actually do not consider the ack. So we need to use <code>_sender.send_empty_segment()</code> to produce a new segment when connecting.</p>
<h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><p>The most difficult part is how to gracefully close the <code>TCPConnection</code>. For unclean shutdown, it’s easy. We just send or receive a segment with the <code>RST</code> flag set.</p>
<p>However, for clean shutdown. There are so many things we need to do.</p>
<ul>
<li><p><em>Prereq #1</em> The inbound stream has been fully assembled and has ended. I use a private function called <code>check_inbound_stream_assembled_and_ended</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::check_inbound_stream_assembled_and_ended</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>(); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Prereq #2</em> The outbound stream has been ended by the local application and fully sent the fact that it ended to the remote peer. Remember, I have provided a <code>end</code> flag but without no public method to get that value. So I do this and uses a function called <code>check_outbound_stream_ended_and_send_fin</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::check_outbound_stream_ended_and_send_fin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">is_end</span>(); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Prereq #3</em> The outbound stream has been fully acknowledged by the remote peer. I use a function called <code>check_outbound_fully_acknowledged</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::check_outbound_fully_acknowledged</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>Prereq #4</em> It’s important to understand the reason why there are two situations. We would implement this in the <code>tick</code> function</p>
</li>
</ul>
<p>We can code now.</p>
<h2 id="Auxiliary-functions"><a href="#Auxiliary-functions" class="headerlink" title="Auxiliary functions"></a>Auxiliary functions</h2><p>Here, I first define a function called <code>set_ack_and_window</code>, it inspects the <code>_receiver</code>‘s acknowledge number and window size. And updates the corresponding fields of itself.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_ack_and_window</span><span class="params">(TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> window_size = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (window_size &gt; numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">        window_size = numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seg.<span class="built_in">header</span>().win = window_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And I define <code>send_new_segments</code>, which recursively adds new segments to the <code>_segments_out</code>. The most importantly, we should indicate whether we could write new segments. There are situations the segment we need to send with no payload but with SYN or FIN set or a keep-alive message.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::send_new_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> is_really_send = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        is_really_send = <span class="literal">true</span>;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_really_send;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Also, there are two situations we should send a segment with RST set. So I use a function named <code>send_rst_flag_segment</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_rst_flag_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Also, I define <code>set_error</code> function to handle the RST set segment or we want to send a new RST set segment.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>Now we comes to the most important part, when the client wants to connect the server, it calls the <code>connect</code>. It is simple enough, because I have done the job in the <code>TCPSender</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_new_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file: tcp_sender.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">        _next_seqno += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="segment-received"><a href="#segment-received" class="headerlink" title="segment_received"></a>segment_received</h2><p>For <code>segment_received</code>, it is tricky.</p>
<ol>
<li>We handle the segment with RST set. It is easy.</li>
<li>We should call <code>_receiver.segment_received</code> method to update the acknowledge number and window size.</li>
<li>We check whether the inbound stream is end (the opposite sender would tell us this information), if so, we are the passive, we don’t need the <code>TIME_WAIT</code> timer, set the <code>_linger_after_streams_finish</code> to be <code>false</code>.</li>
<li>When the received segment with ACK set, we should first checkout whether we should accept the segment. If the <code>receiver_ackno()</code> doesn’t exist, we just return. Otherwise, we should call <code>_sender.ack_received</code> and <code>_fill_window()</code> and calls <code>send_new_segments</code>.</li>
<li>Next, we need to handle the situation with no payload.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Reset the accumulated time</span></span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the `rst` flag is set, sets both the inbound and outbound</span></span><br><span class="line">    <span class="comment">// streams to the error state and kills the connection permanently.</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="built_in">set_error</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the receiver would update the acknowledge number and window size</span></span><br><span class="line">    <span class="comment">// of itself.</span></span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the inbound stream ends before the `TCPConnection` has reached EOF</span></span><br><span class="line">    <span class="comment">// on its outbound stream, `_linger_after_streams_finish` should be false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_inbound_stream_assembled_and_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">        <span class="comment">// Corner case: When listening, we should drop all the ACK.</span></span><br><span class="line">        <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        <span class="built_in">send_new_segments</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">send_new_segments</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">            _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>Simple enough.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_new_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="end-input-stream"><a href="#end-input-stream" class="headerlink" title="end_input_stream"></a>end_input_stream</h2><p><code>end_input_stream</code> aims at doing active close. So we first signal the <code>_sender</code>‘s ByteStream to be end and calls <code>_fill_window</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_new_segments</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h2><p>For <code>tick</code>, we should retransmit the segment. If the retransmission time <code>consecutive_retransmissions()</code> is greater than <code>_cfg.MAX_RETX_ATTEMPTS</code>, we should produce a segment with RST set. However, this is not the most important point. When <code>tick</code> is called, for passive closer, it just returns. For active closer we need to make sure that the passive closer has successfully received the <code>ACK</code> sent by the active closer. But we have no idea, so if the passive closer doesn’t retransmit the segment in a period of time, we can think that passive closer has already been closed. Thus we can close the active closer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to retransmit the segments</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">            <span class="built_in">set_error</span>();</span><br><span class="line">            segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_inbound_stream_assembled_and_ended</span>() &amp;&amp; <span class="built_in">check_outbound_stream_ended_and_send_fin</span>() &amp;&amp;</span><br><span class="line">        <span class="built_in">check_outbound_fully_acknowledged</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_linger_after_streams_finish) &#123;</span><br><span class="line">            _active = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">            _active = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://luolibrary.com">shejialuo</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://luolibrary.com/2022/11/28/CS144-Introduction-to-Computer-Networking-Lab-4/">https://luolibrary.com/2022/11/28/CS144-Introduction-to-Computer-Networking-Lab-4/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
      
      <a href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/11/29/CS144-Introduction-to-Computer-Networking-Lab-5/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">CS144: Introduction to Computer Networking Lab 5</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2022/11/23/CS144-Introduction-to-Computer-Networking-Lab-3/">  
        <span class="next-text nav-default">CS144: Introduction to Computer Networking Lab 3</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="utterances-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:shejialuo@gmail.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://twitter.com/luo_hope" class="iconfont icon-twitter" title="twitter"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/jialuo-she-913873289/" class="iconfont icon-linkedin" title="linkedin"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/shejialuo" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2020 - 2024      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">shejialuo</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
  
<script>
  var container = document.getElementById('utterances-container');
  var script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', 'shejialuo/shejialuo.github.io');
  script.setAttribute('issue-term', 'pathname');
  script.setAttribute('theme', 'github-light');
  script.setAttribute('label', 'Comment');
  script.crossorigin = 'anonymous';
  script.async = true;

  container.appendChild(script);
</script>
  
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



<!-- mermaid -->

  <script src='https://unpkg.com/mermaid@9.2.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>