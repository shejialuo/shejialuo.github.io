<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024年终总结</title>
      <link href="/2024/12/26/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/26/2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>眨眼的瞬间，2024年就要过去了。记忆中突然飘来我曾在西电的网安大楼写下了2023年终总结的碎片。如今的我坐在上海的小小出租屋里，不禁回望四周，感慨时间的无情流逝。在这淡淡的哀愁中，我又回想起《将进酒》中的名句。</p><blockquote><p>君不见黄河之水天上来，奔流到海不复回。<br>君不见高堂明镜悲白发，朝如青丝暮成雪。</p></blockquote><p>此时此刻，我的手停留在键盘之上，不知道该如何去表达自己的情感。各种复杂的情感纠结于我心中，无论如何，我只是想刻下自己的存在。</p><h2 id="走向开源世界：Git"><a href="#走向开源世界：Git" class="headerlink" title="走向开源世界：Git"></a>走向开源世界：Git</h2><p>依稀记得2023年的时候，我一个人前往了上海实习，在那个小小的出租屋里，我总会觉得寂寞。突然想起自己在2023年的年终总结刻下的话语：</p><blockquote><p>上班的体验是很好的，然而晚上一个人待在上海小小的出租屋里面，感受到的确实实在的寂寞。突然急切地希望自己身边能有一个人陪伴，然而我却厌恶自己的想法，如果是因为寂寞就去靠近一个人，对她来说这是一个不公平的事情。</p></blockquote><p><strong>必须给自己找点事情做，不想在2024年重蹈覆辙。即便是一个人生活，也想让自己的每天变得精彩，想让自己鲜明地体会到活着的感觉</strong>。怀揣着上面的想法，我决定给自己找一些有意义的事情去做。借着自己最后的学生生涯，我选择参加了谷歌开源之夏（GSoC），荣幸地被Git开源项目选上，为Git的引用实现一致性检查（<a href="https://summerofcode.withgoogle.com/archive/2024/projects/ukm4PTEF">Implement consistency check for refs</a>）。</p><p>在2024年5月到2024年8月期间，经历了许多痛苦（从版本1迭代到了版本16），我的代码终于提交到了Git仓库里面。看到自己能够为这么一个基础的软件做出贡献，自己实现的功能能够被整个世界的程序员使用，我由衷地为自己感到自豪。我十分感谢指导我的两位导师<a href="https://github.com/pks-t">Patrick</a>和<a href="https://github.com/KarthikNayak">Karthik</a>，给予了我大量的指导和帮助。我对Patrick和Karthik在项目结束对我说的一句话印象特别深刻：</p><blockquote><p>Take on the role of the subject matter expert. This is rather hard initially, but at the end of the project you already had quite a lot of knowledge around how the whole infrastructure works. Carefully answering questions, explaining why certain proposals are not feasible or why your tradeoffs are better demonstrates that you know what you are doing. It’s important to find the right balance between taking feedback from others and confidently saying why your version makes sense. (扮演主题专家的角色。这一开始可能会有些困难，但在项目结束时，你已经对整个架构的运作方式积累了相当多的了解。耐心回答问题，解释为什么某些提议不可行，或者为什么你的权衡更优，这些都能展示你对自己的工作了然于心。找到在接受他人反馈和自信地说明自己方案更合理之间的平衡点非常重要。)</p></blockquote><p>在谷歌开源之夏的旅程中除了收获了代码能力的进步，我觉得最大的收获是加强了人与人之间的联系，我与我的两位导师Patrick和Karthik建立了良好的关系。我原先很少用英文和别人交谈，最开始的第一次和Patrick视频会议，我相当的紧张。同时，我觉得和git社区建立了良好的关系，通过一个开源项目能够让生命中本不会产生交集的大家联系起来，体会到了开源的魅力。</p><p>尽管谷歌开源之下在8月底就结束了，我仍然留在Git社区继续完善我该做的工作，并开始审核别人的代码来了解Git其他部分的功能是如何运作的。今年的我提交了20个commit:</p><ol><li><a href="https://github.com/git/git/commit/b3d175409d9bfe005515ffe361e959fb9965111c">Ref consistency check infrastructure setup</a></li><li><a href="https://github.com/git/git/commit/57e81b59f35198afedae18e8363dbffdc96c481d">Ref content consistency check for file backend</a></li></ol><h2 id="研究生毕业"><a href="#研究生毕业" class="headerlink" title="研究生毕业"></a>研究生毕业</h2><p>伴随着6月底的到来，我也从西电毕业了，人生迈入一个新的阶段。比起本科毕业的时候，或许是因为习惯了离别的原因，又或许是期待自己在上海的新生活的原因，我似乎没有那么伤感了。然而，我的内心仍然悸动，看着实验室的工位变得如此干净，总有种自己的存在被抹去的感觉。回想自己在西电的三年，不知道自己是否变得更加温柔了，也不知道自己是否变得更加勇敢了，更不知道自己是否前进了。诸多回忆突然涌入脑海，让我不知所措。</p><p>然而，我深刻地意识到我即将从集体生活转变为个人生活。再也无法和雨晴一起晚上10点后在实验室打玩游戏，一起回寝室了。再也无法简单地在实验室和兄弟们说一句，今天要不要去小码头搓一顿改善一下伙食。我突然觉得伤感，让我想起一句歌词：</p><blockquote><p>倘若从这场梦醒来，我的孤独该付诸何处。</p></blockquote><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>比起2023在上海实习的我，我更习惯一个人的生活了。我觉得是因为我在2023年已经体会了孤独一人的感觉，提前做了一些准备。至少意识到，得利用好自己的时间，如果任凭时间流逝，无所事事就会觉得空虚，。然而，<strong>这样想是不是会太寂寞呢</strong>？我还是不太想妥协，也不想对自己说谎。</p><p>我不知道自己是否做到了怀揣着生命力和想象力去生活，今年从正式工作开始，重拾了阅读的习惯，我真的好久没有看过书了，然而我始终觉得看书是一个很美好的事情，总能让我静下心来。我原先很不会去享受生活，和同事在每天中午溜圈的时候，我才意识到自己的局限性，其实我也是容易待在舒适圈里面的。于是努力去尝试了更多新鲜的事物，自己周末骑自行车到处去逛，偶尔去咖啡馆看书。但是还是很难，一个人的动力是真的太小了。</p><h2 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h2><p>说影响力是不是太膨胀呢？（逃</p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>其实今年最令我开心的时候，莫过于我的博客有7000多的浏览量，一想到我曾经写下的文字或多或少影响到了在这个世界上的某一个陌生人，给他带来了某些启发，又或是鼓舞了他。我由衷地觉得自己的坚持是有意义的。</p><p><img src="https://s2.loli.net/2024/12/26/DaG3KmguAoYftdb.png" alt="博客数据"></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>完成了谷歌开源之夏后，Git社区对我进行了一次<a href="https://git.github.io/rev_news/2024/09/30/edition-115/">采访</a>，我其实对这次采访很是惊讶的，毕竟我觉得我只是完成了一份微小的工作，十分感谢社区的友好。</p><p>可能最开心的还是自己实现的功能上了所谓的<a href="https://s2.loli.net/2024/12/26/DaG3KmguAoYftdb.png">头条</a>，逐渐在这个世界里面刻下自己一些微不足道的存在。</p><p><img src="https://s2.loli.net/2024/12/26/Oc4vSMYy32rXp5A.png" alt="git news"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>耳边传来熟悉的音乐，在这白色相簿的季节，听着“Powder Snow”。</p><blockquote><p>点点细雪轻轻地从天而降<br>接在手心时，我不由得难过<br>停下脚步的你，望着哪个地方呢<br>仰望天空时，是否想起了我们的曾经</p></blockquote><p>在这无形的时间中，简单刻下自己的存在。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>星之终途</title>
      <link href="/2024/08/27/%E6%98%9F%E4%B9%8B%E7%BB%88%E9%80%94/"/>
      <url>/2024/08/27/%E6%98%9F%E4%B9%8B%E7%BB%88%E9%80%94/</url>
      
        <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这部作品我是冲着田中先生的名气购入的，其实我更多的是想看田中先生想在这部作品表达什么观点。本作是一个典型的公路片剧情，不愧为二次元的死亡搁浅。田中以极其紧凑的方式走完了剧情，我打完本部作品仅用了5个小时，还包括了我摘抄的时间。</p><p>我认为作品的核心一如既往地贯穿了田中的理念。我个人认为田中并不是想去探讨所谓的人性，而是一如既往地收束到爱与希望。先抛开对于女主的塑造，片中最大的冲突在于科学家希望通过菲莉亚来拯救人类，然而裘德并不认为人类所需要拯救。我认为这就是田中的核心观点。我也认为人类不需要拯救，人类会一直丑陋地活下去。</p><p>里面有个核心的对于女主的塑造在于“成为人类”。我认为田中的塑造的最好一点是，女主在成为人类的过程中非常地自然，我在里面看到了自己的成长。我特别喜欢女主的这一句话：</p><blockquote><p>菲莉亚：这个世界，难道被设计成了一旦想要帮助他人就会绝对失败的样子吗？</p></blockquote><p>我相信，我们都曾有过这个疑问。这种自嘲的发言让我颇有既视感。</p><p>说实话，本作有很多背景也没有交待清楚，比如说两个阵营AI的斗争，让我又想起了rewrite里面盖亚和守护者的对立。可惜，本作仅仅是短片，并没有继续深入。</p><p>总的来说，体验很好，如同一场电影一般。</p><h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote><p>裘德：活人凑在一起就是这么臭。<br>菲莉亚：如果我也变臭，我就能成为人了吗？<br>裘德：不会的。</p></blockquote><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote><p>……我不懂这种感情。<br>从未想过去理解，以后也没打算理解。<br>想理解这种感情就要拥有家庭。<br>也就是会扎下根。</p></blockquote><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote><p>那时，她也从头到尾没有大喊大叫过。<br>仅仅是用她锐利冷静的目光盯着我，像是在劝说我。<br>态度的言下之意仿佛是我做错了什么。<br>毫无疑问在她心中，残忍就是邪恶。<br>也认为不杀生就是正义。<br>甚至为了这份正义，即使自己挨饿也在所不惜。<br>她一定觉得这是美好的。</p></blockquote><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><blockquote><p>我与她共处的回忆理应数不胜数。<br>然而，这些回忆却无法按照时间顺序衔接起来。<br>事情发生的向后顺序已经变得模糊不清。<br>……这些回忆已经被时间所冲淡。<br>几年前还记得的事情，现在印象已然十分稀薄。<br>留下了深刻印象的，反倒净是些争论争吵。<br>在我看来，她的主张完全是不可理喻的。<br>她不愿意杀死鹿或者兔子，但也并非素质主义者。<br>肉干她一样爱吃。<br>菲莉亚也是如此。<br>保存用的肉类就可以毫无顾忌地吃下去。<br>要我说的话，这只不过是自欺欺人。</p></blockquote><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><blockquote><p>有些人对猎杀哺乳动物有抵触情绪，却对杀鱼或昆虫之类的并不在意。<br>……对我来说是难以理解的想法，但确实是存在的。</p></blockquote><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><blockquote><p>她是一个喜爱美好事物的女人。<br>总是憧憬着人类的尊严与善良，还有不再残酷的世界。<br>也会拒绝拿枪自卫。<br>也不喜欢我携带武装。<br>厌恶枪支。</p></blockquote><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><blockquote><p>裘德：那毕竟人类就是最可怕的。<br>一提到这个话题，菲莉亚的表情就复杂了起来。</p></blockquote><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><blockquote><p>菲莉亚：从一出生就知道所有事情的话，就不太像人类了吧。</p></blockquote><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><blockquote><p>裘德：……你觉得为什么父母会为了孩子舍弃生命？<br>菲莉亚：因为人类很伟大。<br>裘德：不对，有确切的理由。<br>菲莉亚：是什么？<br>裘德：本能。<br>菲莉亚：……？<br>裘德：为什么父母会重视孩子胜过生命？<br>菲莉亚：因为爱他们？<br>裘德：为什么会爱？<br>菲莉亚：因为是自己的孩子？<br>裘德：所以从孩子出生的那一刻起，就爱着他们。<br>菲莉亚：……是吧。<br>裘德：那会是真正的爱吗？<br>菲莉亚：什么意思？<br>裘德：还不知道这个婴儿会是怎样的人，只是因为是自己的孩子就会爱他。<br>裘德：通常情况下，一个人爱上另一个人是在了解对方以后。<br>裘德：但是对孩子的爱却并非如此，而且是无条件且自动的。为什么呢。<br>菲莉亚：……<br>裘德：因为基因在人的本能里刻下了要保护后代的信息。<br>菲莉亚：哎？<br>裘德：我不觉得那必然是一种崇高的行为，单纯只是本能。<br>菲莉亚：那么，父母为了孩子舍弃生命也……<br>裘德：是因为基因命令他们这么做。<br>裘德：不好意思好像是我在破坏你的幻想，但如果你过于理想化人类，总有一天会伤到你自己的。<br>裘德：无法好好爱孩子的父母也是大有人在的。<br>菲莉亚：……但是至少，会有一点真正的爱，对吧？<br>裘德：当然也有。一起生活多年后，不是本能的爱也会掺入进来。如果是那种爱意，我也不是不能理解。<br>菲莉亚：……那就足够了。哪怕只有一点点，都很伟大。<br>菲莉亚：我也是有本能的吗？<br>裘德：你那想成为人类的愿望，正是类似本能的东西。<br>菲莉亚：哦哦。<br>裘德：你为什么想成为人类？<br>菲莉亚：因为想成为。<br>裘德：还是在被出厂设置牵着走啊。<br>裘德：记住，让本能伴随上思考，哪怕是事后想的。那才是人类。<br>菲莉亚：……好难。</p></blockquote><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><blockquote><p>菲莉亚：这个世界，难道被设计成了一旦想要帮助他人就会绝对失败的样子吗？<br>裘德：哈哈哈。<br>菲莉亚：为什么要笑呢？<br>裘德：没什么，只是觉得你说的很对。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游戏笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Final Report</title>
      <link href="/2024/08/25/GSoC-Final-Report/"/>
      <url>/2024/08/25/GSoC-Final-Report/</url>
      
        <content type="html"><![CDATA[<p>Suddenly, I recalled myself writing the proposal back then, and I couldn’t help but feel a bit wistful. Every time it ends, there’s always an unintentional sense of sadness. After three months, my GSoC project has also come to an end.</p><h2 id="The-Motivation-of-The-Project"><a href="#The-Motivation-of-The-Project" class="headerlink" title="The Motivation of The Project"></a>The Motivation of The Project</h2><p>The <code>git-fsck(1)</code> command is mainly used to check the consistency of the object database which misses check for the ref database. Although <code>git-fsck(1)</code> implicitly checks some properties of the ref database when checking connectivity, these checks aren’t sufficient to ensure that all refs are properly consistent like <a href="https://lore.kernel.org/git/6cfee0e4-3285-4f18-91ff-d097da9de737@rd10.de/">report</a> shows.</p><p>The goal of this small GSoC project is to establish the infrastructure for the ref consistency check, enabling developers to easily add checks for both the files backend and the reftable backend. For more detailed information, please refer to the <a href="https://docs.google.com/document/d/1pWnnyykGmJIN-wyosZ3PtueFfs_BRdvJq-cwroRorBI/">proposal</a>.</p><h2 id="The-Patches"><a href="#The-Patches" class="headerlink" title="The Patches"></a>The Patches</h2><p>I began my work by implementing the infrastructure. However, during the review process, the design underwent significant changes. My main focus was on the following tasks:</p><ol><li>Refactoring the fsck error messages to make them generic, allowing both the object database and the ref database to use the same fsck error message interfaces to avoid repetition.</li><li>Utilizing the existing polymorphism provided by the <code>ref_storage_be</code> structure. For every backend, it needs to provide its own function pointer which would bring a lot of flexibility.</li><li>Designing extensible interfaces for checking ref consistency in the files backend.</li><li>Adding a ref name consistency check for the files backend.</li></ol><p>The ultimate merged patch links are given below:</p><ul><li><a href="https://lore.kernel.org/git/ZrSq3Z8tYrGwBOqC@ArchLinux/">[GSoC][PATCH v16 1&#x2F;9] fsck: rename “skiplist” to “skip_oids”</a>.</li><li><a href="https://lore.kernel.org/git/ZrSq6XV8hKRZMrnt@ArchLinux/">[GSoC][PATCH v16 2&#x2F;9] fsck: rename objects-related fsck error functions</a></li><li><a href="https://lore.kernel.org/git/ZrSrdwOCWrXpMYIA@ArchLinux/">[GSoC][PATCH v16 3&#x2F;9] fsck: make “fsck_error” callback generic</a></li><li><a href="https://lore.kernel.org/git/ZrSrgRGwI_jldprn@ArchLinux/">[GSoC][PATCH v16 4&#x2F;9] fsck: add a unified interface for reporting fsck messages</a></li><li><a href="https://lore.kernel.org/git/ZrSrjO2ltoJuppKA@ArchLinux/">[GSoC][PATCH v16 5&#x2F;9] fsck: add refs report function</a></li><li><a href="https://lore.kernel.org/git/ZrSrlU8TesYsTb2C@ArchLinux/">[GSoC][PATCH v16 6&#x2F;9] refs: set up ref consistency check infrastructure</a></li><li><a href="https://lore.kernel.org/git/ZrSroE8vLlZCK2jp@ArchLinux/">[GSoC][PATCH v16 7&#x2F;9] builtin&#x2F;refs: add verify subcommand</a></li><li><a href="https://lore.kernel.org/git/ZrSsk27zqOqSXTpH@ArchLinux/">[GSoC][PATCH v16 8&#x2F;9] files-backend: add unified interface for refs scanning</a></li><li><a href="https://lore.kernel.org/git/ZrSsngBqfyTPDg7g@ArchLinux/">[GSoC][PATCH v16 9&#x2F;9] fsck: add ref name check for files backend</a></li></ul><p>This series has finally been merged into the <a href="https://github.com/git/git/commit/b3d175409d9bfe005515ffe361e959fb9965111c">master</a> branch.</p><p>After establishing the infrastructure, I continue to implement additional checks for the files backend, as shown in the following patch links:</p><ul><li><a href="https://lore.kernel.org/git/ZsIM0L72bei9Fudt@ArchLinux/">[PATCH v1 1&#x2F;4] fsck: introduce “FSCK_REF_REPORT_DEFAULT” macro</a></li><li><a href="https://lore.kernel.org/git/ZsIM2DRDbJsvNjAM@ArchLinux/">[PATCH v1 2&#x2F;4] ref: add regular ref content check for files backend</a></li><li><a href="https://lore.kernel.org/git/ZsIM4OZWfylcP5Ix@ArchLinux/">[PATCH v1 3&#x2F;4] ref: add symbolic ref content check for files backend</a></li><li><a href="https://lore.kernel.org/git/ZsIM6JZ7miA3j09j@ArchLinux/">[PATCH v1 4&#x2F;4] ref: add symlink ref consistency check for files backend</a></li></ul><p>However, this series is still under review, and I plan to continue following up after GSoC.</p><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><h3 id="Design-Challenge"><a href="#Design-Challenge" class="headerlink" title="Design Challenge"></a>Design Challenge</h3><p>Implementation is much more complex than refactoring. One of my intuitive feelings is that when designing something myself, I need to consider many factors. However, during the implementation process, I made many mistakes, mainly in two areas:</p><ol><li>Over-engineering: I was always concerned about the extensibility of the implementation, worried that poor design would require future refactoring. However, I didn’t realize that this could introduce noise into the code. We should focus solely on the features we need right now.</li><li>Inability to balance between building something that can be easily extended in the future and something that is specific to the task at hand.</li></ol><p>Here are the challenges I encountered during the implementation process:</p><h4 id="Whether-We-Need-To-Refactor-“fsck-options”"><a href="#Whether-We-Need-To-Refactor-“fsck-options”" class="headerlink" title="Whether We Need To Refactor “fsck_options”"></a>Whether We Need To Refactor “fsck_options”</h4><p>There are many fields in fsck_options that are specific to the object database. My first mistake was trying to make <code>fsck_options</code> contain the general options and sub-structures, which is what I attempted in the previous patch.</p><blockquote><p>The git-fsck(1) focuses on object database consistency check. It relies on the “fsck_options” to interact with fsck error levels. However “fsck_options” aims at checking the object database which contains a lot of fields only related to object database.</p><p>In order to add ref operations, create a new struct named “fsck_refs_options” and a new struct named “fsck_objs_options”. Remove object-related fields from “fsck_options” to “fsck_objs_options”. Change the “fsck_options” with three parts of members:</p><ol><li>The “fsck_refs_options”.</li><li>The “fsck_objs_options”.</li><li>The common settings both for refs and objects. Because we leave common settings in “fsck_options”. The setup process could be fully reused without any code changing.</li></ol></blockquote><p>While this approach may seem natural, it introduced a lot of complexity because there is a significant amount of existing code that accepts <code>struct fsck_options *</code> as a parameter. As a result, we had to deal with a lot of code that was not directly related to our main goal. In the final implementation, I simply added a <code>verbose</code> field to the <code>fsck_options</code>.</p><p>Junio gave me a wonderful suggestion:</p><blockquote><p>Just like premature optimization is bad, premature factoring and over-modularization is bad.</p></blockquote><h4 id="How-to-Reuse-“report”-Function"><a href="#How-to-Reuse-“report”-Function" class="headerlink" title="How to Reuse “report” Function"></a>How to Reuse “report” Function</h4><p>To adapt to the existing fsck error levels, my initial approach was to create a new <code>fsck_report_ref</code> function that was separate from the object report function <code>report</code>. However, Patrick, Karthik, and Junio disagreed with this design, suggesting that I should reuse the <code>report</code> function.</p><p>The <code>report</code> function is closely tied to object reporting. At the time, I considered adding parameters to the <code>report</code> function and its corresponding callback function <code>error_func</code> to make their prototypes consistent. However, I was not satisfied with this solution because we couldn’t predict whether additional parameters would be needed for other ref checks in the future, which would result in poor extensibility.</p><p>But Patrick gave me a wonderful suggestion which eventually solved the problem:</p><blockquote><p>A better design would likely be to make <code>error_func()</code> receive a <code>void*</code> pointer such that <code>error_func()</code> and then have the respective subsystems provide a function that knows to format the message while receiving either a <code>struct fsck_object_report *</code> or a <code>struct fsck_ref_report *</code>.</p></blockquote><h3 id="Long-Review-Duration"><a href="#Long-Review-Duration" class="headerlink" title="Long Review Duration"></a>Long Review Duration</h3><p>Building the ref consistency check infrastructure posed challenges not only in terms of design and coding but also due to the lengthy review process. This created a significant mental burden for me during the middle of GSoC. This is what I have recorded in my <a href="https://luolibrary.com/2024/07/16/GSoC-Week-7/">GSoC Week 7</a> blog:</p><blockquote><p>The recent challenges I’ve encountered mainly stem from two aspects. Over the past two weeks, I’ve felt mentally exhausted because I haven’t received much positive feedback. Since May 30th, my first patch is still under review. Sometimes, I can’t help but feel the pressure from my peers. Seeing other GSoC participants successfully merge several patches does indeed make me feel pressured. Therefore, I realize that I must learn how to adjust my mindset during prolonged review periods.</p></blockquote><h2 id="After-GSoC"><a href="#After-GSoC" class="headerlink" title="After GSoC"></a>After GSoC</h2><p>After GSoC, I decided to remain involved with the Git community to continue the work I need to complete. My tentative roadmap is as follows:</p><ol><li>Implement the pack-refs consistency check for the files backend.</li><li>Implement the reflogs consistency check for the files backend.</li><li>Implement the consistency check for the reftable backend.</li><li>Separate the object database check logic from <code>git-fsck(1)</code>.</li><li>Enhance the <code>git-fsck(1)</code> command to allow users to easily disable subprocess checks, providing greater flexibility.</li></ol><p>There is a lot to accomplish, which is exciting!</p><h2 id="Closing-Remarks"><a href="#Closing-Remarks" class="headerlink" title="Closing Remarks"></a>Closing Remarks</h2><p>During my GSoC journey, besides improving my coding skills, I believe the greatest gain was strengthening connections between people. I established a good relationship with my two mentors, Patrick and Karthik. Initially, I rarely conversed in English with others, and during my first video meeting with Patrick, I was quite nervous, worried about my limited English speaking skills.</p><p>Additionally, I feel that I have built a good relationship with the Git community. Through an open-source project, I experienced the charm of open source, as it connects people who might not have otherwise crossed paths in life.</p><p>I am especially grateful to my two mentors from GitLab, <a href="https://gitlab.com/pks-gitlab">Patrick</a> and <a href="https://www.linkedin.com/in/karthik%2Dnayak/">Karthik</a>. They provided me with a lot of guidance, embodying the role of a teacher who imparts knowledge and resolves doubts. I also want to thank <a href="https://github.com/gitster/">Junio</a>, Eric, and <a href="https://www.linkedin.com/in/justintobler/">Justin</a> for their meticulous and detailed work during the code review process, which made the final implementation exceptionally elegant.</p><p>I also feel quite proud of myself for being able to implement a new feature for foundational software used by so many people, something I once thought could only happen in my dreams. I am very grateful for this experience and hope that I can become a mentor in the future, igniting the flame in others’ hearts.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 10-11</title>
      <link href="/2024/08/13/GSoC-Week-10-11/"/>
      <url>/2024/08/13/GSoC-Week-10-11/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>In these two weeks, I continue to solve the reviews. After I have sent the <a href="https://lore.kernel.org/git/ZqeXrPROpEg_pRS2@ArchLinux/">Patch v13</a>. Patrick gives an opinion here, we want to reuse the <code>fsck_vreport</code> function here. We want to make it generic but we design the callback not generic. And Patrick gives a wonderful idea here:</p><blockquote><p>A better design would likely be to make <code>error_func()</code> receive a <code>void*</code> pointer such that <code>error_func()</code> and then have the respective subsystems provide a function that knows to format the message while receiving either a <code>struct fsck_object_report *</code> or a <code>struct fsck_ref_report *</code>.</p></blockquote><p>However, Patrick thinks we may put unnecessary effort here to make things complicated again. But after discussion, I think we should use the below design for the following reasons:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fsck_error)</span><span class="params">(<span class="keyword">struct</span> fsck_options *o,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *info,</span></span><br><span class="line"><span class="params">                          <span class="keyword">enum</span> fsck_msg_type msg_type, <span class="keyword">enum</span> fsck_msg_id msg_id,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span> *message)</span>;</span><br></pre></td></tr></table></figure><ol><li>We only expose one interface called <code>fsck_reportf</code> which will make the code clear. Actually, there is no different between reporting refs and reporting objects.</li><li>We provide more extensibility here, because we will never change <code>fsck_reportf</code> and <code>fsck_error</code> prototype when we want to add more info for either refs or objects.</li></ol><p>And Patrick advices me that I should drop the last patch “[PATCH v13 10&#x2F;10] fsck: add ref content check for files backend”, because we should speed up the review process due to the ddl of GSoC.</p><p>And Junio gives two advices:</p><ol><li>The prototype of <code>files_fsck_refs_fn</code> should adapt to the Patrick’s new change.</li><li>Unless the most common use of an array is to pass it around as a collection of items and operate on the collection, it is a better practice to name an array with a singular noun.  Name the array as <code>fsck_refs_fn[]</code> not <code>fsck_refs_fns[]</code>.</li></ol><p>I solve these problems in <a href="https://lore.kernel.org/git/ZqulmWVBaeyP4blf@ArchLinux/">Patch v14</a>:</p><ol><li>By following the advice from Patrick, we should make the callback function be generic by adding only one <code>void *fsck_report</code> parameter. Thus the commit sequence will be much more clearer. And it wll be much easier for reviewers to review. And I have split the commit into more commits in this version.</li><li>Enhance the commit messages to provide more context about why we should do this.</li><li>Patrick advices that we should initialize the <code>fsck_options</code> member when parsing the options. However, because the original <code>strict</code> and <code>verbose</code> field are defined as the bit field, we cannot take the address of them. So I simply remove the bit field.</li><li>As Patrick said, “.lock” should not be reported as error. At current, ignore files ending with “.lock”.</li><li>Add a fsck msg type called “badRefFiletype” which indicates that a ref has a bad file type when scanning the directory.</li><li>Junio advices instead of using <code>fsck_refs_fns</code>, we should use the singular version <code>fsck_refs_fn</code>, fix this.</li><li>Drop the last patch because in this series, we mainly focus on the infra, I will add a series later to add ref content check.</li></ol><p>And I only do some minor changes in <a href="https://lore.kernel.org/git/ZrEBKjzbyxtMdCCx@ArchLinux/">Patch v15</a> and <a href="https://lore.kernel.org/git/ZrSqMmD-quQ18a9F@ArchLinux.localdomain/">Patch v16</a>.</p><p>The code is merged into <a href="https://github.com/git/git/commit/3bde10da94b1424849233d19eeeab475c7a57152">next</a>. What a long journey.</p><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>My GSoC is going to end. But my contribution to Git will bot end. I will implement ref content check. And I will concentrate on writing the final report.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824: MapReduce</title>
      <link href="/2024/08/04/MIT6-824-MapReduce/"/>
      <url>/2024/08/04/MIT6-824-MapReduce/</url>
      
        <content type="html"><![CDATA[<p>This is my record for finish MIT 6.824(spring 2022) first lab <a href="http://nil.csail.mit.edu/6.824/2022/labs/lab-mr.html">MapReduce</a>.</p><h2 id="Sequence-Version"><a href="#Sequence-Version" class="headerlink" title="Sequence Version"></a>Sequence Version</h2><p>Before we dive into how to solve this problem, we first need to understand the sequence version. First, we look at how <code>Map</code> operates.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">intermediate := []mr.KeyValue&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _ filename := <span class="keyword">range</span> os Args[<span class="number">2</span>:] &#123;</span><br><span class="line">  file, err := os.Open(filename)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  content, err := io.ReadAll(file)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;cannot read %v&quot;</span>, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  file.Close()</span><br><span class="line">  kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line">  intermediate = <span class="built_in">append</span>(intermediate, kva...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The idea for above code is simple. It just calls the user-provided <code>Map</code> function to generate the key-value pair struct <code>mr.KeyValue</code> and put the results into <code>intermediate</code>.</p><p>Next we need to partitioning the <code>intermediate</code> to make it into groups. Actually, we can just sort the results. This is also what the code does.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(ByKey(intermediate))</span><br></pre></td></tr></table></figure><p>Now next we need to call user-provided <code>Reduce</code> function. This is also easy. We have already sorted the <code>intermediate</code>. Now we just handle the groups one by one.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">  j := i + <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> j &lt; <span class="built_in">len</span>(intermediate) &amp;&amp; intermediate[j].key == intermediate[i].key &#123;</span><br><span class="line">    j++</span><br><span class="line">  &#125;</span><br><span class="line">  values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">    values = <span class="built_in">append</span>(values, intermediate[k].Value)</span><br><span class="line">  &#125;</span><br><span class="line">  output := reducef(intermediate[i].Key, values)</span><br><span class="line">  fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line">  i = j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Need-Analysis"><a href="#Need-Analysis" class="headerlink" title="Need Analysis"></a>Need Analysis</h2><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>For MapReduce, there should be a coordinator which allocates the tasks. And the coordinator should use data structure to hold the status. The coordinator could not record the result file of the <code>Map</code> operation, because we have used some rules to make a pattern match.</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>However, for a worker, things would be complicated. In the code, worker could do both <code>Map</code> and <code>Reduce</code>. I don’t think it is a good idea to make them exclusively. So for a worker, it should start two goroutines, one for <code>Map</code> and another for <code>Reduce</code>.</p><p>For <code>Map</code> operation, we should achieve the following functionality:</p><ul><li>Divide the intermediate keys into buckets for <code>nReduce</code> reduce tasks where <code>nReduce</code> is the number of reduce tasks.</li><li>The intermediate files name should be <code>mr-X-Y</code>, where <code>X</code> is the Map task number, and <code>Y</code> is the reduce task number.</li><li>Use <code>encoding/json</code> package to write the key&#x2F;value pairs in JSON format to intermediate files.</li></ul><p>For <code>Reduce</code> operation, we should achieve the following functionality:</p><ul><li>Use <code>encoding/json</code> package to read the key&#x2F;value paris in JSON format from intermediate files.</li><li>Put the output of the Xth reduce task in the file <code>mr-out-X</code>.</li></ul><h2 id="Data-Structure-Design"><a href="#Data-Structure-Design" class="headerlink" title="Data Structure Design"></a>Data Structure Design</h2><p>There are the following things we need to consider:</p><ul><li><p>We need to use the semantic words to represent the states both for the coordinator and workers. However, golang doesn’t provide <code>enum</code> type like C&#x2F;C++. So I decide to use <code>const</code> to emulate the <code>enum</code> type like the following:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WorkingStatus <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  idle       WorkingStatus = <span class="number">0</span></span><br><span class="line">  processing WorkingStatus = <span class="number">1</span></span><br><span class="line">  failed     WorkingStatus = <span class="number">2</span></span><br><span class="line">  terminated WorkingStatus = <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>We need to store the tasks we need to handle in the coordinator and also we need to allocate this task for worker. So we need a way to represent the <code>Map</code> and <code>Reduce</code> task.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapTask <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID       <span class="type">int</span>    <span class="comment">// the current map task id</span></span><br><span class="line">  Filename <span class="type">string</span> <span class="comment">// the file which the map task is processing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID           <span class="type">int</span> <span class="comment">// the current reduce task id</span></span><br><span class="line">  MapTaskTotal <span class="type">int</span> <span class="comment">// the current total map task num for the reduce task</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>We need to store the worker information, because the worker may crash. If we do not store this state, we cannot do any crash recovery. Because a worker will handle <code>Map</code>and <code>Reduce</code> task, so we need to also create states to hold task status. I create a <code>WorkerState</code> to combine the <code>MapWorker</code> and <code>ReduceWorker</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">status    WorkingStatus <span class="comment">// status</span></span><br><span class="line">task      MapTask       <span class="comment">// current task</span></span><br><span class="line">startTime time.Time     <span class="comment">// map task start time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReduceWorker <span class="keyword">struct</span> &#123;</span><br><span class="line">  status    WorkingStatus <span class="comment">// status</span></span><br><span class="line">  task      ReduceTask    <span class="comment">// current task</span></span><br><span class="line">  startTime time.Time     <span class="comment">// reduce task start time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WorkerState <span class="keyword">struct</span> &#123;</span><br><span class="line">  id           <span class="type">int</span>          <span class="comment">// Worker identifier</span></span><br><span class="line">  mapWorker    MapWorker    <span class="comment">// the map worker</span></span><br><span class="line">  reduceWorker ReduceWorker <span class="comment">// the reduce worker</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>And we could the following data structure for coordinator:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">  worker                []WorkerState <span class="comment">// To store the status of the workers</span></span><br><span class="line">  mapTask               []MapTask     <span class="comment">// The map tasks to be done</span></span><br><span class="line">  reduceTask            []ReduceTask  <span class="comment">// The reduce tasks to be done</span></span><br><span class="line">  mapTaskNum            <span class="type">int</span>           <span class="comment">// The total number of map task</span></span><br><span class="line">  reduceTaskNum         <span class="type">int</span>           <span class="comment">// The total number of reduce task</span></span><br><span class="line">  mapTaskFinishedNum    <span class="type">int</span>           <span class="comment">// The number of mapTask finished</span></span><br><span class="line">  reduceTaskFinishedNum <span class="type">int</span>           <span class="comment">// The number of reduceTask finished</span></span><br><span class="line">  allMapFinished        <span class="type">bool</span>          <span class="comment">// To indicate whether all Map operations are finished</span></span><br><span class="line">  allReduceFinished     <span class="type">bool</span>          <span class="comment">// To indicate whether all Reduce operations are finished</span></span><br><span class="line">  status                WorkingStatus <span class="comment">// The status of the coordinator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RPC-Operations"><a href="#RPC-Operations" class="headerlink" title="RPC Operations"></a>RPC Operations</h2><p>Next, we need to handle the rpc operations where we need to consider the synchronization between workers and coordinator.</p><h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p>When a worker is initialized, it should call <code>Register</code> RPC. The coordinator should lock the mutex and update the <code>worker</code> field and return the id and the reduce bucket to the worker like the following:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegisterRequest <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RegisterResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span> <span class="comment">// the worker identifier</span></span><br><span class="line">  NReduce <span class="type">int</span> <span class="comment">// the reduce bucket</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Register(request *RegisterRequest, response *RegisterResponse) <span class="type">error</span> &#123;</span><br><span class="line">  mutex.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"></span><br><span class="line">  newId := <span class="built_in">len</span>(c.worker)</span><br><span class="line"></span><br><span class="line">  newWorker := WorkerState&#123;</span><br><span class="line">    id: newId,</span><br><span class="line">    mapWorker: MapWorker&#123;</span><br><span class="line">      status: idle,</span><br><span class="line">    &#125;,</span><br><span class="line">    reduceWorker: ReduceWorker&#123;</span><br><span class="line">      status: idle,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  c.worker = <span class="built_in">append</span>(c.worker, newWorker)</span><br><span class="line"></span><br><span class="line">  response.ID = newId</span><br><span class="line">  response.NReduce = c.reduceTaskNum</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Request-Map-Task"><a href="#Request-Map-Task" class="headerlink" title="Request Map Task"></a>Request Map Task</h3><p>When the workers want to request map task, it should call <code>MapRequest</code> RPC. However, when there is no task available allocated to the worker, we should block the process in RPC call. You could see the following code to understand the detail.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapTaskRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="type">int</span> <span class="comment">// the worker identifier</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapTaskResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">  Task     MapTask</span><br><span class="line">  Shutdown <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> MapRequest(</span><br><span class="line">  request *MapTaskRequest,</span><br><span class="line">  response *MapTaskResponse) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">  condMap.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> condMap.L.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Here, we use `len(c.filenames)` to indicate whether there is</span></span><br><span class="line">  <span class="comment">// an available task for `Map` operation.</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(c.mapTask) == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If all of the `Map` operation is finished, we should</span></span><br><span class="line">    <span class="comment">// set the `Shutdown` field to `true` and return.</span></span><br><span class="line">    <span class="keyword">if</span> c.allMapFinished &#123;</span><br><span class="line">      response.Shutdown = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    condMap.Wait()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We should return map task back to the `Map`</span></span><br><span class="line">  response.Task = c.mapTask[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Here, we should store the information of the worker</span></span><br><span class="line">  c.worker[request.ID].mapWorker.task = c.mapTask[<span class="number">0</span>]</span><br><span class="line">  c.worker[request.ID].mapWorker.status = processing</span><br><span class="line">  c.worker[request.ID].mapWorker.startTime = time.Now()</span><br><span class="line"></span><br><span class="line">  c.mapTask = c.mapTask[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-Map-Task"><a href="#Finish-Map-Task" class="headerlink" title="Finish Map Task"></a>Finish Map Task</h3><p>When the workers finish the <code>Map</code> operation, it should call <code>MapFinish</code> to indicate the coordinator that “I have finished this task”. However, there are so many details we need to consider:</p><ol><li>There are some tasks running too much time which we will consider they are failed. If later the coordinator receives the <code>MapFinish</code> request, we should simply indicate the workers that they should be shutdown.</li><li>Because the workers may crash, we should never write the real name here. Instead workers should create temp file name. The coordinator should rename this in the RPC call. So we need to add a new field <code>Info</code> representing the mapping between the temp file name and the original file name.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapTaskRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  Info <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> MapFinish(</span><br><span class="line">  request *MapTaskRequest,</span><br><span class="line">  response *MapTaskResponse) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">  mutex.Lock()</span><br><span class="line">  <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> c.worker[request.ID].mapWorker.status == failed ||</span><br><span class="line">    c.allMapFinished &#123;</span><br><span class="line">    response.Shutdown = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> c.worker[request.ID].mapWorker.status == processing &amp;&amp; !c.allMapFinished &#123;</span><br><span class="line"></span><br><span class="line">    c.mapTaskFinishedNum++</span><br><span class="line"></span><br><span class="line">    c.worker[request.ID].mapWorker.status = idle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> temp, original := <span class="keyword">range</span> request.Info &#123;</span><br><span class="line">      os.Rename(temp, original)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When all the `Map` operation is finished we should broadcast for</span></span><br><span class="line">    <span class="comment">// `Reduce` operation. Pay attention that `len(c.filenames) == 0`</span></span><br><span class="line">    <span class="keyword">if</span> c.mapTaskFinishedNum == c.mapTaskNum &#123;</span><br><span class="line">      c.allMapFinished = <span class="literal">true</span></span><br><span class="line">      condReduce.Broadcast()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The <code>ReduceRequest</code> and <code>ReduceFinish</code> functions are like <code>MapRequest</code> and <code>MapFinish</code>. I omit the detail here.</p><h2 id="Coordinator-Operations"><a href="#Coordinator-Operations" class="headerlink" title="Coordinator Operations"></a>Coordinator Operations</h2><p>There are two operations we need to consider for coordinator, one is that coordinator needs to check the liveness of the each worker for executing crash recovery. I define a goroutine <code>checkLiveness</code> here.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> checkLiveness() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    done := c.Done()</span><br><span class="line">    <span class="keyword">if</span> done &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex.Lock()</span><br><span class="line"></span><br><span class="line">    mapRestartTime := <span class="number">0</span></span><br><span class="line">    reduceRestartTime := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c.worker &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> c.worker[i].mapWorker.status == processing &amp;&amp; time.Since(c.worker[i].mapWorker.startTime).Seconds() &gt; <span class="number">10</span> &#123;</span><br><span class="line">        mapRestartTime++</span><br><span class="line">        c.mapTask = <span class="built_in">append</span>(c.mapTask, MapTask&#123;</span><br><span class="line">          ID:       c.worker[i].mapWorker.task.ID,</span><br><span class="line">          Filename: c.worker[i].mapWorker.task.Filename,</span><br><span class="line">        &#125;)</span><br><span class="line">        c.worker[i].mapWorker.status = failed</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> c.worker[i].reduceWorker.status == processing &amp;&amp; time.Since(c.worker[i].reduceWorker.startTime).Seconds() &gt; <span class="number">10</span> &#123;</span><br><span class="line">        reduceRestartTime++</span><br><span class="line">        c.reduceTask = <span class="built_in">append</span>(c.reduceTask, ReduceTask&#123;</span><br><span class="line">          MapTaskTotal: c.worker[i].reduceWorker.task.MapTaskTotal,</span><br><span class="line">          ID:           c.worker[i].reduceWorker.task.ID,</span><br><span class="line">        &#125;)</span><br><span class="line">        c.worker[i].reduceWorker.status = failed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; mapRestartTime; i++ &#123;</span><br><span class="line">      condMap.Signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reduceRestartTime; i++ &#123;</span><br><span class="line">      condReduce.Signal()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Worker-Operations"><a href="#Worker-Operations" class="headerlink" title="Worker Operations"></a>Worker Operations</h2><p>The entrypoint is the <code>Worker</code> function, we will start two goroutine in this function, one is used for handling <code>mapProcess</code> and the other is used for handling <code>reduceProcess</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">  reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When there is a new worker, we should call RPC</span></span><br><span class="line">  <span class="comment">// `RegisterRPC`.</span></span><br><span class="line">  response := RegisterResponse&#123;&#125;</span><br><span class="line">  request := RegisterRequest&#123;&#125;</span><br><span class="line">  mutex = sync.Mutex&#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> !RegisterRPC(&amp;request, &amp;response) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> mapProcess(mapf, response.ID, response.NReduce)</span><br><span class="line">  <span class="keyword">go</span> reduceProcess(reducef, response.ID, response.NReduce)</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapProcess</code> goroutine will handle the following things:</p><ol><li>Firstly uses <code>MapRequestRPC</code> to request one job from coordinator, and the most two important things got from coordinator is the <code>MapTask</code> structure.</li><li>We need to maintain the mapping between the temp file name and the original filename.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapProcess</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue, id <span class="type">int</span>, nReduce <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    request := MapTaskRequest&#123;ID: id&#125;</span><br><span class="line">    response := MapTaskResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !MapRequestRPC(&amp;request, &amp;response) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the coordinator is terminated, we should terminate</span></span><br><span class="line">    <span class="comment">// the `mapProcess`</span></span><br><span class="line">    <span class="keyword">if</span> response.Shutdown &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tempToOriginal := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    intermediate := []KeyValue&#123;&#125;</span><br><span class="line">    filename := response.Task.Filename</span><br><span class="line">    file, _ := os.Open(filename)</span><br><span class="line">    content, _ := io.ReadAll(file)</span><br><span class="line">    file.Close()</span><br><span class="line">    kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line">    intermediate = <span class="built_in">append</span>(intermediate, kva...)</span><br><span class="line"></span><br><span class="line">    outputNamePrefix := fmt.Sprintf(<span class="string">&quot;mr-%d-&quot;</span>, response.Task.ID)</span><br><span class="line"></span><br><span class="line">    outputFile := []*os.File&#123;&#125;</span><br><span class="line">    enc := []*json.Encoder&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= nReduce; i++ &#123;</span><br><span class="line">      outputName := fmt.Sprintf(<span class="string">&quot;%s%d&quot;</span>, outputNamePrefix, i)</span><br><span class="line">      tempFile, _ := os.CreateTemp(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;tempfile-&quot;</span>)</span><br><span class="line">      tempToOriginal[tempFile.Name()] = outputName</span><br><span class="line"></span><br><span class="line">      encTemp := json.NewEncoder(tempFile)</span><br><span class="line">      outputFile = <span class="built_in">append</span>(outputFile, tempFile)</span><br><span class="line">      enc = <span class="built_in">append</span>(enc, encTemp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, kv := <span class="keyword">range</span> intermediate &#123;</span><br><span class="line">      reduceNum := ihash(kv.Key) % nReduce</span><br><span class="line">      enc[reduceNum].Encode(kv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> outputFile &#123;</span><br><span class="line">      file.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request.Info = tempToOriginal</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !MapFinishRPC(&amp;request, &amp;response) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> tempToOriginal &#123;</span><br><span class="line">      <span class="built_in">delete</span>(tempToOriginal, k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reduceProcess</code> is just the same as <code>mapProcess</code>. Actually, from my perspective, there is nothing different.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceProcess</span><span class="params">(reducef <span class="keyword">func</span>(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>, id <span class="type">int</span>, nReduce <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">    request := ReduceTaskRequest&#123;ID: id&#125;</span><br><span class="line">    response := ReduceTaskResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !ReduceRequestRPC(&amp;request, &amp;response) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> response.Shutdown &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intermediate := []KeyValue&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= response.Task.MapTaskTotal; i++ &#123;</span><br><span class="line">      inputName := fmt.Sprintf(<span class="string">&quot;mr-%d-%d&quot;</span>, i, response.Task.ID)</span><br><span class="line">      file, _ := os.Open(inputName)</span><br><span class="line">      dec := json.NewDecoder(file)</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> temp KeyValue</span><br><span class="line">        <span class="keyword">if</span> err := dec.Decode(&amp;temp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        intermediate = <span class="built_in">append</span>(intermediate, temp)</span><br><span class="line">      &#125;</span><br><span class="line">      file.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Sort(ByKey(intermediate))</span><br><span class="line"></span><br><span class="line">    temporaryToOriginal := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    outputName := fmt.Sprintf(<span class="string">&quot;mr-out-%d&quot;</span>, response.Task.ID)</span><br><span class="line">    tempFile, _ := os.CreateTemp(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;tempfile-&quot;</span>)</span><br><span class="line">    temporaryToOriginal[tempFile.Name()] = outputName</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">      j := i + <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> j &lt; <span class="built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;</span><br><span class="line">        j++</span><br><span class="line">      &#125;</span><br><span class="line">      values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">        values = <span class="built_in">append</span>(values, intermediate[k].Value)</span><br><span class="line">      &#125;</span><br><span class="line">      output := reducef(intermediate[i].Key, values)</span><br><span class="line">      fmt.Fprintf(tempFile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line">      i = j</span><br><span class="line">    &#125;</span><br><span class="line">    tempFile.Close()</span><br><span class="line">    request.Info = temporaryToOriginal</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !ReduceFinishRPC(&amp;request, &amp;response) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MIT6.824 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 8-9</title>
      <link href="/2024/07/28/GSoC-Week-8-9/"/>
      <url>/2024/07/28/GSoC-Week-8-9/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>In these two weeks, I mainly focus on solving the reviews. After I have sent the <a href="https://lore.kernel.org/git/ZpPEdmUN1Z5tqbK3@ArchLinux/">Patch v11</a> to the mailing list. Karthik suggests that instead of using <code>ref_checkee</code> and <code>sub_ref_checkee</code>, we may use the following data structure to provide more extensibility here.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsck_refs_info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *refname;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; reftable;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; files;</span><br><span class="line">       &#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So in <a href="https://lore.kernel.org/git/ZpuCg1GL1YE_sJBP@ArchLinux/">patch v12</a>, I implement the above data structure.</p><p>However, Patrick has a different opinion about this. Patrick thinks this is too complicated. We should make thing simple here. Instead of using a union to represent the options, why we not just use a flat structure here. So I just use the following data structure:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fsck_refs_info</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s simple and we reserve the extensibility here. The code is under review in the <a href="https://github.com/shejialuo/git/pull/11">github</a>. I have already solve the review from Karthik. However, due to the reason that Patrick has just come back to Office. I am waiting for the reviews from Patrick. When everything is OK, I will send the Patch v13 to the mailing list.</p><p>What a long journey!</p><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>Continue to handle the reviews.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 7</title>
      <link href="/2024/07/16/GSoC-Week-7/"/>
      <url>/2024/07/16/GSoC-Week-7/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>In this week, I still put my effort on handling reviews.</p><ul><li><a href="https://lore.kernel.org/git/Zo0sQCBqyxX8dJ-f@ArchLinux/">Patch v9</a>: In version 8, Karthik thinks that instead of renaming <code>skiplist</code> to <code>oid_skiplist</code>, we’d better rename <code>skiptlist</code> to <code>skip_oids</code>. So, I simply apply this idea. And I have made a mistake in version 8, I use the <code>static</code> for a string buf, but I forget to use <code>strbuf_reset</code> for each function call. So I add this statement here. However, Eric thinks that using <code>static</code> variable is a very bad idea, because <code>fsck_refs_error_function</code> should not be called frequently. The design will make the code harder to “libify”. This is one thing I have learned. And Justin has provided some reviews about the commit sequence and commit messages, need to make it clearer.</li><li><a href="https://lore.kernel.org/git/Zo6eJi8BePrQxTQV@ArchLinux/">Patch v10</a>: This patch solves the problem of version 9. But there are some new reviews coming from Junio. The first problem is that we should not name the report interface <code>vfsck_report</code> but “fsck_vreport”, and Junio feels that the current commit sequence is not so clear, need to adjust.</li></ul><p>However, In patch v10, the most important question Junio asks is about the functionality <code>fsck_refs_error_function</code>. The declaration of this function in patch v10 is shown below:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsck_refs_error_function</span><span class="params">(<span class="keyword">struct</span> fsck_options *options UNUSED,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="keyword">struct</span> object_id *oid,</span></span><br><span class="line"><span class="params">                             <span class="keyword">enum</span> object_type object_type UNUSED,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *checked_ref_name,</span></span><br><span class="line"><span class="params">                             <span class="keyword">enum</span> fsck_msg_type msg_type,</span></span><br><span class="line"><span class="params">                             <span class="keyword">enum</span> fsck_msg_id msg_id UNUSED,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *message )</span>;</span><br></pre></td></tr></table></figure><p>Junio thinks above declaration only handles the problem of the single ref such as <code>refs/heads/main</code>. What about the packed-refs?</p><blockquote><p>The error reporting function for refs consistency check was still about reporting a problem for a single ref.  I am wondering how consistency violations that are not about a single ref should be handled.  For example, if <code>refs/packed-backend.c:packed_fsck()</code> finds that the file is not sorted properly or has some unparsable garbage in it, it is not something you can report as “refs&#x2F;heads&#x2F;main is broken”, but those who are interested in seeing the “reference database consistency” verified, it is very much what they want the tool to notice.</p></blockquote><p>So I need to find a way to handle this. So I decide to look at the spec of the packed-refs and reftable refs. And I finally find a way to do this.</p><p>After some investigations, there are the following situations where we should handle when checking ref consistency.</p><ol><li>When checking loose refs and reflofs, we only need the <code>checkee</code> information, because they are standalone files.</li><li>When checking packed-refs, we should check the packed-refs itself, for example whether it is sorted or there are some garbage trailing contents. However, we should also check each ref (<code>sub_checkee</code>) in the file.</li><li>When checking reftable refs, we need to check the binary file, we could still use the idea like 2 case.</li></ol><p>By the above statements, I change the <code>fsck_refs_error_function</code> shown as below:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsck_refs_error_function</span><span class="params">(<span class="keyword">struct</span> fsck_options *options UNUSED,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="keyword">struct</span> object_id *oid,</span></span><br><span class="line"><span class="params">                             <span class="keyword">enum</span> object_type object_type UNUSED,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *ref_checkee,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *sub_ref_checkee,</span></span><br><span class="line"><span class="params">                             <span class="keyword">enum</span> fsck_msg_type msg_type,</span></span><br><span class="line"><span class="params">                             <span class="keyword">enum</span> fsck_msg_id msg_id UNUSED,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">strbuf</span> <span class="title">sb</span> =</span> STRBUF_INIT;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sub_ref_checkee)</span><br><span class="line">        strbuf_addf(&amp;sb, <span class="string">&quot;%s.%s&quot;</span>, ref_checkee, sub_ref_checkee);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        strbuf_addstr(&amp;sb, ref_checkee);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oid)</span><br><span class="line">        strbuf_addf(&amp;sb, <span class="string">&quot; -&gt; (%s)&quot;</span>, oid_to_hex(oid));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg_type == FSCK_WARN)</span><br><span class="line">        warning(<span class="string">&quot;%s: %s&quot;</span>, sb.buf, message);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = error(<span class="string">&quot;%s: %s&quot;</span>, sb.buf, message);</span><br><span class="line"></span><br><span class="line">    strbuf_release(&amp;sb);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It could provide the following report messages:</p><ol><li>“ref_checkee”: “fsck error name”: “user message”.</li><li>“ref_checkee.sub_ref_checkee”: “fsck error name”: “user message”.</li><li>“ref_checkee -&gt; (oid hex)”: “fsck error name”: “user message”.</li><li>“ref_checkee.sub_ref_checkee -&gt; (oid hex)”: “fsck error name”: “user message”.</li></ol><p>This is what I done in <a href="https://lore.kernel.org/git/ZpPEdmUN1Z5tqbK3@ArchLinux/">patch v11</a>.</p><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>It’s important for me to set up the infra of consistency check for refs. Because everything will be built upon that. I think I will continue to handle the reviews.</p><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>The recent challenges I’ve encountered mainly stem from two aspects. Over the past two weeks, I’ve felt mentally exhausted because I haven’t received much positive feedback. Since May 30th, my first patch is still under review. Sometimes, I can’t help but feel the pressure from my peers. Seeing other GSoC participants successfully merge several patches does indeed make me feel pressured. Therefore, I realize that I must learn how to adjust my mindset during prolonged review periods.</p><p>Secondly, there’s the issue raised by Junio regarding how to improve the “fsck_refs_error_function.” Junio actually brought this up in the initial version, but I subconsciously ignored it. Although I am responsible for building the infrastructure, I have limited knowledge about packed-refs and reftable refs. I thought it would be very difficult for me to design a perfect function. However, in the end, I had to face this problem head-on. Sometimes, when I encounter difficult issues, I tend to avoid them subconsciously. Despite this, I eventually found a solution.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 6</title>
      <link href="/2024/07/08/GSoC-Week-6/"/>
      <url>/2024/07/08/GSoC-Week-6/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>In this week, I mainly focus on solving the reviews.</p><ul><li><a href="https://lore.kernel.org/git/ZoLHtmOKTfxMSxvw@ArchLinux/">Patch v6</a>: In this version, I decide to reduce the complexity. However, I still misunderstood what Junio said, I still explicitly extracts two options <code>fsck_refs_options</code> and <code>fsck_objects_options</code> here. In my view, I suppose we could make the code more clean. However, Junio has commented as the following:<blockquote><p>Just like premature optimization is bad, premature factoring and over-modularization is bad.</p></blockquote></li><li><a href="https://lore.kernel.org/git/ZoVX6sn2C9VIeZ38@ArchLinux/">Patch v7</a>: In this version, I just add a new ref-related field <code>verbose_refs</code> into the <code>fsck_options</code> without any over-modularization.</li><li><a href="https://lore.kernel.org/git/ZovqY4vQnQBAs7PH@ArchLinux/">Patch v8</a>: Some commit messages in Patch v7 are not clear which makes the reviewer confused. Enhance the commit messages in this version.</li></ul><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>I guess this series should be OK. After setting up the infrastructure. I decide to add packed-refs consistency checks with the following steps:</p><ol><li>Get a list of checks that packed-refs should checks, discussing with my mentors and the community.</li><li>Implement the code.</li></ol><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>Since becoming a full-time employee, time has become a bit tight. I will manage my time more efficiently.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 4-5</title>
      <link href="/2024/06/30/GSoC-Week-4-5/"/>
      <url>/2024/06/30/GSoC-Week-4-5/</url>
      
        <content type="html"><![CDATA[<h2 id="Personal-Life"><a href="#Personal-Life" class="headerlink" title="Personal Life"></a>Personal Life</h2><p>Due to the need to help prepare for my master’s graduation work and to move to Shanghai to start my job at NVIDIA on July 1st, I have divided the GSoC records into two weeks.</p><h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>In these two weeks, I mainly work on three tasks:</p><ul><li><a href="https://lore.kernel.org/git/ZnKKy52QFO2UhqM6@ArchLinux">Patch v4</a>: In this version, I correct the previous implementation that attempted to use pointer casting and adopt a composition strategy to design the data structure.</li><li><a href="https://lore.kernel.org/git/Zn4xeoqhCeBCSNvg@ArchLinux">Patch v5</a>: In this version, Junio suggest that I should reuse the existing report code. However, I overcomplicate the issue by setting up two parallel data structures, which increases the complexity of the problem.</li><li>Completed the GSoC midterm evaluation. My mentors have given me some really useful advice, especially.<blockquote><p>Find the balance between building something that can be easily extended in the future vs. something that is specific to the task at hand.</p></blockquote></li></ul><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>The next task is still based on the composition structure of the data. Although Junio provided a data structure using a union, I still find it too complex. I have always wanted my implementation to be extensible, which has slightly deviated from the task I was supposed to do.</p><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>I feel that the biggest challenge over these two weeks has been understanding the reviews. Every time I submit changes based on a review, I tend to veer off course a bit. I feel that the reviewers’ comments are aimed at addressing specific issues, while I always strive for a perfect implementation, which has led to a lot of unnecessary work and made the code more complex.</p><p>How to balance this is something I have decided to think about carefully.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 3</title>
      <link href="/2024/06/17/GSoC-Week-3/"/>
      <url>/2024/06/17/GSoC-Week-3/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>This week, I focus on handling the reviews from my mentors and Junio. My mentors have put some comments on the <a href="https://github.com/shejialuo/git/pull/2">PR</a> before I send the patch to the mailing list.</p><h3 id="Reviews-From-Junio"><a href="#Reviews-From-Junio" class="headerlink" title="Reviews From Junio"></a>Reviews From Junio</h3><p>There are many important reviews from Junio. And we have discussed some issues:</p><ol><li>The dangling symref should not be reported by <code>git-fsck(1)</code>. There is a common situation where people would use dangling symref to create the pointee ref. Like Junio said:</li></ol>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git symbolic-ref refs/heads/maint refs/heads/maint-2.46</span><br><span class="line">git branch maint v2.46.0</span><br></pre></td></tr></table></figure><ol start="2"><li>We should change <code>fsck_files_symref</code> to <code>fsck_symref_target</code>. Because we are checking the target not the symref.</li><li>The use of <code>unsigned int *trailing</code> is not proper which will lose a lot of information for the caller.</li><li>The current implementation should check the symbolic link “escape” situation.</li><li>Some error information will cause misleading.</li></ol><h3 id="The-Problems-I-Found"><a href="#The-Problems-I-Found" class="headerlink" title="The Problems I Found"></a>The Problems I Found</h3><p>However, I have still found some problems in the current implementation:</p><ol><li>When checking symref target, the <code>referent</code> buf could be end with <code>&#39;\n&#39;</code>. If we simply pass the <code>referent</code> to <code>check_refname_format</code> function, we will get incorrect behavior.</li><li>The current implementation totally ignores the absolute symbolic link situation.</li><li>The current tests lack testing for symbolic links.I wanna make sure that the symbolic link check will work especially in Windows. I am a little worry about the compatibility.</li></ol><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>So in order to enhance this patch, I will do the following things:</p><ol><li>Change the defined fsck messages and drop the <code>danglingSymref</code>.</li><li>Enhance the checks for symbolic link and add the corresponding tests.</li></ol><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>This week, I spent most of my time addressing reviews. The biggest challenge I encountered was how to reasonably explain my intentions and design ideas when facing others’ reviews. Additionally, understanding the principles and motivations behind the reviews was also challenging. Rather than calling it a challenge, I would say it was a very interesting experience.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 2</title>
      <link href="/2024/06/10/GSoC-Week-2/"/>
      <url>/2024/06/10/GSoC-Week-2/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>This is the second week of writing code. I spend most of my time reading the <code>git-fsck(1)</code> source code and enhance my first-version patch.</p><h3 id="Understand-Fsck-Message"><a href="#Understand-Fsck-Message" class="headerlink" title="Understand Fsck Message"></a>Understand Fsck Message</h3><p>As Junior has commented:</p><blockquote><p>How well does this interact with the fsck error levels (aka fsck_msg_type), by the way?  It should be made to work well if the current design does not.</p></blockquote><p>So the first thing I do in this week is to understand “fsck message”. It takes me a lot of time here.</p><h3 id="Implement-the-Code"><a href="#Implement-the-Code" class="headerlink" title="Implement the Code"></a>Implement the Code</h3><p>After understand how fsck messages works, I continue to start coding. I mainly do the following things like this <a href="https://github.com/shejialuo/git/pull/2">PR</a> shows:</p><ul><li>add refs check interfaces to interface with fsck error levels.</li><li>set up ref consistency check infrastructure.</li><li>add verify subcommand for builtin <code>git-refs</code>.</li><li>add git-refs verify child process for <code>git-fsck(1)</code>.</li><li>add unified interface for refs scanning for files backend.</li><li>add ref name check for files backend.</li><li>add ref content check for files backend.</li></ul><p>However, due to the <code>git-refs</code> has not been merged into the <code>next</code>. I’ll send the patches to the mailing list until everything is OK.</p><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>I need to understand the <code>git-worktree</code>. The current implementation totally ignores worktree.</p><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>This week, I have encountered numerous challenges. The most difficult part for me has been designing the code.</p><p>In the process of integrating the fsck message into the reference consistency check, I encounter numerous design issues. Should I add two new fields directly to <code>fsck_options</code>, or should I create a new structure and reuse existing functions through polymorphism? I ponder this for a long time and ultimately choose the latter to ensure semantic clarity.</p><p>Additionally, I need to name the new fsck messages, which also takes considerable thought. Since I have to implement a new feature myself, coding is not the most complex part; rather, it is the design. How to design it in a way that makes both the semantics and the code clearer takes up a significant amount of my time.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC Week 1</title>
      <link href="/2024/06/02/GSoC-Week-1/"/>
      <url>/2024/06/02/GSoC-Week-1/</url>
      
        <content type="html"><![CDATA[<h2 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h2><p>This is the first week of writing code. I spent most of my time building the infrastructure for the ref consistency check and implementing some consistency checks for the files backend.</p><h3 id="Set-Up-the-Infrastructure"><a href="#Set-Up-the-Infrastructure" class="headerlink" title="Set Up the Infrastructure"></a>Set Up the Infrastructure</h3><p>I reuse the polymorphism provided by <code>ref_storage_be</code> and add a new interface called <code>fsck_fn</code> to facilitate consistency checks for refs as the <a href="https://lore.kernel.org/git/20240530122753.1114818-1-shejialuo@gmail.com/T/#m63c0d98020a814954f26c54c65bf04830bb0862a">refs: setup ref consistency check infrastructure</a> shows. Additionally, I implement dummy methods for different backends to ensure compatibility and extensibility.</p><h3 id="Name-and-Content-Check-For-Files-Backend"><a href="#Name-and-Content-Check-For-Files-Backend" class="headerlink" title="Name and Content Check For Files Backend"></a>Name and Content Check For Files Backend</h3><p>After setting up the infrastructure, I decide to add some basic checks for the file backend. We may need to parse every file located in a specific directory and perform checks on its content or file name. Therefore, I design the following workflow:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iter = dir_iterator_begin(dir, 0);</span><br><span class="line">while (dir_iterator_advance(iter) == ITER_OK)</span><br><span class="line">  if (IS_FILE(iter))</span><br><span class="line">    for (fn = fns; fn; fn++)</span><br><span class="line">      fn(iter)</span><br></pre></td></tr></table></figure><p>And I have written the following code to achieve above pseudo code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*files_fsck_refs_fn)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *refs_check_dir,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> dir_iterator *iter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">files_fsck_refs</span><span class="params">(<span class="keyword">struct</span> ref_store *ref_store,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* refs_check_dir,</span></span><br><span class="line"><span class="params">        files_fsck_refs_fn *fsck_refs_fns)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">while</span> ((iter_status = dir_iterator_advance(iter)) == ITER_OK) &#123;</span><br><span class="line">    error(<span class="string">&quot;test: %s&quot;</span>, iter-&gt;relative_path);</span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(iter-&gt;st.st_mode)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(iter-&gt;st.st_mode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (files_fsck_refs_fn *fsck_refs_fn = fsck_refs_fns;</span><br><span class="line">          *fsck_refs_fn; fsck_refs_fn++) &#123;</span><br><span class="line">        ret |= (*fsck_refs_fn)(refs_check_dir, iter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      error(_(<span class="string">&quot;unexpected file type for &#x27;%s&#x27;&quot;</span>), iter-&gt;basename);</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For name check and content check, we should just following the prototype of <code>files_fsck_refs_fn</code>. Below shows the detail about these two functionalities.</p><ul><li>Name check: use the existing API <code>check_refname_format</code> to check the reference name.</li><li>Content check: check the following two cases.<ul><li>check whether the ref content length is valid and the last character is a newline.</li><li>check whether the content is be range of <code>[0-9a-f]</code>.</li></ul></li></ul><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>There are many limitations for the current implementation:</p><ul><li>The semantic of <code>fsck_fn</code> should be presented either in code using comments or in commit message. As <a href="https://github.com/gitster">Junio</a> said:<blockquote><p>What is the extra blank line doing there?  It makes reader wonder why the .fsck member is somehow very special and different from others.  Is there a valid reason to single it out (and no, “yes this is special because I invented it” does not count as a valid reason)? The same comment applies to a few other places in this patch.</p></blockquote></li><li>The current implementation totally ignores the symbolic ref such as <code>ref: refs/heads/main</code>.<blockquote><p>In any case, the two checks are good ONLY for regular refs and not for symbolic refs.  The users are free to create symbolic refs next to their branches, e.g. here is a way to say, “among the maintenance tracks maint-2.30, maint-2.31, … maint-2.44, maint-2.45, what I consider the primary maintenance track is currently maint-2.45”.</p></blockquote></li><li>The current implementation should consider the real symbolic file.<blockquote><p>The caller also needs to be prepared to find a real symbolic link that is used as a symbolic ref.</p></blockquote></li><li>The content check is not proper.<blockquote><p>I do not think it is a good idea to suddenly redefine what a valid way to write object names in a loose ref file after ~20 years. it should be at most FSCK_WARN when it does not look like what <em>we</em> wrote.</p></blockquote></li><li>The current implementation does not interact with the fsck error levels at all.<blockquote><p>How well does this interact with the fsck error levels (aka fsck_msg_type), by the way?  It should be made to work well if the current design does not.</p></blockquote></li></ul><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>The next plan is very clear now.</p><ul><li>Really understand what <code>git-fsck</code> does to know whether we should port some functions to ref part and also to find a way to interact with teh fsck error levels.</li><li>Enhance the current implementation to support regular file containing symbolic ref and symbolic link file.</li><li>Understand how <code>git-worktree</code> works and incorporate the worktree like <code>git-fsck</code>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC-Community Bonding Period</title>
      <link href="/2024/05/27/GSoC-Community-Bonding-Period/"/>
      <url>/2024/05/27/GSoC-Community-Bonding-Period/</url>
      
        <content type="html"><![CDATA[<p>During the community bonding period, I engaged in various activities to familiarize myself with my mentors, the community, and the git codebase. I had video conferences with each of my two mentors, where we discussed not only how to quickly set up a basic infrastructure for reference consistency checks but also talked about our respective careers and technical exchanges. Additionally, we scheduled bi-weekly video meetings for ongoing synchronization.</p><p>At the same time, all mentors and contributors agreed to an online meeting on June 7th, allowing us to further familiarize ourselves with the community.</p><h2 id="Setup-the-Mutt-to-Improve-Productivity"><a href="#Setup-the-Mutt-to-Improve-Productivity" class="headerlink" title="Setup the Mutt to Improve Productivity"></a>Setup the Mutt to Improve Productivity</h2><p>To enhance the efficiency of handling emails in the community later on, I plan to implement the use of mutt on ArchLinux before the official coding begins, and I have written a blog post called <a href="https://luolibrary.com/2024/05/12/Use-Mutt-in-ArchLinux/">Use Mutt in ArchLinux</a> documenting the configuration process.</p><h2 id="Infrastructure-Implementation"><a href="#Infrastructure-Implementation" class="headerlink" title="Infrastructure Implementation"></a>Infrastructure Implementation</h2><p>Before the official GSoC coding period begins, I was ready to set up the architecture for reference consistency checks as envisioned in the proposal. The core idea is to add a callback to <code>ref_storage_be</code>, then add the functionality to check if the ref name is correct for the file backend, and add code in the <code>fsck.c</code> file for testing.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ref_storage_be</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  check_refs_fn *check_refs;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>My mentors, Patrick and Karthik, have already commented on the corresponding <a href="https://github.com/shejialuo/git/commit/d4c33868502f7a74066cc8bce9c78941b68f58cb">commit</a>, with the main issues focusing on the following aspects:</p><ol><li>The current commit should be split; the first commit should focus on the implementation of the infrastructure, and then the second commit should add the name check for the file backend.</li><li>Do not use refs code to enumerate through the refs here. The reason is that this function would hide broken references from us. Use <code>dir-iterator.h</code> to check <code>refs/</code>.</li><li>Suggestions for some naming changes.</li><li>The need to also check the refs of the worktree.</li></ol><h2 id="Next-Plan"><a href="#Next-Plan" class="headerlink" title="Next Plan"></a>Next Plan</h2><p>I have now essentially completed the coding for the infrastructure. The subsequent work mainly involves addressing the comments from my two mentors on the current commit, then cleaning up the code, and reviewing the code through PRs in my own <a href="https://github.com/shejialuo/git/">repository</a>.</p><p>Secondly, I will maintain an email in the community to organize all updated blogs, making it convenient for the community to promptly follow my updates and provide me with feedback.</p>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Mutt in ArchLinux</title>
      <link href="/2024/05/12/Use-Mutt-in-ArchLinux/"/>
      <url>/2024/05/12/Use-Mutt-in-ArchLinux/</url>
      
        <content type="html"><![CDATA[<p>I successfully configured the Mutt email client a long time ago. Many open-source communities continue to use mailing lists as their primary communication tool, making a plain text email client essential. Mutt is an excellent choice for this purpose. I wrote this blog post to deepen my understanding of Mutt’s processes and to share why it remains relevant and useful in today’s digital communication landscape.</p><p>The following contents are cited from Mutt ArchWiki:</p><blockquote><p>Mutt focuses primarily on being a Mail User Agent (MUA), and was originally written to view mail. Later implementations (added for retrieval, sending, and filtering mail) are simplistic compared to other mail applications and, as such, users may wish to use external applications to extend Mutt’s capabilities.</p><p>Nevertheless, the Arch Linux mutt package is compiled with IMAP, POP3 and SMTP support, removing the necessity for external applications.</p></blockquote><p>Although the ArchLinux mutt package includes SMTP protocol functionality, which could simplify email management, I have decided to stick with the traditional way of using Mutt. This approach allows me to fully understand and control the email handling process, ensuring that I can customize and optimize it according to my specific needs.</p><p>I decide to use the following softwares in Arch Linux (It should work in any UNIX-like environment).</p><ul><li><a href="https://www.fetchmail.info/">fetchmail</a>. It is a mail-retrieval and forwarding utility; it fetches mail from remote mail servers and forwards it to your local machine’s delivery system.</li><li><a href="https://github.com/BuGlessRB/procmail">procmail</a>. A program for filtering, sorting and storing email.</li><li><a href="https://github.com/muttmua/mutt">Mutt</a>. The MUA.</li><li><a href="https://marlam.de/msmtp/">msmtp</a>. A simple SMTP client.</li></ul><h2 id="The-Usage-of-fetchmail"><a href="#The-Usage-of-fetchmail" class="headerlink" title="The Usage of fetchmail"></a>The Usage of fetchmail</h2><p>It’s not hard to use <code>fetchmail</code>. You should carefully read its <a href="https://www.fetchmail.info/fetchmail-man.html">manual</a>. It will explain everything you need.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#  QQMail (FoxMail)</span><br><span class="line">poll imap.qq.com protocol IMAP user &quot;392499367@qq.com&quot; password &quot;&quot; ssl keep</span><br><span class="line">mimedecode</span><br><span class="line">mda &quot;/usr/bin/procmail -f %F -d %T&quot;</span><br><span class="line"></span><br><span class="line"># GMail</span><br><span class="line">poll imap.gmail.com protocol IMAP user &quot;shejialuo@gmail.com&quot; password &quot;&quot; ssl keep</span><br><span class="line">mimedecode</span><br><span class="line">mda &quot;/usr/bin/procmail -f %F -d %T&quot;</span><br></pre></td></tr></table></figure><p>The <code>fetchmail</code> will eventually call <code>procmail</code> for directing the emails.</p><h2 id="The-Usage-of-procmail"><a href="#The-Usage-of-procmail" class="headerlink" title="The Usage of procmail"></a>The Usage of procmail</h2><p>The functionality of <code>procmail</code> is very powerful. However, power sometimes can cause a lot of trouble. So, I only use <code>procmail</code> to put the received email into the corresponding inbox.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">MAILDIR=$HOME</span><br><span class="line">VERBOSE=off</span><br><span class="line">LOGFILE=/tmp/procmaillog</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^TO392499367@qq\.com</span><br><span class="line">Mail/QQMail/inbox/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^TOshejialuo@foxmail\.com</span><br><span class="line">Mail/QQMail/inbox/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^(To|Cc):.*git@vger\.kernel\.org</span><br><span class="line">* ^TOshejialuo@gmail\.com</span><br><span class="line">Mail/GMail/mailing_list/git/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^From:.*@google\.com</span><br><span class="line">* ^TOshejialuo@gmail\.com</span><br><span class="line">Mail/GMail/information/google/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^From:.*@apple\.com</span><br><span class="line">* ^TOshejialuo@gmail\.com</span><br><span class="line">Mail/GMail/information/apple/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^From:.*@github\.com</span><br><span class="line">* ^TOshejialuo@gmail\.com</span><br><span class="line">Mail/GMail/information/github/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^From:.*@wakatime\.com</span><br><span class="line">* ^TOshejialuo@gmail\.com</span><br><span class="line">Mail/GMail/information/wakatime/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^From:.*@wakatime\.com</span><br><span class="line">* ^TOshejialuo@gmail\.com</span><br><span class="line">Mail/GMail/information/steam/</span><br><span class="line"></span><br><span class="line">:0</span><br><span class="line">* ^TO*shejialuo@gmail.com*</span><br><span class="line">Mail/GMail/inbox/</span><br><span class="line"></span><br><span class="line">:0：</span><br><span class="line">Mail/spam</span><br></pre></td></tr></table></figure><p>The configuration described above is straightforward. It efficiently examines both the To and Cc fields of an email and directs the message to the appropriate folder accordingly.</p><h2 id="The-Usage-of-mstmp"><a href="#The-Usage-of-mstmp" class="headerlink" title="The Usage of mstmp"></a>The Usage of mstmp</h2><p>It’s still not so hard to configure the <code>mstmp</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># QQMail (FoxMail)</span><br><span class="line">account QQMail</span><br><span class="line">    auth login</span><br><span class="line">    host smtp.qq.com</span><br><span class="line">    port 587</span><br><span class="line">    from 392499367@qq.com</span><br><span class="line">    user 392499367@qq.com</span><br><span class="line">    password &quot;&quot;</span><br><span class="line">    tls on</span><br><span class="line">    tls_certcheck off</span><br><span class="line"></span><br><span class="line"># GMail</span><br><span class="line">account GMail</span><br><span class="line">    auth login</span><br><span class="line">    host smtp.gmail.com</span><br><span class="line">    port 587</span><br><span class="line">    from shejialuo@gmail.com</span><br><span class="line">    user shejialuo@gmail.com</span><br><span class="line">    password &quot;&quot;</span><br><span class="line">    tls on</span><br><span class="line">    tls_certcheck on</span><br><span class="line"></span><br><span class="line">logfile /tmp/msmtp.log</span><br></pre></td></tr></table></figure><h2 id="The-Usage-of-Mutt"><a href="#The-Usage-of-Mutt" class="headerlink" title="The Usage of Mutt"></a>The Usage of Mutt</h2><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><p>I use the <a href="https://github.com/dracula/mutt">dracula theme</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Dracular color theme</span><br><span class="line">source ~/.config/mutt/dracula.muttrc</span><br></pre></td></tr></table></figure><h3 id="Basic-Configuration"><a href="#Basic-Configuration" class="headerlink" title="Basic Configuration"></a>Basic Configuration</h3><p>The configuration could be very different for different people. I simply put my configuration below. You’d better use the <code>man muttrc</code> to change the configuration for whatever you like.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Use directory by default instead of a single file</span><br><span class="line">set mbox_type=Maildir</span><br><span class="line"></span><br><span class="line"># The default directory to save attach_save_dirachments from the &quot;attachment&quot; menu.</span><br><span class="line">set attach_save_dir = ~/.config/mutt/attachments</span><br><span class="line"></span><br><span class="line"># When this variable is set, mutt will beep when an error occurs.</span><br><span class="line">set beep = no</span><br><span class="line"></span><br><span class="line"># Character set your terminal uses to display and enter textual data</span><br><span class="line">set charset = &quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line"># This option allows you to edit the header of your outgoing messages along with</span><br><span class="line"># the body of your message.</span><br><span class="line">set edit_headers=yes</span><br><span class="line"></span><br><span class="line"># This variable specifies which editor is used by mutt.</span><br><span class="line">set editor=&quot;vim&quot;</span><br><span class="line"></span><br><span class="line"># Controls whether or not a copy of the messages you are replying to is</span><br><span class="line"># included in your reply.</span><br><span class="line">set include = yes</span><br><span class="line"></span><br><span class="line"># When set, mutt will set the envelope sender of the message.</span><br><span class="line">set use_envelope_from = yes</span><br><span class="line"></span><br><span class="line"># This variable specifies what real name should be used when</span><br><span class="line"># sending messages.</span><br><span class="line">set realname=&quot;shejialuo&quot;</span><br><span class="line"></span><br><span class="line"># Specifies how to sort messages in the &quot;index&quot; menu</span><br><span class="line">set sort = threads</span><br><span class="line"></span><br><span class="line"># Controls whether or not Mutt will move read messages from your spool mailbox to your</span><br><span class="line"># $mbox mailbox</span><br><span class="line">set move = yes</span><br></pre></td></tr></table></figure><h3 id="Use-w3m-To-View-HTML-Content"><a href="#Use-w3m-To-View-HTML-Content" class="headerlink" title="Use w3m To View HTML Content"></a>Use w3m To View HTML Content</h3><p>I don’t want to use external browser to view HTML content. I use <a href="https://fiasko.io/projects/htmail-view.html.en">Reading html email with mutt</a> as the reference to setup. It’s not hard.</p><p>We need to first change the <code>mutt</code> configuration like the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set w3m to view html content</span><br><span class="line">auto_view text/html</span><br><span class="line">alternative_order text/plain text/enriched text/html</span><br></pre></td></tr></table></figure><p>And the add the following content to the <code>~/.mailcap</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text/html; w3m -I %&#123;charset&#125; -T text/html; copiousoutput;</span><br></pre></td></tr></table></figure><h3 id="Use-Zathura-to-View-PDF-File"><a href="#Use-Zathura-to-View-PDF-File" class="headerlink" title="Use Zathura to View PDF File"></a>Use Zathura to View PDF File</h3><p>Append the following content to the <code>~/.mailcap</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/pdf; zathura %s;</span><br></pre></td></tr></table></figure><h3 id="Vim-Bindings"><a href="#Vim-Bindings" class="headerlink" title="Vim Bindings"></a>Vim Bindings</h3><p>Please refer to this wonderful blog <a href="https://ryanlue.com/posts/2017-05-21-mutt-the-vim-way">Mutt, the Vim Way</a>.</p><h3 id="Multiple-Accounts-Support"><a href="#Multiple-Accounts-Support" class="headerlink" title="Multiple Accounts Support"></a>Multiple Accounts Support</h3><p>We could use Mutt hook functionality to support multiple accounts. For multiple accounts, you must use <em>account-hooks</em> and <em>folder-hooks</em>.</p><ul><li><em>Folder-hooks</em> will run a command before switching folders. This is mostly useful to set the appropriate SMTP parameters when you are in a specific folder. For instance when you are in your work mailbox and you send an e-mail, it will automatically use your work account as sender.</li><li><em>Account-hooks</em> will run a command every time Mutt calls a function related to an account, like IMAP syncing. It does not require you to switch to any folder.</li></ul><p>I use folder-hooks because there is no account configuration for mutt. I use Gmail as the master configuration in <code>muttrc</code> like the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># GMail as the master</span><br><span class="line">source ~/.config/mutt/accounts/GMail</span><br><span class="line"></span><br><span class="line"># Multiple Accounts support</span><br><span class="line">folder-hook ~/Mail/GMail/* source ~/.config/mutt/accounts/GMail</span><br><span class="line">folder-hook ~/Mail/QQMail/* source ~/.config/mutt/accounts/QQMail</span><br></pre></td></tr></table></figure><p>Below is a full example for GMail and QQMail.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ~/.config/mutt/accounts/GMail</span><br><span class="line"></span><br><span class="line">set from = &quot;shejialuo@gmail.com&quot;</span><br><span class="line">set sendmail = &quot;/usr/bin/msmtp -a GMail&quot;</span><br><span class="line">set spoolfile=&quot;$HOME/Mail/GMail/inbox&quot;</span><br><span class="line">set mbox=&quot;$HOME/Mail/GMail/seen&quot;</span><br><span class="line">set record=&quot;$HOME/Mail/GMail/sent&quot;</span><br><span class="line">set postponed=&quot;$HOME/Mail/GMail/draft&quot;</span><br><span class="line"></span><br><span class="line"># vim: ft=muttrc:</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># ~/.config/mutt/accounts/QQMail</span><br><span class="line">set from = &quot;392499367@qq.com&quot;</span><br><span class="line">set sendmail = &quot;/usr/bin/msmtp -a QQMail&quot;</span><br><span class="line">set spoolfile = &quot;$HOME/Mail/QQMail/inbox&quot;</span><br><span class="line">set mbox=&quot;$HOME/Mail/QQMail/seen&quot;</span><br><span class="line">set record=&quot;$HOME/Mail/QQMail/sent&quot;</span><br><span class="line">set postponed=&quot;$HOME/Mail/QQMail/draft&quot;</span><br><span class="line"></span><br><span class="line"># vim: ft=muttrc:</span><br></pre></td></tr></table></figure><h2 id="Create-Mail-Directories"><a href="#Create-Mail-Directories" class="headerlink" title="Create Mail Directories"></a>Create Mail Directories</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spam</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/spam/&#123;cur,new,tmp&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># QQMail</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/QQMail/inbox/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/QQMail/draft/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/QQMail/seen/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/QQMail/sent/&#123;cur,new,tmp&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># GMail</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/GMail/inbox/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/GMail/draft/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/GMail/seen/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/GMail/sent/&#123;cur,new,tmp&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/GMail/information</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/Mail/GMail/mailing_list</span><br></pre></td></tr></table></figure><h2 id="Common-Operations"><a href="#Common-Operations" class="headerlink" title="Common Operations"></a>Common Operations</h2><h3 id="Read-Raw-Mailbox"><a href="#Read-Raw-Mailbox" class="headerlink" title="Read Raw Mailbox"></a>Read Raw Mailbox</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">muut -f /tmp/a</span><br></pre></td></tr></table></figure><h3 id="Send-the-Patches"><a href="#Send-the-Patches" class="headerlink" title="Send the Patches"></a>Send the Patches</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> *.patch; <span class="keyword">do</span> proxychains4 mutt -H <span class="string">&quot;<span class="variable">$p</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://wiki.archlinux.org/title/mutt">Mutt ArchWiki</a></li><li><a href="https://www.fetchmail.info/fetchmail-man.html">Fetchmail Manual</a></li><li><a href="https://fiasko.io/projects/htmail-view.html.en">Reading html email with mutt</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GSoC 2024 - Implement consistency check for refs</title>
      <link href="/2024/05/03/GSoC-2024-Implement-consistency-check-for-refs/"/>
      <url>/2024/05/03/GSoC-2024-Implement-consistency-check-for-refs/</url>
      
        <content type="html"><![CDATA[<p>I am fortunate to participate in <a href="https://summerofcode.withgoogle.com/programs/2024/projects/ukm4PTEF">GSoC 2024</a> contributing to <a href="https://git-scm.com/">Git</a>. This opportunity not only allows me to engage with one of the most influential open-source projects but also enables me to work under the guidance of experienced developers in the field.</p><p>I would like to extend my deepest gratitude to my two mentors, <a href="https://github.com/pks-t">Patrick</a> and <a href="https://github.com/KarthikNayak">Karthik</a>, who are both esteemed developers at <a href="https://about.gitlab.com/">GitLab</a>. Their expertise and guidance are invaluable, and I am incredibly fortunate to have the opportunity to learn from such experienced professionals in the field.</p><p>The primary purpose of this page is to serve as an archive for my weekly reports throughout the GSoC journey. These reports will detail my progress, challenges encountered, solutions devised, and learnings acquired each week. The intention behind maintaining this archive is twofold:</p><ol><li><strong>Transparency</strong>: To keep a transparent record of my contributions and progress throughout the project. This will allow my mentors, peers, and anyone interested in the project to track its development and my growth as a developer.</li><li><strong>Reflection</strong>: To serve as a reflective journal for myself. Documenting my journey will help me analyze my approaches, celebrate milestones, and learn from the challenges I face.</li></ol><p>You may access all related pages by visiting the <a href="https://luolibrary.com/categories/GSoC-2024/">GSoC 2024 category</a>.</p><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ol><li><a href="https://luolibrary.com/2024/05/27/GSoC-Community-Bonding-Period/">Community Bonding Period</a></li><li><a href="https://luolibrary.com/2024/06/02/GSoC-Week-1/">GSoC Week 1</a></li><li><a href="https://luolibrary.com/2024/06/10/GSoC-Week-2/">GSoC Week 2</a></li><li><a href="https://luolibrary.com/2024/06/17/GSoC-Week-3/">GSoC Week 3</a></li><li><a href="https://luolibrary.com/2024/06/30/GSoC-Week-4-5/">GSoC Week 4-5</a></li><li><a href="https://luolibrary.com/2024/07/08/GSoC-Week-6/">GSoC Week 6</a></li><li><a href="https://luolibrary.com/2024/07/16/GSoC-Week-7/">GSoC Week 7</a></li><li><a href="https://luolibrary.com/2024/07/28/GSoC-Week-8-9/">GSoC Week 8-9</a></li><li><a href="https://luolibrary.com/2024/08/13/GSoC-Week-10-11/">GSoC Week 10-11</a></li><li><a href="https://luolibrary.com/2024/08/25/GSoC-Final-Report/">GSoC Final Report</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GSoC 2024 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年终总结</title>
      <link href="/2024/01/31/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/31/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2023年的尾声早就已经过了，时间总是如同利刃一般无情地划过。我坐在西电网安大楼的实验室中，脑袋已经相当沉重了。突然想着必须记录2023年，为什么呢？内心不禁发问。我想我必须记录自己的存在。时间总是无痕，我必须在这个无痕且透明的世界里面，刻下属于我的痕迹。</p><h2 id="逃离"><a href="#逃离" class="headerlink" title="逃离"></a>逃离</h2><p>我为什么第一个想到的词就是逃离呢？因为我自己在2023年4月份的时候，已经疲倦了。每当疲倦的时候，我都不禁地反问自己，打代码的意义是什么呢？在面实习的过程中基本没有得到什么正反馈，不知道自己该为何而战。心里开始烦躁了，焦急了，幸福的口袋似乎什么东西都没有装下。不经让我想起《Rewrite》游戏里面的经典话语：</p><blockquote><p>有一天，察觉到自己一无所有。</p><p>发现本以为堆满着幸福的口袋，其实空无一物。</p><p>因为我没为在口袋里塞些什么而努力，所以是理所当然的。</p></blockquote><p>我一直以打代码自豪，这是我重要的存在意义。然而，我深刻地记得我当时对自我的怀疑，我真的能够打代码一辈子吗？我真的喜欢代码吗？我真的不是通过代码来逃避自我吗？我很迷惘。于是乎我决定逃离，本来不打算五一回家的我，以逃离为目的踏上了回家的旅程。</p><h3 id="与挚友的交谈"><a href="#与挚友的交谈" class="headerlink" title="与挚友的交谈"></a>与挚友的交谈</h3><p>从西安到成都的高铁很快，我简单地背了个包就回到了成都。和我的挚友见面了，他仍然是往常一样，我也如往常一样。吃喝玩乐过后，我和他在他那租的一套一里面聊着天。我们从初中聊到高中再聊到大学，我第一次知道了他在初中的细腻情感，第一次知道了他在高中时候将自己的情感诉诸于暴力的悔恨。我许久没有如此真挚的聊天了。我不仅又反思了自己的傲慢与偏见，我们真的能够轻易地了解一个人吗？我们总是凭借一些自己或他人的所见，就轻易对一个人下定义。</p><p>不禁意间，天就变亮了，我的挚友给我说不要逃避自己的感情，既然无法开辟一段新的未来，就认真地审视自己的过去。我一下就想到了我这次回家的主题：<strong>逃离</strong>。我不由黯然伤神。这几年，我不知道自己是否前进了。我的一些朋友一直认为我是在原地踏步，说实话，我很讨厌听到这样的话。但是反过来想，如果是一个不那么了解我的人，也确实很容易得出这样的结论。</p><h3 id="回家的反思"><a href="#回家的反思" class="headerlink" title="回家的反思"></a>回家的反思</h3><p>家永远是最温暖的港湾，不论哪个时间回家都会有这样的感慨。和父母聊了聊天，见了见外公，吃到了熟悉的香味。我的烦恼与疑惑已然被抛在了脑后。然而，我不由自主地又翻阅了我和曾经的她在高中时期写的书信，所有的信都用一种巧妙的方式送回到了我的手里。我每次都觉得这是命运使然，似乎可能在那时她就已经决定分手了。</p><p>我每次看信的内容，涌起的都是极其复杂的感情。好的方面有对往日回忆的追忆，对昔日温暖的遗憾。坏的方面，我不禁质疑这份感情的真假，我无法分清什么是假什么是真。每次一想到这个，我感觉到极其的厌倦，爱过的人和事物为什么这么让人扫兴。</p><p>五一节和另外的挚友相见了，我说起了我的迷惘，对代码的疑惑，自己能否将其作为终生的事业而奋斗呢？对困扰自己多年的感情的疑惑，自己是真的在前进，还是在逃避自己的内心呢？</p><h3 id="重返重庆"><a href="#重返重庆" class="headerlink" title="重返重庆"></a>重返重庆</h3><p>为什么突然想去重庆呢？没有理由，就是想去了。见到了自己的大学室友，他没什么变化，一如既往地真诚。我才明白我追求的是什么，我希望能与人建立真诚的关系，希望我真诚待别人，也希望别人真诚待我。然而，我追求的这个东西确实这个世间最为宝贵的东西，我矛盾的地方就在于明知有些东西难以强求却想强求。</p><p>回到了自己本科的母校，见到了那个时候对我启发甚大的学业导师。他仍然是对科研保留着属于他的纯粹。我很羡慕他，我觉得我的科研生涯完全没有去解决过一个真正的科学问题，从来没有去探索过计算机科学应该去解决的问题。他推荐我去滑铁卢大学读博士，我说我硕士期间的科研素养积累的不够，他批评了我的想法，我现在都记得他的话语：</p><blockquote><p>你为什么不去看看国外是怎么搞科研的呢？如果你觉得不合适，退学就行了啊。而且去国外体会一下别人的文化，别人的生活，感受一下也是一个好事。</p></blockquote><p>我才意识到自己的局限性，才意识到自己在西电读研失去的一个最宝贵的东西：<strong>勇气</strong>。我自己扼杀了自己的可能性。我老师问我，你觉得一个博士最重要的是什么？我已经忘记我怎么回答的呢？他给我说了一个我很震撼的话，博士最重要的是去研究真正的科学问题。实际上，我在读研之前他应该也给我说过，但是在当时我很难理解这句话的真正含义。我不禁再次反思，我想成为一个纯粹的人，然而我的逃离证明了我对代码并不纯粹。</p><p>当我沉溺于另一个世界中的时候，我另一位朋友带着她的男朋友来了西安，突然将我从这段妄想拉回了现实，我急忙买了一张从重庆到西安的动车票回到了西安。似乎给我这段旅程画上了句号。</p><h2 id="正视"><a href="#正视" class="headerlink" title="正视"></a>正视</h2><p>五一的逃离让我认识了许多东西，我才发现所谓的实习和秋招我不应该焦虑，我保持我自己，做好我自己该做的事情。</p><ul><li>ehForwarderBot社区贡献：抽空认真地阅读了<code>efb-qq-plugin-go-cqhttp</code>的源码，给所有的方法添加了注解，并提供了发送文件和视频的功能。</li><li>database-systems-complete-book-solutions：基本完成了这本讲数据库原理的课后习题答案。</li></ul><p>当时我自己也学了很多东西，毕竟我还是很热爱coding的。</p><h2 id="婚礼"><a href="#婚礼" class="headerlink" title="婚礼"></a>婚礼</h2><p>来西安的朋友结婚了，在9月份给我发了请帖国庆她要结婚了，我由衷地为她感到高兴，她找到了属于自己的归宿。我曾经去过她家拜访，那个时候我只觉得自己格格不入，那种生活的气息甚至让我觉得有些许的窒息。我突然意识到自己是不是离小小的幸福越来越远了。</p><p>本以为能高兴去参加的婚礼，更多的却是给自己带来的痛苦。当我知道伴娘是我的前女友的时候，内心是一丝丝的期待，主要是好奇这五年的时间她变成了一个什么样的人。同时，我也很想见我的哥们儿。来到成都东站的时候，兄弟们已经在等着我了，然而殊不知噩梦才刚刚开始。</p><p>到了婚礼前一天晚上的时候，我一个哥们儿突然说，我的前女友叫我们过去玩。实际上，对于我来说我的内心是不愿意的，我或多或少觉得有点尴尬。我不知道我该说些什么，所以在与她见面的那一瞬间，我有逃避的想法，不过既然来了，肯定不能逃避了，我现在都能清晰地记得我内心所说的话：</p><blockquote><p>人不能逃避自我。</p></blockquote><p>然而，我的前女友只叫了我另外四个兄弟的名字，而忽略了我的名字，我一瞬间就语塞了。因为我的存在在此时此刻已经被她恶意地抽离了。于是乎，大家热烈地讨论明天早上堵门的事情，商量着小游戏该如何安排，而我并不存在，这让我第一次意识到了我似乎成为了《局外人》这本小说的主人公。只不过，他是主动的，而我是被动的。最讽刺的是，我一个兄弟对我所说的话：</p><blockquote><p>这么多年了，你还没走出来吗？</p></blockquote><p>我已经无法解释什么了，我第一次意识到了距离。然而，也是有开心的事情。第二天我听到新娘的致辞的时候，我才明白这份幸福属于她是应该的。真挚的情感表达，她放弃成为一个医生，选择了其他职业，感谢了她的父母对她职业选择的理解。感谢与她老公的相遇。说实话，我的眼睛湿润了，唯独真挚的情感能让人心震撼。</p><p>结婚的当天下午，他们都去打牌了，我自己选择了逃离。把我的MBP打开，写了一下午的MIT 6.824。这可谓是我最快乐的时光了，我终于找回了属于自己的存在。我从来不讨厌孤独一人，而是厌恶被人恶意的孤立。</p><p><img src="https://s2.loli.net/2024/01/31/E1LtaWz9ycKrGBj.png" alt="10月4日的提交记录"></p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>人生第一次参加了真正意义上的工作，然而第一份实习在NVIDIA，可能直接会把我惯坏吧。不如说已经把我惯坏了。上班的体验是很好的，然而晚上一个人待在上海小小的出租屋里面，感受到的确实实在的寂寞。突然急切地希望自己身边能有一个人陪伴，然而我却厌恶自己的想法，如果是因为寂寞就去靠近一个人，对她来说这是一个不公平的事情。所以由衷地觉得，晚上的时间要好好把握。要去充实自己的生活。不禁苦笑，说总是比做起来容易。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>人的一年说多也多，说少也少。然而，正如我开头所讲，简单地记录自己的存在。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秋招总结</title>
      <link href="/2023/11/20/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/11/20/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>我觉得还是有必要记录一下我今年的秋招，但实际上记录的目的是为了什么呢？或许，仍然是刻印下自己的足迹并或多或少给阅读之人带来些许启发。</p><h2 id="暑期实习"><a href="#暑期实习" class="headerlink" title="暑期实习"></a>暑期实习</h2><p>其实投暑期实习的时候，我还是十分自信的，觉得靠着自己的能力拿下一个暑期实习是没有什么问题的。国内的大厂我投了百度、美团、阿里和腾讯。拼多多还有字节我直接选择没投，我觉得我没有那个命，而且我很不认同拼多多对不懂计算机的人群的歧视（参考<a href="https://mp.weixin.qq.com/s/P_EYQxOEupqdU0BJMRqWsw">2022年度最不可赦漏洞</a>）。同时我也投了一些外企的暑期实习，比如说亚马逊，英伟达和Paypal这些公司。</p><p>由于我本科双非，阿里实习简历过不了（面了个所谓的电话面），外企的面试属于可遇不可求。我总共只面试了百度，美团和腾讯这三个公司的暑期实习。</p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>百度是我最开始投的公司，当时我选择的岗位是C++软件研发工程师，做笔试的时候运气好，三道算法题我做出了两道算法题，拿到了面试机会。我现在已经记不清楚面试的内容了，我只记得一面做的是<a href="https://leetcode.cn/problems/reorder-list/">LeetCode 143</a>，二面做的是<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">LeetCode 25</a>。由于当时就没刷题，在只有20分钟左右的时间下，我很难写出在ACM模式下的LeetCode 25题。同时由于我自己自言自语地说了一句，感觉思路不对，然后面试官回了一句，“确实思路肯定有问题，你想一想”。又浪费了不少的时间。</p><p>题做不起，自然而然就被挂了。实际上二面的面试官问我做的科研横向项目在分布式集群下怎么收集的数据（实际上这个横向项目技术含量比较低，苦于没有实习经历，我还是得写一个看起来正经的项目吧），我说是使用python来收集的，他反问我为什么不适用Kafka。最后结束的时候他给我说搞工程和搞学术是不一样的。</p><p>其实，我很不能理解这些面试官的心态，没有必要教育我一顿。我的业务场景根本不需要那么重的东西，我只需要收集点数据处理就行了。</p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>美团我的笔试做的一塌糊涂，100分拿了个40分？美团我进行到了第二面，由于是投的基础研发部，所以面试需要进行三轮。</p><p>一面的面试官，主要是询问我做的国外公开课的<a href="https://github.com/shejialuo/CS149-fall21">CS149</a>中的能够解析任务依赖的异步Fork-Join任务库是怎么实现的，我记得当时我是把整个数据结构怎么设计的，以及同步的过程详细给面试官说了。可能因为回答的好，后面面试官给了我一个很简单的算法题。</p><p>然而，最令我震撼的是那个面试官在反问环节对我说的一番话（当时我问了他，你工作的时候觉得做的最有意思的事情是什么？）：</p><blockquote><p>你做的这个东西，我们一般都是直接用别人的库，平时我们很少写这些。可能你因为还是学生，没有上班，可能还比较幼稚，工作本身就是没有意义的，可能最大的乐趣就是解决了一个BUG。</p></blockquote><p>实际上，我被这句话震撼了。我其实并不是不明白上面这句话的道理。我感到了深深的悲哀，我一下意识到了我如果从事互联网的工作，可能也是这样。我该追求什么呢？</p><p>二面就比较抽象了，面试官一上来就问我我为什么笔试做的这么糟糕，我说题比较难，我尽力了。然后让我写了一个简化的我没有做的笔试题，然后他说我函数参数传错了。我或多或少写了5年的cpp了，真的不至于传参数都能传错。然后我直接说我确实参数传错了，然后面试就这样结束了，时间不到30分钟。</p><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>腾讯是面的最舒服的，因为他直接问我现在能来实习吗？我说不能，然后面试就结束了。多好不要浪费大家的时间。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我在面完上面三家公司，感到了深深的疲倦。于是在当时我在朋友圈发了以下的内容：</p><blockquote><p>从2月份到现在，面试了百度，腾讯，阿里这三家公司。我的体会是，面试变成了一件相当无聊的事情，二十分钟不明所以聊一下你做的项目，然后给你一道LeetCode的中等题目或者hard的题目让你做一做，然后你就一直做，面试官几乎不说话，做得起就继续，做不起就拜拜。如果你做起了，还会因为你现在不能来实习成为廉价劳动力直接挂你。</p><p>我在想这些面试官对我的了解基本等于0，就因为我能做起一个题就让我继续下一轮……，我是真心觉得无语。问些八股还要去找公司里面的题库，问<code>new</code>和<code>malloc</code>的区别这种无聊的问题。</p><p>从现在的经验来看，国内的互联网做的东西真心很无聊。还是思考一下换赛道吧，还是希望能做点有意思的东西的。</p></blockquote><p>于是乎，我做了一个很不理智的决定，直接放弃了其他大厂的暑期实习。根本不想面，我觉得面试毫无意义，同时去这些大厂实习也是毫无意义（当然，我肯定是偏激的观点）。不如在学校做点有意思的事情。</p><p>差不多从四月份开始我就开始学习<a href="https://interpreterbook.com/">Writing An Interpreter in Go</a>和<a href="https://compilerbook.com/">Writing A Compiler In Go</a>，我用cpp进行了自己的一个实现（见<a href="https://github.com/shejialuo/cppmpiler">cppmpiler</a>）。</p><p>然后，给<a href="https://github.com/ehForwarderBot">ehForwarderBot</a>社区做了一些贡献，主要是给slave端的QQ添加发送文件的支持。</p><p>当然，我不得不刷LeetCode。这可谓是我秋招过程中做的最痛苦的事情。让我回想起高中为了成绩不得不刷题的感觉。明明我还想写一个模拟器，还想去探索一下内存模型和缓存一致性。</p><h2 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h2><p>秋招是从7月份就开始的，因为很多公司已经开始提前批了。还是希望自己能毕业进大厂的，至少平台要高一些。所以还是采取了海投策略。</p><h3 id="百度提前批"><a href="#百度提前批" class="headerlink" title="百度提前批"></a>百度提前批</h3><p>百度提前批约我面试的时间应该是2023年7月中旬左右，一面的面试官是一位女生，我已经记不清她开了摄像头还是没开摄像头，听着她虚弱的声音，我就觉得她已经很累了。她问了我一些并行计算的项目，然后就让我做两道算法题了。我直接把两道算法题秒了，毕竟我不是在做题，我只是在默写。</p><p>二面咋说了，面试官还是比较有水平的，问了我并行计算，怎么使用CUDA的，然后怎么做Reduce操作。然后问了我个CPU指令乱序，回答不上（那个时候体系结构方面的知识确实忘了许多）。然后写了个LRU，给我介绍了一下部门的情况，面完二面就直接挂了。</p><p>要说我不觉得不甘，那肯定是扯淡的。不过从实习我得到的一个宝贵的经验就是面试也就是这个样，主要还是看顺眼了就行了。许多东西都是强求不得的。</p><h3 id="美团-1"><a href="#美团-1" class="headerlink" title="美团"></a>美团</h3><p>美团由于填写简历的时候填错了，学历填成了非统招，所以做完笔试就没有后续了，实际上我觉得cpp面美团也没有什么优势，毕竟java基本不懂，数据库也只会底层的原理，不懂上层的东西。</p><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><p>阿里总共有6个部门，因为阿里卡第一学历，所以我阿里的简历筛选一个都通过不了。我其实觉得这个公司的HR挺无能的，作为一个公司核心就应该是选择人才，如果通过卡第一学历甚至那什么28所名单来进行筛选，只能够体现这个公司的无能。</p><h3 id="腾讯-1"><a href="#腾讯-1" class="headerlink" title="腾讯"></a>腾讯</h3><p>腾讯我投的是后台开发，说实在的，我觉得cpp就不应该投后台开发，然而我没有更好的选择。腾讯第一次捞我，把我调到技术运营的岗位去了，我研究生做的是云方面的研究，这个岗位就是针对内部系统的运营维护的，面试了就是聊天加项目加八股。没什么新意。然后二面也比较常规，三面主管面没发挥好，可能主管觉得我go语言基础不是那么好加上iptables的实现没有解释的清楚（我忘了），三面就给我挂了。</p><p>后面第二次捞我，是腾讯健康的部门的后台开发，第一面面了两个小时，当时我就知道多半这次面试就已经结束了。实际上这个题的代码很不好写，内存有限制，面试官一定要让我把代码写出来。前面八股问了半个小时，我和他讨论思路用了50分钟，怎么设计数据结构是合理的，怎么避免内存限制，怎样效率最高。然后我就开始写了，这个代码很不好调试，从4点开始面到5点50左右，我的精神已经开始恍惚了。我主要想吃饭了，然后我主动给面试官说我写不了了，就这样结束吧，大家好吃饭。</p><h3 id="B站"><a href="#B站" class="headerlink" title="B站"></a>B站</h3><p>B站由于认识HR，虽说简历全挂了，还是给了我一个分布式存储开发岗位的机会。一面的话是八股加体系结构，这可以说是我进行的最有深度的一次面试了，给面试官讲解内存子系统。当然二面只进行了20分钟就结束了，显然B站不招人嘛。但是我觉得这是给我想法转变一次的面试，cpp真的要搞后台开发吗？我学的技能就不是互联网的东西。</p><h3 id="龙芯"><a href="#龙芯" class="headerlink" title="龙芯"></a>龙芯</h3><p>龙芯的面试我是已经在英伟达实习的时候面的了，这个岗位相当有意思，名字叫基础软件研发，主要做gcc和ocaml的编译器适配和优化，你可知对于一个学习过Haskell的人并接触过一些ocaml语言的人来说，这个岗位有多么的吸引。面试的过程还是主要考察体系结构的知识，以及询问我怎么在CPU上实现矩阵的乘法的优化。二面主要问我调试器是怎么实现的，怎么做并行计算的，怎么实现SUNDR（一个安全方面课程的最后的作业），然后问了我个在Linux系统上用鼠标左键点击PPT翻页，从设备到内核态到用户态的整个过程（这是一个很有意思的问题）。目前，状态在泡池子中。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>实际上，我还投了许多公司。</p><ul><li>简历挂的：字节，拼多多，京东，滴滴，小米，米哈游，大疆，网易。</li><li>泡池子的：华为（云计算开发工程师），比亚迪（操作系统研发工程师）。</li></ul><h3 id="英伟达"><a href="#英伟达" class="headerlink" title="英伟达"></a>英伟达</h3><p>我在秋招的时候仍然是投了英伟达的实习岗位，其实我只是抱着试一试的心态，无论是学历还是经历，我比起申请的人都差了不少。但是英伟达给了我面试的机会，这个岗位是Software Intern - CUDA Test Development。实际上英伟达的面试能够让我感受到很重要的一点，就是注重对基础的考察，而且在面试过程中与面试官的交流才是最重要的，怎么去解决问题。面试官会和你一起去沟通解决这个问题。</p><p>实际上我在面完这个岗，是给我发了拒信的。当时候另外一个实习岗位Software Intern - Autonomous Vehicles给了我面试机会。然而，好巧不巧，HR找到我，说上一个岗位准备给我发offer了（其实是有人鸽了），在确定性和不确定性之间，我选择了确定性的offer。因为已经9月份底了，加上英伟达的光环，我还是非常希望能够转正的，毕竟我没拿到一个大厂的offer（或者说，他们连面试的机会都不愿意给我）。于是我选择放弃了当前的面试，接受了这个offer。实际上目前回想，我不应该做这个选择，我应该坚持我想要的。</p><p>正式入职英伟达的时候已经10月中旬了，软件测试的工作说来有趣说来也无趣，公司的同事以及主管都对我很好，英伟达给的福利待遇也很好。我其实已经十分地幸运了，能够拿到这样的实习，能够有转正的机会。这是我敢都不敢想的事情。然而，我的主管很大方地支持我去投内部的秋招，我是非常的感动。而且，实习也会给你自己探索的机会，我就在实习期间写了个python的命令行工具来自动化流程，提升大家的效率。主管还给了我20分钟的时间作汇报，我当时才进组两周左右。</p><p>于是乎，我投递了System Software Engineer, SoC - New College Grad的岗位，我为什么想投这个岗位，是因为我内心想做的事情驱动着我。我非常感谢能给我这个面试机会，如果不是因为我能够拿到英伟达实习的机会，我是绝对拿不到秋招的面试机会。面试主要还是问体系结构方面的知识，我最感动的是第一位面试官对我的评价：</p><blockquote><p>从你的身上，我感受到你对技术的热爱与热情。</p></blockquote><p>我从来没有得到过这么高的评价，在我看来，这是对我很高的认可。然后就是二面从1点进行到5点，仍然是我所说的，交流沟通才是最重要的，在会议室和面试官一起在白板上写代码，一起讨论问题。英伟达的面试体验可谓是我面过的公司最好的，二面基本都是4个小时，足以体现对面试者相当高的尊重。</p><p>我最终也是幸运地拿到了这份offer，我做梦也不敢想的事情发生到了自己的身上。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我的秋招并不是那么顺利，因为第一学历的限制我几乎没有什么好的选择，加上我学的东西几乎与业务无关（我在整个学生生涯写的web后端还有sql几乎等于没有），我几乎拿不到大厂的offer，如果没有英伟达的offer，我就只能等华为，龙芯还有比亚迪了。</p><p>然而，我一直在思考我自己想要的是什么，我前段时间看到的文章<a href="https://justinyan.me/post/5790">每个人每天都只有24小时，希望我的选择真的是我的选择</a>让我深思了不少，正如同文章的题目一样，对自我的叩问才是成长，做什么样的事，成为什么样的人，需要用一辈子的时间去寻找答案。我为什么面试互联网大厂几乎到主管面就不行，我思考过这个问题，是因为我没有态度，我内心其实一直在排斥。如果我去做后台开发自己学的这些底层知识还有什么用。所以我面试的时候很多时候遇到无语的问题，我一般不会反驳，而是说“嗯嗯，你说得对”。</p><p>在整个秋招期间，我看到了本硕西电的有些朋友学java能够拿很多大厂的offer，我的内心难免会有嫉妒之情，对自己第一学历被卡的无奈，以及底层知识远离业务的无奈。每当面试官面试的时候问我，你做这个东西有什么意义的时候，我总是无奈一笑，说我挺喜欢做这些没有意义的活。</p><p>后面我意识到了不能着急，于是我仍然按照我自己的步骤走，因为学习并行计算，认识到了必须要去深入了内存子系统才能提高程序性能，于是我认真了学习了这两本书（从9月份到现在，实际上正是因为这两本书让我在英伟达秋招的这个岗位占了优势）：</p><ul><li>UNIX systems for modern architectures: symmetric multiprocesssing and caching for kernel programmers.</li><li>A Primer on Memory Consistency and Cache Coherence.</li></ul><p>实际上，我觉得人生就应该做一些没有意义的事情。这些没有意义的事情总会在运气到来的时候给予我们或多或少的帮助。在我看来，面试还是运气大于实习，我不喜欢超人的想法，觉得努力就能够有所收获，这是一种傲慢的想法。失去了同理心的想法。我一点也不觉得我能拿到这个offer是我的实力占主要因素，能够得到面试机会的人，没有人实力很差，至少我觉得大家都差不多。</p><p>我最后想用《三傻大闹宝莱坞》中的结尾话作为总结：</p><blockquote><p>追求卓越，成功将不期而至。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TopKProblem实战</title>
      <link href="/2023/09/19/TopKProblem%E5%AE%9E%E6%88%98/"/>
      <url>/2023/09/19/TopKProblem%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>最近面试一直被问关于Top K的问题。网上有许多已经有这方面的答案了，然而我认为这些答案仅仅是局限于表面。网上的答案几乎都没有任何的代码实现，我认为理解这个问题需要自己去进行实现。仍然引用费曼的经典话：</p><blockquote><p>What I cannot create, I do not understand.</p></blockquote><p>本教程的代码位于<a href="https://github.com/shejialuo/topKProblem">topKProblem</a>仓库中。</p><h2 id="最经典的Top-K问题"><a href="#最经典的Top-K问题" class="headerlink" title="最经典的Top K问题"></a>最经典的Top K问题</h2><p>最经典的Top K问题忽略任何机器的限制，也就是从一个数组中得到前K大的数。有两种经典的方法：</p><ul><li>快速选择</li><li>堆排序</li></ul><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;data, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pivot = data[end];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = start - <span class="number">1</span>, j = start;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[j] &gt; pivot) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      std::<span class="built_in">swap</span>(data[i], data[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">swap</span>(data[i + <span class="number">1</span>], data[end]);</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">helper</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;data, <span class="type">int</span> k, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mid = <span class="built_in">partition</span>(data, start, end);</span><br><span class="line">  <span class="type">int</span> index = mid - start + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index == k) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(data, k, start, mid - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(data, k - index, mid + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">topKUsingPartition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;data, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> index = <span class="built_in">helper</span>(data, k, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> std::vector&lt;<span class="type">int</span>&gt;&#123;data.<span class="built_in">cbegin</span>(), data.<span class="built_in">cbegin</span>() + index + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">topKUsingHeap</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;data, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::priority_queue&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; heap&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    heap.<span class="built_in">push</span>(data[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; data.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i] &gt; heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">      heap.<span class="built_in">pop</span>();</span><br><span class="line">      heap.<span class="built_in">push</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    ans[i] = heap.<span class="built_in">top</span>();</span><br><span class="line">    heap.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="受限环境下的Top-K问题"><a href="#受限环境下的Top-K问题" class="headerlink" title="受限环境下的Top K问题"></a>受限环境下的Top K问题</h2><p>假设我们的机器只有30M的内存，我们希望处理500M的<code>int_32</code>类型的数据，这些数据存储在文件中。我在此处假设<code>k</code>的大小是我们能够接受的，也就是<code>k</code>的大小对于内存而言可以忽略。</p><p>此部分的代码可以直接在<a href="https://github.com/shejialuo/topKProblem/tree/master/src/topKRestricted">仓库</a>中查看。</p><h3 id="使用堆排序"><a href="#使用堆排序" class="headerlink" title="使用堆排序"></a>使用堆排序</h3><p>最简单的方式可能仍然是使用堆排序，因为我们仅仅只需要在内存中维护$O(k)$的大小，对于大文件我们每次只需要读取20M即可，因此内存永远不会超过。然而我们必须思考一个问题，数字是以什么形式保存在文件中。我在这让假设数字都是通过二进制方式的形式存储的，减少分割等操作。</p><p>我采取了如下的思路实现，在Linux系统下通过<code>setrlimit</code>限制进程的内存大小，使用c++17的<code>filesystem</code>标准库在临时文件中写入数据，进行操作。</p><h3 id="使用快速选择"><a href="#使用快速选择" class="headerlink" title="使用快速选择"></a>使用快速选择</h3><p>对于大文件我们每次只需要读取20M即可，然后选择前<code>k</code>大的数。我们就能得到一系列的数组，然后我们直接将数组合并，得到一个新的数组，其大小不可能超过内存，然后再次选择前<code>k</code>大的数，从而得出答案。当然我们也可以使用堆来处理，毕竟这属于一个子问题。</p><h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><p>执行的结果如下所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== Result</span><br><span class="line">Heap average time: 1.4765 s</span><br><span class="line">Select average time: 1.90026 s</span><br></pre></td></tr></table></figure><p>可以看出，使用堆还是要快一些的，这是因为减少了内存的拷贝。</p><h2 id="受限条件下基于多线程的快速选择"><a href="#受限条件下基于多线程的快速选择" class="headerlink" title="受限条件下基于多线程的快速选择"></a>受限条件下基于多线程的快速选择</h2><p>基于快速选择的方法可以使用多线程进行加速，这是使用堆比不上的优势，现在的处理器基本上都是多核，此处使用多线程进行加速，如何构建多线程是一个问题。首先每个线程即是生产者也是消费者，这样代码写出来就极其的复杂，所以我的一个思路还是确定需要完成的任务数，通过任务数来实现线程之间的同步。</p><h2 id="问题变种"><a href="#问题变种" class="headerlink" title="问题变种"></a>问题变种</h2><p>所谓的问题变种，无非就是通过哈希得到频率，然后根据频率来得到Top K。没有任何本质的区别。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>实践出真知。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.858-SUNDR的实现</title>
      <link href="/2023/09/11/MIT6-858-SUNDR%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/09/11/MIT6-858-SUNDR%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>MIT6.858最后一个实验是复现论文<a href="https://www.usenix.org/legacy/event/osdi04/tech/full_papers/li_j/li_j.pdf">Secure Untrusted Data Repository</a>的串行化实现。在开始做这个实验之前，你应该仔细地阅读这篇论文。</p><h2 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h2><p>MIT6.858提供了基本的文件系统代码，了解这个文件系统是如何构建的，对于代码实现的相当重要。</p><h3 id="基本的类型定义"><a href="#基本的类型定义" class="headerlink" title="基本的类型定义"></a>基本的类型定义</h3><p>在SUNDR中，有用户和群组的划分。同时每一个文件都是由<code>&lt;principal, i-number&gt;</code>对应的。显然，每个用户和群组都可以有多个文件，所以只需要再定义一个类包含用户（群组）和所有的文件个数。故源代码中定义了三个类型：</p><ul><li><code>User</code>：继承于<code>Principal</code>。</li><li><code>Group</code>：继承于<code>Principal</code>。</li><li><code>I</code>：包含<code>Principal</code>和<code>n</code>。</li></ul><h3 id="基本的存储实现"><a href="#基本的存储实现" class="headerlink" title="基本的存储实现"></a>基本的存储实现</h3><p>在文件系统中，最基本的存储单元是<code>Block</code>类，其可以存储数据、inode等信息。由于SUNDR基于快照的机制保障安全，故其与git的实现机制相似，基于content-hash机制对每一个Block进行哈希。故<code>Block</code>类提供了两个函数：</p><ul><li><code>store(blob)</code>：<code>blob</code>是存储的数据，其为二进制数据。其返回值为二进制内容的sha1sum。</li><li><code>load(chash)</code>：根据哈希值找到相应的block，进而读取block中的二进制数据。</li></ul><p>同时，文件系统定义了<code>Inode</code>类，用于作为元数据。其包含了某一个文件或者目录的基本信息，例如类型，创建的时间，修改的时间及其对应的所有的block的哈希值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.size = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.kind = <span class="number">0</span> <span class="comment"># 0 is dir, 1 is file</span></span><br><span class="line">        <span class="variable language_">self</span>.ex = <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>.ctime = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.mtime = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.blocks = []</span><br></pre></td></tr></table></figure><p>显然，<code>Inode</code>类也是存储在block中的，所以我们需要基于<code>ihash</code>通过调用<code>block.load(chash)</code>函数得到其二进制数据，然后进行反序列化得到其字段值。当我们想要获得文件的值时，我们直接使用如下的函数即可：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&quot;&quot;</span>.join([secfs.store.block.load(b) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="variable language_">self</span>.blocks])</span><br></pre></td></tr></table></figure><p>然而，我们必须考虑目录这种情况。在SUNDR中，目录的每一项元素都是一个元组<code>(filename, I)</code>。其中其定义了<code>add</code>函数来实现在一个目录里面添加一个新项。同时定义了<code>find_under</code>函数用来查找目录。</p><h3 id="Itable"><a href="#Itable" class="headerlink" title="Itable"></a>Itable</h3><p>每个用户和群组都拥有一个<code>i-table</code>。对于用户而言，<code>i-table</code>保存的是<code>i-number</code>到<code>ihash</code>的映射。对于群组而言，<code>i-table</code>保存的是<code>i-number</code>到<code>I</code>的映射。因此对于<code>Itable</code>类而言，源码利用了python的动态性，直接定义了一个dict。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Itable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mapping = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">ihandle</span>):</span><br><span class="line">        b = secfs.store.block.load(ihandle)</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        t = Itable()</span><br><span class="line">        t.mapping = pickle.loads(b)</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bytes</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> pickle.dumps(<span class="variable language_">self</span>.mapping)</span><br></pre></td></tr></table></figure><p>然后，其定义了一个关键的函数<code>resolve</code>，基于<code>i-table</code>解析得到<code>ihash</code>或者<code>I</code>。同时，该函数支持递归地解析<code>I</code>最终得到<code>ihash</code>。其思路实现比较简单。</p><p>最关键的在于<code>modmap(mod_as, i, ihash)</code>函数，对于某个用户<code>mod_as</code>而言，给定一个<code>I</code>类，需要修改或者创建其在<code>i-table</code>中的映射。然而关键在于<code>I</code>有两类情况，一种是用户，另一种是群组。</p><ul><li>对于用户而言，其<code>mod_as</code>和<code>i.p</code>必须相等。我们需要修改或者创建其在<code>i-table</code>中的映射，这个过程相当简单。</li><li>对于群组而言，情况就会比较复杂了。我们首先需要基于提供的<code>i</code>找到其对应的<code>I</code>，也就是调用<code>resolve</code>函数并进行一层的解析。如果<code>I.p = mod_as</code>，证明群组的修改和用户的修改是一致的，我们一定会最先对用户的修改进行处理，所以此处不需要进行任何操作。如果不是那么证明我们需要创建一个新的<code>I</code>，于是调用<code>modmap(mod_as, I(mod_as), ihash)</code>在<code>mod_as</code>用户的<code>i-table</code>中添加映射。</li></ul><h3 id="文件系统API接口"><a href="#文件系统API接口" class="headerlink" title="文件系统API接口"></a>文件系统API接口</h3><p>源码已经给出了某些文件系统接口的实现，例如<code>link</code>函数，<code>link</code>函数的作用即将一个<code>I</code>添加到当前目录中，其原理很简单，首先需要基于当前目录构建一个<code>Directory</code>。然后调用<code>add</code>函数添加目录，并使用<code>modmap</code>修改映射关系。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Omit syntax check and write check</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">link</span>(<span class="params"><span class="keyword">def</span> link(<span class="params">link_as: User, i: I, parent_i: I, name: <span class="built_in">str</span></span>):</span></span><br><span class="line"><span class="params">    parent_ihash = secfs.store.tree.add(<span class="params">parent_i, name, i</span>)</span></span><br><span class="line"><span class="params">    secfs.tables.modmap(<span class="params">link_as, parent_i, parent_ihash</span>)</span>)</span><br></pre></td></tr></table></figure><p>在SUNDR论文中，文件系统的初始化是root用户生成一对私钥&#x2F;公钥，同时创建<code>.users</code>和<code>.groups</code>文件，存储相应的公钥及印映射信息。文件系统使用<code>init</code>函数提供了接口。其首先需要创建一个类型为目录的inode，然后添加<code>.</code>和<code>..</code>目录。同时需要创建<code>.users</code>和<code>.groups</code>文件，调用<code>link</code>函数添加到根目录中。</p><p>在了解了基本的数据结构以及映射关系后，我们就可以开始编写自己的代码。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现创建文件和目录的功能"><a href="#实现创建文件和目录的功能" class="headerlink" title="实现创建文件和目录的功能"></a>实现创建文件和目录的功能</h3><p>我们需要所做的第一个工作就是实现创建文件和目录。无论是文件还是目录我们都需要首先创建一个<code>Inode</code>。然后我们需要将其存储在文件系统中，并得到其hash值<code>ihash</code>。然后我们需要调用<code>modmap</code>修改itable的映射关系。对于目录而言，我们需要做更多额外的工作。我们需要添加在当前目录创建<code>.</code>和<code>..</code>，并调用<code>modmap</code>修改itable的映射关系。然后我们调用<code>link</code>维护目录结构关系。</p><p>然而，我们需要考虑如果是为一个群组创建文件和目录呢？实际上面的流程都是一样的，因为对于群组来说，<code>itable</code>是存储的映射，所以我们仅仅只需要更新这个映射关系即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_create</span>(<span class="params">parent_i: I, name: <span class="built_in">str</span>, create_as: User, create_for: Principal, isdir: <span class="built_in">bool</span></span>):</span><br><span class="line">    ...</span><br><span class="line">    ihash = secfs.store.block.store(node.<span class="built_in">bytes</span>())</span><br><span class="line">    store_i = secfs.tables.modmap(create_as, I(create_for), ihash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isdir:</span><br><span class="line">        new_ihash = secfs.store.tree.add(store_i, <span class="string">b&#x27;.&#x27;</span>, store_i)</span><br><span class="line">        secfs.tables.modmap(create_as, store_i, new_ihash)</span><br><span class="line">        new_ihash = secfs.store.tree.add(store_i, <span class="string">b&#x27;..&#x27;</span>, parent_i)</span><br><span class="line">        secfs.tables.modmap(create_as, store_i, new_ihash)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> create_for.is_group():</span><br><span class="line">        secfs.tables.modmap(create_as, I(create_for), store_i)</span><br><span class="line"></span><br><span class="line">    link(create_as, store_i, parent_i, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> store_i</span><br></pre></td></tr></table></figure><h3 id="Version-Structure-List实现"><a href="#Version-Structure-List实现" class="headerlink" title="Version Structure List实现"></a>Version Structure List实现</h3><p>目前所有的映射关系都是存储在<code>current_table</code>中的，其是存储在内存中的，当有其他客户端时，其访问服务端，得不到<code>current_table</code>的信息，所以需要对<code>current_table</code>进行修改，其需要存储在文件系统中。在这个过程中，我们不考虑任何安全方面的实现。</p><p>我们首先需要认识到<code>current_table</code>保存的是<code>Principal</code>到<code>Itable</code>的映射。由于函数<code>resolve</code>以及<code>modmap</code>严重依赖于<code>current_table</code>，所以应该尽可能合理地设计数据结构，减少代码的更改。</p><p>在SUNDR原论文中，其提供的数据结构<code>VersionStructure</code>包含每一个用户的<code>i-handle</code>，所属的群组的<code>g-handle</code>以及<code>version_vector</code>。这是与当前的逻辑矛盾的，当前的映射单独保存了用户和群组的，为了简便起见，我没有采取这样的数据结构。我仍然按照当前的逻辑进行实现。因此，我定义了如下的数据结构。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionStructure</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    `VersionStructure` is the most important data structure in this lab. In</span></span><br><span class="line"><span class="string">    the original SUNDR paper, the version structure is specified only for</span></span><br><span class="line"><span class="string">    the `User`. Each user could have one and more group handles. However,</span></span><br><span class="line"><span class="string">    it&#x27;s a bad idea for the current code. Because the `current_itables`</span></span><br><span class="line"><span class="string">    mapping the `I` to the inode. The `I.p` could be user or the group.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    version_vector : <span class="built_in">dict</span>[Principal, <span class="built_in">int</span>]</span><br><span class="line">    <span class="comment"># It could be the user or the group, it is only the hash, should</span></span><br><span class="line">    <span class="comment"># later read from</span></span><br><span class="line">    i_handle: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.version_vector = &#123;&#125;</span><br><span class="line">        <span class="variable language_">self</span>.i_handle = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>根据SUNDR论文，每次每个客户端对文件系统进行操作之间，都需要从服务器下载最新的VSL，当进行了修改需要对VSL进行验证，如果验证通过，则进行数字签名，上传VSL。从性能的角度来说，传递单独的<code>VersionStructure</code>是节省带宽的，然而我认为此处不是这个lab的核心，因此我才用了最粗暴的方式，即上传整个VSL。故定义了如下的数据结构：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionStructureList</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    `VersionStructureList` is the core data structure here, It</span></span><br><span class="line"><span class="string">    contains the the user or the group `VersionStructure`.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    version_structures: <span class="built_in">dict</span>[Principal, VersionStructure]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.version_structures = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Download the `version_structure_list` from the server, it should</span></span><br><span class="line"><span class="string">        be called every time it operates on the file system. It&#x27;s may</span></span><br><span class="line"><span class="string">        be a bad idea, but it is simple.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">global</span> server</span><br><span class="line">        blob = server.read_version_structure_list()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> blob == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;data&quot;</span> <span class="keyword">in</span> blob:</span><br><span class="line">            <span class="keyword">import</span> base64</span><br><span class="line">            blob = base64.b64decode(blob[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.version_structures = pickle.loads(blob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">global</span> server</span><br><span class="line">        blob = pickle.dumps(<span class="variable language_">self</span>.version_structures)</span><br><span class="line">        server.store_version_structure_list(blob)</span><br></pre></td></tr></table></figure><p>我们要在server端添加<code>store_version_structure_list</code>RPC调用，以及<code>read_version_structure_list</code>RPC调用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecFSRPC</span>():</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">    @Pyro4.expose</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_version_structure_list</span>(<span class="params">self</span>):</span><br><span class="line">        chash = <span class="variable language_">self</span>.version_structure_list_hash</span><br><span class="line">        <span class="keyword">if</span> chash != <span class="literal">None</span> <span class="keyword">and</span> chash <span class="keyword">in</span> <span class="variable language_">self</span>.blocks:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.blocks[chash]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Pyro4.expose</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">store_version_structure_list</span>(<span class="params">self, blob</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;data&quot;</span> <span class="keyword">in</span> blob:</span><br><span class="line">            <span class="keyword">import</span> base64</span><br><span class="line">            blob = base64.b64decode(blob[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> hashlib</span><br><span class="line">        chash = hashlib.sha224(blob).hexdigest()</span><br><span class="line">        <span class="variable language_">self</span>.blocks[chash] = blob</span><br><span class="line">        <span class="variable language_">self</span>.version_structure_list_hash = chash</span><br></pre></td></tr></table></figure><p>现在到达了最关键的一步，也就是我们需要修改<code>resolve</code>和<code>modmap</code>中的代码，我们需要替换掉<code>current_table</code>。我们需要一点即可，即<code>VersionStructure</code>存储的是<code>i-handle</code>我们必须进行磁盘的读写，而不是类似源码中直接存储<code>Itable</code>（实际上这一步是可以优化的，如果其<code>i-handle</code>没有发生变化，我们可以实现缓存，而不是从磁盘中实现读写，然而我忽略了因为这并不是这个lab的核心）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resolve</span>(<span class="params">i: I, resolve_groups = <span class="literal">True</span></span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">global</span> version_structure_list</span><br><span class="line">    <span class="keyword">if</span> principal <span class="keyword">not</span> <span class="keyword">in</span> version_structure_list.version_structures:</span><br><span class="line">        <span class="comment"># User does not yet have an itable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    i_handle = version_structure_list.version_structures[principal].i_handle</span><br><span class="line">    t = Itable.load(i_handle)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modmap</span>(<span class="params">mod_as: User, i: I, ihash</span>) -&gt; I:</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># find (or create) the principal&#x27;s itable</span></span><br><span class="line">    t = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">global</span> version_structure_list</span><br><span class="line">    <span class="keyword">if</span> i.p <span class="keyword">not</span> <span class="keyword">in</span> version_structure_list.version_structures:</span><br><span class="line">        <span class="keyword">if</span> i.allocated():</span><br><span class="line">            <span class="comment"># this was unexpected;</span></span><br><span class="line">            <span class="comment"># user did not have an itable, but an inumber was given</span></span><br><span class="line">            <span class="keyword">raise</span> ReferenceError(<span class="string">&quot;itable not available&quot;</span>)</span><br><span class="line">        t = Itable()</span><br><span class="line">        version_structure_list.version_structures[i.p] = VersionStructure()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no current list for principal&quot;</span>, i.p, <span class="string">&quot;; creating empty table&quot;</span>, t.mapping)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        i_handle = version_structure_list.version_structures[i.p].i_handle</span><br><span class="line">        t = Itable.load(i_handle)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    i_handle = secfs.store.block.store(t.<span class="built_in">bytes</span>())</span><br><span class="line">    version_structure_list.version_structures[i.p].i_handle = i_handle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>到了此处，我们就可以通过百分之87的测试。可见，我们已经完成了大部分的工作。剩下的就是实现安全方面的功能，这个lab最难的并不在于代码，而是你如何进行数据结构的设计。</p><h3 id="安全方面实现"><a href="#安全方面实现" class="headerlink" title="安全方面实现"></a>安全方面实现</h3><p>要实现安全方面就很简单了，需要考虑如下两个（由于时间关系，此处我并没有进行验证）：</p><ol><li>验证服务器端的身份</li><li>实现SUNDR协议</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Extra-Assignment-Implement Dense Matrix-Matrix Multiplication</title>
      <link href="/2023/08/27/CS149-Extra-Assignment-Implement-Dense-Matrix-Matrix-Multiplication/"/>
      <url>/2023/08/27/CS149-Extra-Assignment-Implement-Dense-Matrix-Matrix-Multiplication/</url>
      
        <content type="html"><![CDATA[<p>It’s hard to implement Matrix-Matrix Multiplication. So I recommend the following repository for you. I also refer to this repository when doing this assignment.</p><ul><li><a href="https://github.com/flame/blislab">blislab</a></li></ul><h2 id="The-native-implementation"><a href="#The-native-implementation" class="headerlink" title="The native implementation"></a>The native implementation</h2><p>We do not use 2-D array, we flat the array to one dimension. We assume that $A$ is $M \times K$, $B$ is $K \times N$, and $C$ is $M \times N$. We need to implement the $\alpha A \times B + \beta \times C$.</p><p><img src="https://s2.loli.net/2023/08/23/dHTJDkhwBfIiA74.png" alt="Flatten matrix multiplication"></p><p>We could calculate the following:</p><ul><li>$C[0] &#x3D; A[0]B[0] + A[1]B[N] + \cdots + A[K - 1]B[(K - 1)N]$</li><li>$C[1] &#x3D; A[K]B[1] + A[K + 1]B[N + 1] + \cdots + A[2K - 1]B[(K - 1)N + 1]$</li></ul><p>Thus, we could writing the following code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gemm</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Disable constructor</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">Gemm</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Calculate the GEMM sequentially</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @details The matrix A, B, C are all one-dimensional array, so the need</span></span><br><span class="line"><span class="comment">   * to find the way to calculate the matrix multiplication.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemm</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B, <span class="type">double</span> *C,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="type">double</span> inner_pod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; k; kk++) &#123;</span><br><span class="line">          inner_pod += A[i * k + kk] * B[kk * n + j];</span><br><span class="line">        &#125;</span><br><span class="line">        C[i * n + j] = alpha * inner_pod + beta * C[i * n + j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gemm</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B, <span class="type">double</span> *C, <span class="type">double</span> alpha,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">  Gemm::<span class="built_in">gemm</span>(m, n, k, A, B, C, alpha, beta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We assume that $A$ is $1024 \times 1024$ and $B$ is $1024 \times 1024$, we could see that the Intel mkl library would only execute 18ms, the reference implementation would execute 62ms. However, the native implementation executes 5746ms.</p><p><img src="https://s2.loli.net/2023/08/24/AJwG1Nect8qREkh.png" alt="The native implementation result"></p><h2 id="Blocked-matrix-multiplication"><a href="#Blocked-matrix-multiplication" class="headerlink" title="Blocked matrix multiplication"></a>Blocked matrix multiplication</h2><p>The efficiency is low because we do not use the cache. So the idea is use the blocked matrix multiplication thus improving the cache hit rate. The idea is intuitive. If you’are not familiar with the<br>blocked multiplication, I recommend you to read some materials.</p><p>From the below figure, we first need to split the matrix into the blocked matrices. We assume each block would be the $size \times size$. For $A$, we first need to split for the row $M$. And for $B$, we need to split for the col $N$. And for both $A$ and $B$, we could simultaneously handle $K$. However, the trouble is that we need to know each block top-left coordinate, because we need to find the absolute position. So we should define the coordinates for the absolute position.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief A wrapper to wrap the coordinates for indicating the</span></span><br><span class="line"><span class="comment"> * start left-top point for the current blocked matrix.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point2D</span> &#123;</span><br><span class="line">  <span class="type">int</span> i&#123;&#125;; <span class="comment">/**&lt; The absolute i */</span></span><br><span class="line">  <span class="type">int</span> j&#123;&#125;; <span class="comment">/**&lt; The absolute j */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/27/kMEThCBtFmDdW82.png" alt="Blocked matrix-matrix multiplication"></p><p>So we need to first split for $M$ and for $N$, then for $K$, we could get the following incomplete c++ code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += size;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += size;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; k; k += size) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the first loop, we should set the $A$’s start point of <code>i</code> and we also need to tell whether <code>i + size &lt; m</code>. Similarly, in the second loop, we should set the $B$’s start point of <code>j</code> and we also need to tell whether <code>j + size &lt; n</code>. In the last loop, we should set the $A$’s start point of <code>j</code> and $B$’s start point of <code>i</code> and also need to tell whether <code>k + size &lt; kk</code>.</p><p>It’s easy to calculate the start points of $C$. It is dependent on the <code>i</code> and <code>j</code>. Thus we could have the following code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Point2D a&#123;&#125;, b&#123;&#125;, c&#123;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += size) &#123;</span><br><span class="line">  <span class="type">int</span> mBlock = i + size &lt; m ? size : m - i;</span><br><span class="line">  a.i = i;</span><br><span class="line">  c.i = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += size) &#123;</span><br><span class="line">    b.j = j;</span><br><span class="line">    c.j = j;</span><br><span class="line">    <span class="type">int</span> nBlock = j + size &lt; n ? size : n - j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; k; kk += size) &#123;</span><br><span class="line">      a.j = kk;</span><br><span class="line">      b.i = kk;</span><br><span class="line">      <span class="type">int</span> kBlock = kk + size &lt; k ? size : k - kk;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At now, it’s not hard to write the calculate:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemmBlock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Disable constructor</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">GemmBlock</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Apply the C = beta C, it should be calculated at first.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">scalarMultiplication</span><span class="params">(<span class="type">int</span> mBlock, <span class="type">int</span> nBlock, <span class="type">int</span> n, Point2D &amp;c,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">double</span> *C, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mBlock; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nBlock; j++) &#123;</span><br><span class="line">        C[(i + c.i) * n + (j + c.j)] = beta * C[(i + c.i) * n + (j + c.j)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Matrix multiplication with block</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @details In order to implement the block matrix multiplication, we need</span></span><br><span class="line"><span class="comment">   * to calculate the blocked matrix A and blocked matrix B. For example</span></span><br><span class="line"><span class="comment">   * A11 A12  B11 B12  C11 C12</span></span><br><span class="line"><span class="comment">   * A21 A22  B21 B22  C21 C22</span></span><br><span class="line"><span class="comment">   * C11 = A11 X b11 + A12 X B21</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">matrixMultiplicationBlock</span><span class="params">(<span class="type">int</span> mBlock, <span class="type">int</span> nBlock, <span class="type">int</span> kBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">int</span> n, <span class="type">int</span> k, Point2D &amp;a, Point2D &amp;b,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Point2D &amp;c, <span class="type">double</span> *A, <span class="type">double</span> *B,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">double</span> *C, <span class="type">double</span> alpha)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mBlock; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nBlock; j++) &#123;</span><br><span class="line">        <span class="type">double</span> inner_pod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; kBlock; kk++) &#123;</span><br><span class="line">          inner_pod +=</span><br><span class="line">              A[(i + a.i) * k + (kk + a.j)] * B[(kk + b.i) * n + (j + b.j)];</span><br><span class="line">        &#125;</span><br><span class="line">        C[(i + c.i) * n + (j + c.j)] += alpha * inner_pod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Split the matrix</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemmUsingBlock</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> *C, <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">    Point2D a&#123;&#125;, b&#123;&#125;, c&#123;&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += size) &#123;</span><br><span class="line">      <span class="type">int</span> mBlock = i + size &lt; m ? size : m - i;</span><br><span class="line">      a.i = i;</span><br><span class="line">      c.i = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += size) &#123;</span><br><span class="line">        b.j = j;</span><br><span class="line">        c.j = j;</span><br><span class="line">        <span class="type">int</span> nBlock = j + size &lt; n ? size : n - j;</span><br><span class="line">        <span class="built_in">scalarMultiplication</span>(mBlock, nBlock, n, c, C, beta);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; k; kk += size) &#123;</span><br><span class="line">          a.j = kk;</span><br><span class="line">          b.i = kk;</span><br><span class="line">          <span class="type">int</span> kBlock = kk + size &lt; k ? size : k - kk;</span><br><span class="line">          <span class="built_in">matrixMultiplicationBlock</span>(mBlock, nBlock, kBlock, n, k, a, b, c, A, B,</span><br><span class="line">                                    C, alpha);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemm</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B, <span class="type">double</span> *C,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">gemmUsingBlock</span>(m, n, k, A, B, C, alpha, beta);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then executing <code>./gemm 1024</code>. As the result shows, we execute 843ms. It is much better than the native implementation.</p><p><img src="https://s2.loli.net/2023/08/27/YyUZxQDwveBTsGc.png" alt="Blocked matrix-matrix multiplication result"></p><h2 id="Blocked-matrix-multiplication-with-memory-layout-change"><a href="#Blocked-matrix-multiplication-with-memory-layout-change" class="headerlink" title="Blocked matrix multiplication with memory layout change"></a>Blocked matrix multiplication with memory layout change</h2><p>We can still improvement the efficiency, we still access the matrix $B$ with col. However, when the matrix size is big, it would cause cache miss. When executing <code>./gemm 2048</code>. The program would cause 7476ms. This is because the memory layout of $B$ is bad for cache hit. So we could change the layout of $B$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemmBlockWithMemoryLayoutChange</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Disable constructor</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">GemmBlockWithMemoryLayoutChange</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">scalarMultiplication</span><span class="params">(<span class="type">int</span> mBlock, <span class="type">int</span> nBlock, <span class="type">int</span> n, Point2D &amp;c,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">double</span> *C, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mBlock; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nBlock; j++) &#123;</span><br><span class="line">        C[(i + c.i) * n + (j + c.j)] = beta * C[(i + c.i) * n + (j + c.j)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">matrixMultiplicationBlock</span><span class="params">(<span class="type">int</span> mBlock, <span class="type">int</span> nBlock, <span class="type">int</span> kBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">int</span> n, <span class="type">int</span> k, Point2D &amp;a, Point2D &amp;b,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Point2D &amp;c, <span class="type">double</span> *A, <span class="type">double</span> *B,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">double</span> *C, <span class="type">double</span> alpha)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mBlock; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nBlock; j++) &#123;</span><br><span class="line">        <span class="type">double</span> inner_pod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; kBlock; kk++) &#123;</span><br><span class="line">          inner_pod +=</span><br><span class="line">              A[(i + a.i) * k + (kk + a.j)] * B[(j + b.i) * n + (kk + b.j)];</span><br><span class="line">        &#125;</span><br><span class="line">        C[(i + c.i) * n + (j + c.j)] += alpha * inner_pod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemmUsingBlock</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> *C, <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line">    Point2D a&#123;&#125;, b&#123;&#125;, c&#123;&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += size) &#123;</span><br><span class="line">      <span class="type">int</span> mBlock = i + size &lt; m ? size : m - i;</span><br><span class="line">      a.i = i;</span><br><span class="line">      c.i = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += size) &#123;</span><br><span class="line">        b.i = j;</span><br><span class="line">        c.j = j;</span><br><span class="line">        <span class="type">int</span> nBlock = j + size &lt; n ? size : n - j;</span><br><span class="line">        <span class="built_in">scalarMultiplication</span>(mBlock, nBlock, n, c, C, beta);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; k; kk += size) &#123;</span><br><span class="line">          a.j = kk;</span><br><span class="line">          b.j = kk;</span><br><span class="line">          <span class="type">int</span> kBlock = kk + size &lt; k ? size : k - kk;</span><br><span class="line">          <span class="built_in">matrixMultiplicationBlock</span>(mBlock, nBlock, kBlock, n, k, a, b, c, A, B,</span><br><span class="line">                                    C, alpha);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemm</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B, <span class="type">double</span> *C,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> *newB = <span class="keyword">new</span> <span class="type">double</span>[n * k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        newB[j * k + i] = B[i * n + j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gemmUsingBlock</span>(m, n, k, A, newB, C, alpha, beta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] newB;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then executing <code>./gemm 1024</code>. As the result shows, we execute 478ms. We gain more performance.</p><p><img src="https://s2.loli.net/2023/08/27/VhNcertR6vYDEim.png" alt="Blocked matrix-matrix multiplication with memory layout change result"></p><h2 id="Blocking-for-multiple-levels-of-cache"><a href="#Blocking-for-multiple-levels-of-cache" class="headerlink" title="Blocking for multiple levels of cache"></a>Blocking for multiple levels of cache</h2><p>It’s hard to explain this idea, you should carefully read the <a href="https://github.com/flame/blislab">blislab</a> tutorial and read the following paper carefully:</p><ul><li><a href="https://dl.acm.org/doi/10.1145/1356052.1356053">Anatomy of High-Performance Matrix Multiplication</a></li></ul><p>I follow the below figure to implement the algorithm.</p><p><img src="https://s2.loli.net/2024/08/11/7iTaYZnUWkVv82P.png" alt="Three Cache Level Matrix Multiplication"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GemmBlockWithThreeCacheLevel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Disable constructing this class</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">GemmBlockWithThreeCacheLevel</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">matrixMultiplicationBlock</span><span class="params">(<span class="type">int</span> mBlock, <span class="type">int</span> nBlock, <span class="type">int</span> kBlock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">int</span> n, <span class="type">int</span> k, Point2D &amp;a, Point2D &amp;b,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Point2D &amp;c, <span class="type">double</span> *A, <span class="type">double</span> *B,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">double</span> *C, <span class="type">double</span> alpha)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mBlock; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nBlock; j++) &#123;</span><br><span class="line">        <span class="type">double</span> inner_pod = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; kBlock; kk++) &#123;</span><br><span class="line">          inner_pod +=</span><br><span class="line">              A[(i + a.i) * k + (kk + a.j)] * B[(j + b.i) * k + (kk + b.j)];</span><br><span class="line">        &#125;</span><br><span class="line">        C[(i + c.i) * n + (j + c.j)] += alpha * inner_pod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Use five loop tp calculate the matrix-matrix multiplication, for</span></span><br><span class="line"><span class="comment">   * simplicity here, I only implement C = alpha AB.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemmUsingBlock</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> *C, <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sizeN = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sizeK = <span class="number">256</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> sizeM = <span class="number">96</span>;</span><br><span class="line"></span><br><span class="line">    Point2D a&#123;&#125;, b&#123;&#125;, c&#123;&#125;, ra&#123;&#125;, rb&#123;&#125;, rc&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> rSizeN = <span class="number">4</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> rSizeM = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to create pack A and pack B. It&#x27;s a bad idea to allocate</span></span><br><span class="line">    <span class="comment">// memory in the loop.</span></span><br><span class="line">    <span class="type">double</span> *packedA = <span class="keyword">new</span> <span class="type">double</span>[sizeM * sizeK];</span><br><span class="line">    <span class="type">double</span> *packedB = <span class="keyword">new</span> <span class="type">double</span>[sizeN * sizeK];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += sizeN) &#123;</span><br><span class="line">      <span class="comment">// In this loop, we only handle for the matrix B, it would</span></span><br><span class="line">      <span class="comment">// be split up by `sizeN` for the col.</span></span><br><span class="line">      b.j = j;</span><br><span class="line">      c.j = j;</span><br><span class="line">      <span class="type">int</span> nBlock = j + sizeN &lt; n ? sizeN : n - j;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> kk = <span class="number">0</span>; kk &lt; k; kk += sizeK) &#123;</span><br><span class="line">        <span class="comment">// In this loop, we handle for the matrix A and matrix B.</span></span><br><span class="line">        <span class="comment">// For the matrix A it would be split up by `sizeK` for the col</span></span><br><span class="line">        <span class="comment">// For the matrix B it would be split up by `sizeK` for the row</span></span><br><span class="line">        a.j = kk;</span><br><span class="line">        b.i = kk;</span><br><span class="line">        <span class="type">int</span> kBlock = kk + sizeK &lt; k ? sizeK : k - kk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// At here, we should pack the B into a consecutive memory, in</span></span><br><span class="line">        <span class="comment">// order to improve the cache hit rate and avoid TLB miss. We make</span></span><br><span class="line">        <span class="comment">// `packedB` into the L3 cache, So the L3 size should be greater</span></span><br><span class="line">        <span class="comment">// than the `sizeN * sizeK`. So in the following `for` loop all</span></span><br><span class="line">        <span class="comment">// the access to the `packedB` would gain great efficiency. And we</span></span><br><span class="line">        <span class="comment">// will convert the row-major to the col-major.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j_ = <span class="number">0</span>; j_ &lt; nBlock; j_++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i_ = <span class="number">0</span>; i_ &lt; kBlock; i_++) &#123;</span><br><span class="line">            packedB[j_ * sizeK + i_] = B[(b.i + i_) * n + (b.j + j_)];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += sizeM) &#123;</span><br><span class="line">          <span class="comment">// In this loop, we handle for the matrix A, it would be split</span></span><br><span class="line">          <span class="comment">// up by the `sizeI` for the row.</span></span><br><span class="line">          a.i = i;</span><br><span class="line">          c.i = i;</span><br><span class="line">          <span class="type">int</span> mBlock = i + sizeM &lt; m ? sizeM : m - i;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// At here, we should pack the A into a consecutive memory, in</span></span><br><span class="line">          <span class="comment">// order to improve the cache hit rate and avoid TLB miss. We</span></span><br><span class="line">          <span class="comment">// make `packedA` into the L2 cache, so the L2 cache must be</span></span><br><span class="line">          <span class="comment">// greater than `sizeM * sizeK`. So the following `for` loop</span></span><br><span class="line">          <span class="comment">// for accessing to the `packedA` would get great efficiency.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i_ = <span class="number">0</span>; i_ &lt; mBlock; i_++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j_ = <span class="number">0</span>; j_ &lt; kBlock; j_++) &#123;</span><br><span class="line">              packedA[i_ * sizeK + j_] = A[(a.i + i_) * k + (a.j + j_)];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Here, we already split the matrix A and matrix B into the block.</span></span><br><span class="line">          <span class="comment">// However, we need to split again just like the above, this would</span></span><br><span class="line">          <span class="comment">// be super easy.</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> jr = <span class="number">0</span>; jr &lt; nBlock; jr += rSizeN) &#123;</span><br><span class="line">            <span class="type">int</span> rNBlock = jr + rSizeN &lt; nBlock ? rSizeN : nBlock - jr;</span><br><span class="line">            rb.i = jr;</span><br><span class="line">            rc.j = jr + c.j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ri = <span class="number">0</span>; ri &lt; mBlock; ri += rSizeM) &#123;</span><br><span class="line">              <span class="type">int</span> rMBlock = ri + rSizeM &lt; mBlock ? rSizeM : mBlock - ri;</span><br><span class="line">              ra.i = ri;</span><br><span class="line">              rc.i = ri + c.i;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span> (<span class="type">int</span> internalK = <span class="number">0</span>; internalK &lt; kBlock; internalK++) &#123;</span><br><span class="line">                ra.j = internalK;</span><br><span class="line">                rb.j = internalK;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">matrixMultiplicationBlock</span>(rMBlock, rNBlock, <span class="number">1</span>, n, sizeK, ra, rb,</span><br><span class="line">                                          rc, packedA, packedB, C, alpha);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] packedA;</span><br><span class="line">    <span class="keyword">delete</span>[] packedB;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">gemm</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">double</span> *A, <span class="type">double</span> *B, <span class="type">double</span> *C,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">double</span> alpha, <span class="type">double</span> beta)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gemmUsingBlock</span>(m, n, k, A, B, C, alpha, beta);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS149 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多核处理器带来的缓存一致性问题</title>
      <link href="/2023/08/22/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/22/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在前面的章节中，我们介绍了缓存的底层实现。我们一直假设计算机只有一个CPU核心，然而在现代的计算机体系结构中，CPU拥有多个核心。为了简单起见，如下图所示，每个核心都有一块独立的私有缓存，以及一个由所有核心共享的末级缓存(LLC)。</p><p><img src="https://s2.loli.net/2023/08/10/gT5WfKButCqpOSV.png" alt="多核处理器模型"></p><h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><p>假设我们运行一个进程，其有两个线程，一个线程运行在C1，另一个线程运行在C2。从程序员的观点出发，这段代码是相当简单的。然而，我们需要从缓存的角度思考这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C1</span><span class="params">(<span class="type">int</span> *A)</span> </span>&#123;</span><br><span class="line">  *A = <span class="number">43</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C2</span><span class="params">(<span class="type">int</span> *A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*A == <span class="number">42</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> A = <span class="number">42</span>;</span><br><span class="line">  thread thread1&#123;C1, &amp;A&#125;;</span><br><span class="line">  thread thread2&#123;C2, &amp;A&#125;;</span><br><span class="line"></span><br><span class="line">  thread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">  thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下表所示：</p><ul><li>Time 1时刻，对于C1来说，其需要对地址A写入值43，由于缓存未命中，其会将A的值42写入其私有缓存中。对于C2来说，其需要检查地址A的内容，由于缓存未命中，其会将A的值42写入其私有缓存中。(可能读者会想如果采取的<em>write-through</em>策略，C2有可能会读取到43的值，我们在这个例子中忽略这种情况，实际上如果涉及到两个核同时读写，<em>write-through</em>策略也会导致缓存的不一致性)</li><li>Time 2时刻，C2继续进行循环操作，由于其能命中其私有缓存，故其一直会进行死循环，然而实际上A的值应该是43。</li></ul><table><thead><tr><th>Time</th><th>Core C1</th><th>Core C2</th></tr></thead><tbody><tr><td>1</td><td>S1: A&#x3D;43;</td><td>L1:while(A &#x3D;&#x3D; 42);</td></tr><tr><td>2</td><td></td><td>L2:while(A &#x3D;&#x3D; 42);</td></tr><tr><td>3</td><td></td><td>L3:while(A &#x3D;&#x3D; 42);</td></tr><tr><td>4</td><td></td><td>…</td></tr><tr><td>n</td><td></td><td>Ln:while(A &#x3D;&#x3D; 42);</td></tr></tbody></table><p>从上述的过程可以得出一个重要的结论，多核问题会产生新的缓存不一致问题。由于私有缓存的存在，当某两个私有缓存指向的是同一个物理地址时，需要保持同步，维护一致性。</p><h2 id="一致性问题解决通用方法"><a href="#一致性问题解决通用方法" class="headerlink" title="一致性问题解决通用方法"></a>一致性问题解决通用方法</h2><p>从上述的例子，我们其实可以很快地可以类比在多线程编程中的读写同步问题。当只读的时候，不存在不一致性问题，问题就在于写入缓存时。在实际的处理器中采用了<em>cache coherence protocol</em>，分为两类：</p><ul><li><em>Consistency-agnostic coherence</em>：首先需要将写入的这个事件通过缓存中的内部网络传递到其它核，再写入缓存。</li><li><em>Consistency-directed coherence</em>：先写入缓存，再广播事件，常用于GPGPU。</li></ul><h2 id="Consistency-agnostic-缓存一致性不变量"><a href="#Consistency-agnostic-缓存一致性不变量" class="headerlink" title="(Consistency-agnostic)缓存一致性不变量"></a>(Consistency-agnostic)缓存一致性不变量</h2><p>我们能够确定一个十分明确的不变量，<em>single-writer-multiple-reader</em>(SWMR)，如下图所示，对于任一时刻，对于某一个内存地址来说，其要么有多个核心在执行读操作，要么只有一个核心在进行读写操作。</p><p><img src="https://s2.loli.net/2023/08/10/Zs2ypk5TmYiIgHc.png" alt="SWMR"></p><p>同时我们还需要确保数据的一致性，内存位置的值与其最后一个读写时期结束时的值相同。因此我们可以明确如下的两个缓存一致性不变量：</p><ol><li><strong>Single-Writer, Multiple-Read (SWMR) Invariant</strong>.</li><li><strong>Data-Value Invariant</strong>.</li></ol><h2 id="通用实现方法"><a href="#通用实现方法" class="headerlink" title="通用实现方法"></a>通用实现方法</h2><p>我们希望所有CPU的私有缓存以及所有核心共享的末级缓存都能够维持缓存一致性不变量。目前采用的通用方式就是对于每一个私有缓存以及所有核心共享的末级缓存通过添加一个<em>coherence controller</em>状态机来维持这两个不变量。</p><p>对于私有缓存的<em>coherence controller</em>，特称为<em>cache controller</em>，其需要处理来自CPU的Load&#x2F;Store请求，当是Load请求的时候返回相应的数据给CPU。同时其需要发送请求和响应，接收其他controller的请求和响应。对于末级缓存而言，特称为<em>memory controller</em>，其只需要发送请求和响应，接收其他controller的请求和响应。</p><p>在后面的所有讨论中，我们都默认<em>cache</em>策略为<em>write-back</em>。</p><h3 id="一个简单协议的实现"><a href="#一个简单协议的实现" class="headerlink" title="一个简单协议的实现"></a>一个简单协议的实现</h3><p>首先，对于状态机而言，我们必须定义状态以及导致状态变化的事件：</p><ul><li>对于<em>cache controller</em>的每一个<em>cache block</em>而言，其有三种状态，$\text{I}$(invalid)，$\text{V}$(valid), $\text{IV}^{\text{D}}$。最后一个状态的存在是由于需要从内存里面读取到缓存，我们必须考虑stall的影响。</li><li>对于<em>memory controller</em>的每一个<em>cache block</em>而言，其只有两种状态，$\text{I}$(invalid)，$\text{V}$(valid)。<ul><li>当状态为$\text{I}$时，所有的cache controller相对应的cache block状态都为$\text{I}$。</li><li>当状态为$\text{V}$时，有且只有一个cache controller对于的cache block状态为$\text{V}$。</li></ul></li><li>三类主要事件：<ul><li><em>Get</em>：请求一个cache block。</li><li><em>DateResp</em>：传输cache block里的数据。</li><li><em>Put</em>：将cache block里的数据写回内存。</li></ul></li></ul><p>我们可以给出如下图所示的状态转换：</p><p><img src="https://s2.loli.net/2023/11/12/EHgMnZYblKV4aC9.png" alt="cache controller specification"></p><p><img src="https://s2.loli.net/2023/11/12/7SOtqrJfFh6IxZC.png" alt="memory controller specification"></p><p>可以发现这个协议的实现效率十分地低，实际上我们完全在多核处理器下实现的串行操作，在使用当某几个核心竞争相同的<em>cache block</em>时，会发生大量的stall，导致性能的降低。</p><h2 id="设计缓存一致性协议的通用思路"><a href="#设计缓存一致性协议的通用思路" class="headerlink" title="设计缓存一致性协议的通用思路"></a>设计缓存一致性协议的通用思路</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>在多核系统中，缓存的状态定义变得尤为关键，为了提高效率实现共享不能简单地将其状态划分为invalid和valid：</p><ul><li>Validity：一个<em>valid</em>的cache block必须是其包含了最新的数据。</li><li>Dirtiness：Dirtiness一定是暗含了Validity。当cache block的状态发生变化时，其必须把结果写入到内存中。</li><li>Exclusivity：同样Exclusivity一定时暗含了Validity，且其是唯一一个拥有memory block的副本。</li><li>Ownership：是当前memory block的所有者，负责控制其响应和请求。</li></ul><h4 id="Stable-states"><a href="#Stable-states" class="headerlink" title="Stable states"></a>Stable states</h4><ul><li>$\text{M}$(modified)：valid，exclusive，owned and potentially dirty。</li><li>$\text{O}$(owned)：valid，owned，and potentially dirty but not exclusive。对于这种状态而言，<em>cache block</em>仅仅是只读的，其他核心的<em>cache block</em>也可能共享这个数据，但是其并不拥有控制权，所有的请求和响应都需要是$O$的<em>coherence controller</em>来处理。</li><li>$\text{E}$(exclusive)：valid，exclusive，and clean。</li><li>$\text{S}$(shared)：valid but not exclusive，not dirty and not owned。</li><li>$\text{I}$(invalid)：可以理解为Nothing。</li></ul><h4 id="Transient-states"><a href="#Transient-states" class="headerlink" title="Transient states"></a>Transient states</h4><p>我们定义如下的规则，对于$\text{XY}^{\text{Z}}$而言，其意味着只有经历完事件$\text{Z}$，才能完成状态$\text{X}$到$\text{Y}$的转换。</p><h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><p>我们定义如下的transactions:</p><ol><li>GetShared(<code>GetS</code>)：将block变为$\text{S}$状态。</li><li>GetModified(<code>GetM</code>)：将block变为$\text{M}$状态。</li><li>Upgrade(<code>Upg</code>)：将block从$\text{S}$或者$\text{O}$状态变为$\text{M}$状态。</li><li>PutShared(<code>PutS</code>)：从$\text{S}$状态释放block。</li><li>PutExclusive(<code>PutE</code>)：从$\text{E}$状态释放block。</li><li>PutOwned(<code>PutO</code>)：从$\text{O}$状态释放block。</li><li>PutModified(<code>PutM</code>)：从$\text{M}$状态释放block。</li></ol><p>同时我们可以知道CPU会对<em>cache controller</em>发送如下的事件：</p><ol><li>Load：如果缓存命中了，直接读取，否则执行<code>GetS</code>。</li><li>Store：如果在$\text{M}$或者$\text{E}$状态下命中了缓存，直接写入缓存，否则执行<code>GetM</code>或者<code>Upg</code>。</li><li>Atomic read-modify-write：如果在$\text{M}$或者$\text{E}$状态下命中了缓存，直接执行RMW语义，否则执行<code>GetM</code>或者<code>Upg</code>。</li><li>Instruction fetch：如果缓存命中了，直接读取，否则执行<code>GetS</code>。</li><li>Replace：执行<code>PutS</code>，<code>PutE</code>，<code>PutO</code>或者<code>PutM</code>。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>A Primer on Memory Consistency and Cache Coherence chapter 2 and chapter 6</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存与内存专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理缓存</title>
      <link href="/2023/08/18/%E7%89%A9%E7%90%86%E7%BC%93%E5%AD%98/"/>
      <url>/2023/08/18/%E7%89%A9%E7%90%86%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="物理缓存的基本操作"><a href="#物理缓存的基本操作" class="headerlink" title="物理缓存的基本操作"></a>物理缓存的基本操作</h2><p>物理缓存完全采用物理地址作为索引。由于物理地址具有的唯一性，其能够避免歧义和别名问题。如下图所示，首先虚拟地址通过MMU转化为物理地址，然后根据物理地址判断缓存是否命中。</p><p><img src="https://s2.loli.net/2023/08/18/YnqESIGakT18t9m.png" alt="物理缓存结构"></p><h2 id="操作系统与物理缓存的交互"><a href="#操作系统与物理缓存的交互" class="headerlink" title="操作系统与物理缓存的交互"></a>操作系统与物理缓存的交互</h2><p>由于物理缓存采取物理地址进行索引，无论是共享内存还是独享内存，物理地址的唯一性确保了歧义和别名问题都可以避免。然而，我们还需要关心一下I&#x2F;O问题。</p><h3 id="I-O与总线监听技术"><a href="#I-O与总线监听技术" class="headerlink" title="I&#x2F;O与总线监听技术"></a>I&#x2F;O与总线监听技术</h3><p>物理缓存基于总线监听技术来保证I&#x2F;O操作的缓存一致性。如下图所示，总线连接了CPU&#x2F;MMU&#x2F;cache，内存以及I&#x2F;O设备。使得每个设备都能收到其他设备的广播信息。如下图所示，当CPU需要读内存时，其会把物理地址的信息通过总线发送给内存，然后内存会把值发送给CPU。</p><p><img src="https://s2.loli.net/2023/08/18/i9hl3CYW1ndFfVH.png" alt="System bus"></p><p>总线中的数据传递是基于事务的思想实现的，通过一个或者多个总线事务进行传输。每一个总线事务只能够发送一定大小的数据，例如当需要从从磁盘里面读取数据时，会划分为多个总线事务，每个事务都会包含内存地址及数据。所有的设备都可以观察总线上的事务，当物理缓存没有使用总线时，其会监听总线上所有的总线事务(<em>snooping</em>)。</p><p>物理缓存会检查每个总线事务的地址，去判断给物理地址是否命中缓存，如果没有命中缓存，我们什么也不需要处理。然而当命中了缓存后，我们就需要思考如何进行处理呢。我们首先考虑<em>write-through</em>策略，当I&#x2F;O设备需要从这个地址读取内容时，我们不需要采取任何的内容，因为<em>write-through</em>策略保证了缓存和内存的一致性。然而，当I&#x2F;O设备需要写入内容到该地址时，必须要把对应的物理缓存的cache line的valid位置为0，从而让下次读取时产生cache miss，让CPU从内存中读取数据，保证缓存与内存的一致性。当然，有些实现直接修改cache line的block值。</p><p>对于<em>write-back</em>策略，当I&#x2F;O设备需要从这个地址读取内容时，如果dirty位为0，I&#x2F;O设备可以直接从内存中读，如果dirty为1，I&#x2F;O设备直接从cache读取数据，对于I&#x2F;O设备中这个过程是透明的，I&#x2F;O设备并不知道它是从内存读还是缓存读的。当I&#x2F;O设备需要写入内容到该地址时，如果其dirty位为0，缓存可以直接将其valid位置为0。如果正好写入的大小等于cache line，那么我们就可以直接替代cache line的值，然而很有可能写入的大小小于cache line，就需要硬件提供局部写入的机制，因为不能丢失原先已经写入的缓存的信息。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存与内存专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带有键值的虚拟缓存</title>
      <link href="/2023/08/17/%E5%B8%A6%E6%9C%89%E9%94%AE%E5%80%BC%E7%9A%84%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98/"/>
      <url>/2023/08/17/%E5%B8%A6%E6%9C%89%E9%94%AE%E5%80%BC%E7%9A%84%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>虚拟缓存存在一个很大的问题，由于每一个进程都拥有独立的地址空间。当上下文切换后，必须对缓存进行刷新。一个很简单的想法就是把pid和虚拟地址结合起来作为索引进行缓存查找，从而减少刷新缓存的次数。</p><h2 id="带有键值的虚拟缓存的基本操作"><a href="#带有键值的虚拟缓存的基本操作" class="headerlink" title="带有键值的虚拟缓存的基本操作"></a>带有键值的虚拟缓存的基本操作</h2><p>首先是硬件结构的变化，由于需要支持键值，每个cache line的tag都会增加一个进程键值用于区分不同的进程。同时我们需要一个新的寄存器来保存这个进程键值，如下图所示：</p><p><img src="https://s2.loli.net/2023/08/17/DMP4FEZoe96C5XQ.png" alt="带有键值的虚拟缓存"></p><p>带有键值的虚拟缓存除了其加了一个新的键值以外其本质与虚拟缓存的操作没有差别。其仍然通过虚拟地址进行索引，然而由于有额外的键值信息可以判断当前缓存是否属于当前进程。一个美好的愿望是硬件为系统中的每一个进程都生成一个独一无二的标识符，这样我们就不会产生歧义和别名。愿望始终是愿望，硬件能够提供的标识符往往数目很少，有些硬件仅仅支持8个标识符。所以会有某些进程共享同一个标识符，我们仍然会面临虚拟缓存的歧义和别名问题。</p><h2 id="操作系统与带有键值的虚拟缓存的交互"><a href="#操作系统与带有键值的虚拟缓存的交互" class="headerlink" title="操作系统与带有键值的虚拟缓存的交互"></a>操作系统与带有键值的虚拟缓存的交互</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当键值充足时，我们可以为每一个在系统中运行的进程分配一个独一无二的键，这样上下文切换的时候，对于<em>write-through</em>而言，我们都不需要刷新缓存，仅仅只需要改变寄存器中的进程键值即可。</p><p>当键值不够使用时，操作系统需要重新分配键值。一个常见的思路是换入和换出，我们仍然需要将某个键值换出，然后把所有有关于该键值的缓存进行刷新。对于<em>write-through</em>而言，我们做的操作会比较简单，我们直接可以直接把cache line的valid位置为0。对于<em>write-back</em>而言，我们还需要写入内存。实际上，你会发现，这样也带来了另外的复杂度，操作系统应该换出哪个键呢？</p><p>对于采取<em>write-back</em>的写策略，还有一个更加严重的问题。当我们对进程A进行了上下文切换后，其cache line的值可能已经被改变了，然而很有可能另一个进程B会刷新这个cache line，但是对于进程B而言，操作系统并没有进程A的页表信息，操作系统无法知道该写入哪个具体的物理内存。因此，大多数采取带有键值的虚拟缓存会采用<em>write-through</em>策略。</p><p>有些硬件提供了额外的机制，既然目前已经有键值信息，就可以把键值信息和页表信息组成一个映射，这样对于上述情况，就能够找到物理地址，从而写入数据。然而，却极大地增加了硬件负担。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>对于虚拟缓存而言，两个进程之间共享内存会因为上下文切换时自动对缓存进行刷新的机制避免别名问题，然而带有键值的虚拟内存会更加的复杂。</p><p>对于直接映射缓存而言，我们假设两个进程的相同的虚拟地址指向相同的物理地址。同时假设操作系统给进程$A$分配的键值为1，给进程$B$分配的键值为2。我们可以明确地知道由于虚拟地址相同，其找到的cache set必然相同，由于每个cache set只有一个cache line。如下图所示，当进程A切换到进程B时，进程B访问该虚拟地址，由于键值不同，会导致cache miss，然后读取<strong>相同的物理内存</strong>到cache中。然而，物理内存没有发生任何的改变。</p><p><img src="https://s2.loli.net/2023/08/17/iyScjte1s5PT3rD.png" alt="共享内存-直接映射虚拟缓存"></p><p>然而，大多数情况这两个进程的虚拟地址是不相同的，这样就和虚拟缓存的情况一样了，会产生别名的情况。当我们需要使用共享内存时，cache在一定程度上就失效了。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>MMU的一个重要作用就是将虚拟地址转化为物理地址。MMU内部提供了自动将虚拟地址转化为物理地址的机制，操作系统通过构建虚拟地址到物理地址的映射，对于每个进程操作系统都会构建页表的基地址将其放到某个特定的寄存器中。</p><h3 id="MMU与操作系统的交互"><a href="#MMU与操作系统的交互" class="headerlink" title="MMU与操作系统的交互"></a>MMU与操作系统的交互</h3><p>Sv39 RISC-V只使用虚拟地址的低39位作为索引来翻译物理地址。如下图所示，其使用了三层页表结构来将虚拟地址翻译为物理地址。其转化的过程相当简单，首先通过页表的基地址找到其L2的偏移量，然后读取其值找到二级页表的基地址找到其L1的偏移量，然后这样循环地进行找到物理地址加上虚拟地址中的偏移量即可。</p><p><img src="https://s2.loli.net/2022/06/06/pFzaiEU7LS2ZdAX.png" alt="RISC-V address translation details"></p><p>对于操作系统，只需要将页表的基地址放入<code>satp</code>寄存器中即可。硬件会自动完成虚拟地址到物理地址的转换。</p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>从上述的过程可以得知，既然硬件需要完成虚拟地址到物理地址，我们已经讲述过的虚拟缓存是不是完美符合这个需求的。现有的MMU都有一小块虚拟缓存，即TLB。TLB保存的缓存信息即为虚拟地址对应的物理地址以及页属性。由于不同进程的页表不同，其虚拟地址对应的物理地址也必然不同：</p><ul><li>对于虚拟缓存来说，每次进行上下文切换都需要将对应的cache line valid位置0。</li><li>对于带有键值的虚拟缓存来说，由于其键值存在，不需要每次上下文切换刷新TLB，当键值不够分配时，才需要将对应的cache line valid位置0。</li></ul><p>TLB是最适合使用虚拟缓存的，这是因为TLB是一个只读缓存且没有共享内存机制。</p><h2 id="基于物理标签的虚拟缓存"><a href="#基于物理标签的虚拟缓存" class="headerlink" title="基于物理标签的虚拟缓存"></a>基于物理标签的虚拟缓存</h2><p>虚拟缓存最重要的一个问题在于虚拟地址与物理地址的映射问题，虚拟地址是操作系统与硬件结合起来给进程提供的抽象，其映射关系会随着上下文切换发生改变，从而造成了别名和歧义问题。于是就提出了另一种类型的虚拟缓存，我们仍然使用虚拟缓存对cache se定位，同时找寻block offset。但是缓存中的tag使用物理地址。然而，这样我们不得不增加新的负担，也就是我们必须用通过MMU将虚拟地址转化为物理地址。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>UNIX Systems for Modern Architectures Chapter 4</li><li>UNIX Systems for Modern Architectures Chapter 5</li><li><a href="https://zhuanlan.zhihu.com/p/107096130">Cache 组织方式</a></li><li><a href="https://zhuanlan.zhihu.com/p/108425561">TLB原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存与内存专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟缓存</title>
      <link href="/2023/08/17/%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98/"/>
      <url>/2023/08/17/%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>我们已经讲述了缓存最基本的结构，然而一个核心的关键问题在于在现代的体系结构中，运行中的进程都是使用的虚拟地址，这是由硬件和操作系统提供了一个美好的假象。在上一节中，我们已经明确了一个核心关键点，内存地址与缓存之间是有一定的映射关系，那么我们是应该用虚拟地址还是物理地址呢？一种美好的愿望是我们直接使用虚拟地址，因为我们这样就不需要把虚拟地址通过MMU转化为物理地址，从而提高效率。然而，愿望始终是愿望。虚拟缓存给操作系统带来了极大的负担来保证一致性。</p><h2 id="虚拟缓存的基本操作"><a href="#虚拟缓存的基本操作" class="headerlink" title="虚拟缓存的基本操作"></a>虚拟缓存的基本操作</h2><p>无论如何，我们也只能有两种基本的操作，要么读要么写。当我们去读一个虚拟地址其内存值的时候，我们仍然按照相同的操作去查询缓存是否命中，如果缓存命中了，直接返回缓存值即可。如果缓存没有命中，我们需要先把虚拟地址通过MMU转化为物理地址，然后从内存中读取数据，并加载到缓存中。</p><p>写的问题就更加复杂了，由于写的策略有两种write-through和write-back（我们假设其都支持write-allocate）。我们需要考虑在这两种策略下，虚拟缓存是如何进行写的操作的。对于write-through，无论是命中了cache还是没有命中cache，其都需要把虚拟地址通过MMU转化为物理地址，然后写入内存。对于没有命中cache的情况，其会直接读取内存的值写入cache中。对于write-back而言，对于没有命中cache的情况，其和write-through是相似的，对于命中了cache的情况，我们只需要在cache中写入即可。</p><p><img src="https://s2.loli.net/2023/08/16/PGzDoUNlqK4ZdxX.png" alt="虚拟缓存"></p><p>你可能会发现，除了我们需要读取内存的时候要把虚拟地址转化为物理地址的情况，虚拟缓存似乎也没有什么本质改变。然而，我们必须得思考一个问题，就是读写权限的问题。</p><ul><li>缓存读的虚拟地址对应的物理地址实际上已经变得无法读取了，然而缓存并不知道这个信息，如果我们仍然访问这个虚拟地址，缓存会直接给CPU返回其保存的值，显然我们需要判断这个物理地址是否可读。</li><li>同理，缓存写的虚拟地址对应的物理地址也可能变得无法写入了。对于cache miss的情况，我们能够轻易地进行判断，因为我们会把虚拟地址通过MMU转化为物理地址，可以判断这个物理地址是否可写。对于cache hit的情况，如果其dirty flag已经是1，我们显然可以得知这个虚拟地址对应的物理地址是可写的。麻烦的情况在于dirty flag为0，我们必须知道其到底是否可写，所以我们需要把虚拟地址转化为物理地址去判断这个地址是否可写。</li></ul><h2 id="歧义-Ambiguity-与别名-Alias"><a href="#歧义-Ambiguity-与别名-Alias" class="headerlink" title="歧义(Ambiguity)与别名(Alias)"></a>歧义(Ambiguity)与别名(Alias)</h2><h3 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h3><p>我们首先回忆一下操作系统是如何与硬件结合实现虚拟地址转化到物理地址。对于每一个进程，操作系统需要维持一个页表，这个页表包含了从虚拟地址到物理地址的映射，操作系统分配内存时，会自动从空闲的内存中分配页然后修改页表，然后按照硬件规则完成虚拟地址到物理地址的映射。也就是对于两个不同的进程，其相同的虚拟地址完全可以对应不同的物理地址。当操作系统对进程进行调度后，由于我们是按照虚拟地址进行缓存的映射，虚拟缓存无法意识到这个物理地址已经改变了。因此，操作系统在此时必须做一些事情来刷新缓存。</p><p><img src="https://s2.loli.net/2023/08/16/qvKxtZG1NngHer8.png" alt="虚拟缓存-歧义"></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>进程间的通信有一个重要的方法就是共享内存，即不同的虚拟地址能够映射到同一个物理地址。然而，由于两个进程的虚拟地址不同，其对应的cache set也会不同，假设采取的策略为write-back，当某一个进程修改了共享内存，其只会改变与其对应的cache line的值，却不会改变另一个进程的cache line的值，进而导致不一致问题。</p><p><img src="https://s2.loli.net/2023/08/16/sdqVXHNUEbKjBCQ.png" alt="虚拟缓存-别名"></p><h2 id="操作系统与虚拟缓存的交互"><a href="#操作系统与虚拟缓存的交互" class="headerlink" title="操作系统与虚拟缓存的交互"></a>操作系统与虚拟缓存的交互</h2><p>由于歧义和别名问题，在许多场景下，操作系统必须要采取一些策略来保证缓存的一致性。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>当发生上下文切换时，一个虚拟地址可能会映射到另一个物理地址，此时虚拟缓存就应该失效了。所以内核会强制刷新所有当前进程的缓存。对于只进行了读操作的cache line，我们只需要让这个cache line的valid位置为0。对于进行了写的操作，如果其策略为write-through，其操作也很简单，将valid位置为0，然而如果写策略为write-back，我们需要把每一个改变了的cache line重新写入内存，会花费大量的时间。</p><p>除此之外，如果上下文切换相当地频繁，缓存的命中率会急剧地下降。因此，虚拟缓存最合适的场景是计算型任务以及批处理任务。减少了虚拟地址转化为物理地址的损耗，同时避免上下文切换带来的性能损耗。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>对于两个进程使用共享内存的情况，是不存在别名问题的，因为上下文切换时会自动解决这个问题。然而，麻烦的在于可能存在同一个进程两个不同的虚拟地址映射到同一块共享内存，这样就导致了别名问题。一个很简单的解决方法就是不使用cache。</p><h3 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>对于buffered IO而言，由于操作系统管理的内核使用统一的虚拟地址，其不会存在歧义和别名问题。然而，最大的问题在于DMA设备，由于DMA设备直接与内存交互，会导致缓存与内存的不一致问题，即unbuffered I&#x2F;O。</p><p>当用户采用系统调用<code>write</code>时，且缓存写策略为write-back时，不会直接把修改的数据写入到内存中，如果此时DMA设备读取相关的数据，就会导致不一致性问题。所以当DMA设备需要读取数据时，操作系统应强制刷新缓存。如果采用阻塞I&#x2F;O，当执行<code>write</code>或者<code>read</code>系统调用时，操作系统本身就会进行上下文的切换，对缓存进行刷新。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>UNIX Systems for Modern Architectures Chapter 3</li><li><a href="https://zhuanlan.zhihu.com/p/107096130">Cache 组织方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存与内存专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存基础知识</title>
      <link href="/2023/08/16/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/08/16/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="通用的缓存组织结构"><a href="#通用的缓存组织结构" class="headerlink" title="通用的缓存组织结构"></a>通用的缓存组织结构</h2><p>缓存的目的在于减少CPU直接从内存中读取数据的次数。缓存是静态存储器，其不需要对电容进行刷新的性质决定了其访问速度必然快于动态存储器（内存）。如何构建内存与缓存之间的映射关系是缓存的一个最重要的基础知识。对于开发者来说，缓存的存在是透明的。然而，当编写高性能计算或者多线程的程序时，我们不能忽视缓存这个在计算机体系结构中起到重要作用的部件。</p><p>我们假定某个计算机支持$m$位的内存地址。显然，常见的$m$为32位或者64位。如下图所示，缓存是由多个<em>cache set</em>组成的，每个<em>cache set</em>由多个<em>cache line</em>组成，同时每一个<em>cache line</em>包含一个<em>cache block</em>。我们定义如下的符号含义：</p><ul><li>$S$：cache set的数目。</li><li>$E$: 每一个cache set所包含的cache line的数目。</li><li>$B$: 每一个cache line所包含的cache block的总字节。</li></ul><p><img src="https://s2.loli.net/2023/08/15/Wr2qhtOZKT4b6Jl.png" alt="通用的缓存组织结构-基本"></p><p>我们需要根据当前的内存地址，首先定位到cache set，由于cache set的数目为$S$，故我们需要$s$位数来定位到某个cache set（显然，$2^{s} &#x3D; S$）。同时，我们需要$b$位数来定位到cache block的偏移量（显然，$2^{b} &#x3D; B$）。此时，我们还有一个问题没有解决，我们仍然需要判断其位于哪个cache line中。我们在前两个过程中已经使用了$s + b$位，故我们可以使用剩下的$t &#x3D; m - (s + b)$位来去定位cache line。然而，目前的缓存组织结构中并不存在这个信息，所以我们需要在缓存中添加。同时，我们在cache line中添加一个标志位，判断当前cache line是否有效，如下图所示&#96;</p><p><img src="https://s2.loli.net/2023/08/15/97SbKtfo5JPCmsA.png" alt="通用的缓存组织结构"></p><h2 id="直接映射缓存-Direct-Mapped-caches"><a href="#直接映射缓存-Direct-Mapped-caches" class="headerlink" title="直接映射缓存(Direct-Mapped caches)"></a>直接映射缓存(Direct-Mapped caches)</h2><p>当$E &#x3D; 1$时，就被称为直接映射缓存，其原理就相当简单了。由于每一个cache set只包含一个cache line，所以每一个地址有且只能有一个cache line与之对应。然而，这样在某些情况下会带来很大的性能问题。举个例子，如下面的代码所示，我们循环地依次在地址$A$和地址$B$中写入数据。恰好不好，地址$A$的地址$B$的$s$是一致的。显然，他们会访问到同一个cache set，由于只有一个cache line，每次其对比tag值都不相同，故缓存硬件会从内存中读取相应的数据放到cache line中，导致每次cache line中的数据都会被刷新，也就是一直<em>cache miss</em>。这种现象被称为cache颠簸（<em>cache thrashing</em>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    *A = <span class="built_in">computeA</span>();</span><br><span class="line">    *B = <span class="built_in">computeB</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组相连缓存-Set-Associative-Caches"><a href="#组相连缓存-Set-Associative-Caches" class="headerlink" title="组相连缓存(Set Associative Caches)"></a>组相连缓存(Set Associative Caches)</h2><p>为了解决上述问题，每一个cache set可以含有多个cache line，假如$E &#x3D; 2$，对于上述例子而言，硬件会寻找两个cache line的tag值是否与物理地址的tag相等，这样就在一定程度上可以缓解cache颠簸。然而，这样也带了另一个问题，如果没有一个cache line与之对应，产生了cache miss。那么缓存必须换出一个cache line（如果有空的cache line，当然就直接使用了）。显然，这就回到了常见的换入换出策略了，例如LRU或者LFU。</p><h2 id="全相连缓存"><a href="#全相连缓存" class="headerlink" title="全相连缓存"></a>全相连缓存</h2><p>当$S &#x3D; 1$时，即只存在一个cache set时，我们直接舍弃了$s$。然而，我们增大了寻找cache line的成本，意味着需要遍历来找到我们所需的cache line，如果是cache miss的情况，我们甚至需要遍历所有的cache line。当然，硬件可能提供一些并行来加快速度，然而由于极高的硬件成本，采用率极少。</p><h2 id="缓存写策略"><a href="#缓存写策略" class="headerlink" title="缓存写策略"></a>缓存写策略</h2><ul><li><em>write-through</em>: 同时写入缓存和内存。其优势在于能够始终保持内存和缓存的一致性，劣势在于每次写CPU都会调用一次写内存操作，浪费时钟。</li><li><em>write-back</em>: 先写入缓存，后面再写入内存。每个cache line中会有一个bit位记录数据是否被修改过，称之为<em>dirty bit</em>。优势在于避免了写内存操作，然而劣势在于需要处理不一致性。</li></ul><h2 id="write-allocate"><a href="#write-allocate" class="headerlink" title="write-allocate"></a>write-allocate</h2><p>当使用<em>write-back</em>时，<em>write-allocate</em>通常一起被使用，CPU将数据写入内存的情况，如果缓存未命中其总是被写入缓存中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/102293437">Cache的基本原理</a></li><li><a href="https://csapp.cs.cmu.edu/">CSAPP Chapter 6</a></li><li>UNIX Systems for Modern Architectures Chapter 2</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存与内存专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Assignment4 Big Graph Processing in OpenMP</title>
      <link href="/2023/06/08/CS149-Assignment4-Big-Graph-Processing-in-OpenMP/"/>
      <url>/2023/06/08/CS149-Assignment4-Big-Graph-Processing-in-OpenMP/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>Before we use openMP to parallelize the code. We just first write the serial form. It is easy.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pageRank</span><span class="params">(Graph g, <span class="type">double</span>* solution, <span class="type">double</span> damping, <span class="type">double</span> convergence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> numNodes = <span class="built_in">num_nodes</span>(g);</span><br><span class="line">  <span class="type">double</span> equal_prob = <span class="number">1.0</span> / numNodes;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; ++i) &#123;</span><br><span class="line">    solution[i] = equal_prob;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>* tempArray = <span class="keyword">new</span> <span class="type">double</span>[g-&gt;num_nodes];</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> converged = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!converged) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> Vertex* iv = <span class="built_in">incoming_begin</span>(g, v); iv != <span class="built_in">incoming_end</span>(g, v); ++iv) &#123;</span><br><span class="line">        tempArray[v] += solution[*iv] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">outgoing_size</span>(g, *iv));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = tempArray[v] * damping + (<span class="number">1.0</span> - damping) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> t = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">outgoing_size</span>(g, v) == <span class="number">0</span>) &#123;</span><br><span class="line">          t += damping * solution[v] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] += t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> globalDiff = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      globalDiff += <span class="built_in">abs</span>(tempArray[v] - solution[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      solution[v] = tempArray[v];</span><br><span class="line">    &#125;</span><br><span class="line">    converged = globalDiff &lt; convergence;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] tempArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we can use openMP to parallelize the code above.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pageRank</span><span class="params">(Graph g, <span class="type">double</span>* solution, <span class="type">double</span> damping, <span class="type">double</span> convergence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> numNodes = <span class="built_in">num_nodes</span>(g);</span><br><span class="line">  <span class="type">double</span> equal_prob = <span class="number">1.0</span> / numNodes;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; ++i) &#123;</span><br><span class="line">    solution[i] = equal_prob;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>* tempArray = <span class="keyword">new</span> <span class="type">double</span>[g-&gt;num_nodes];</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> converged = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!converged) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g, solution)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> Vertex* iv = <span class="built_in">incoming_begin</span>(g, v); iv != <span class="built_in">incoming_end</span>(g, v); ++iv) &#123;</span><br><span class="line">        tempArray[v] += solution[*iv] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">outgoing_size</span>(g, *iv));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g, damping, numNodes)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = tempArray[v] * damping + (<span class="number">1.0</span> - damping) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> t = <span class="number">0.0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) reduction(+: t) shared(solution, g, numNodes, damping)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">outgoing_size</span>(g, v) == <span class="number">0</span>) &#123;</span><br><span class="line">        t += damping * solution[v] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g, t)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] += t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> globalDiff = <span class="number">0.0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) reduction(+: globalDiff) shared(tempArray, solution, g)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      globalDiff += <span class="built_in">abs</span>(tempArray[v] - solution[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, solution, g)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      solution[v] = tempArray[v];</span><br><span class="line">    &#125;</span><br><span class="line">    converged = globalDiff &lt; convergence;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] tempArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><h3 id="Top-Down-BFS"><a href="#Top-Down-BFS" class="headerlink" title="Top Down BFS"></a>Top Down BFS</h3><p>The easiest idea for implementing top-down bfs is to use two variables, one is for the current frontier, and another is for the next frontier. And when we add the new node to the next frontier, we should use <code>#pragma omp critical</code> to protect the next frontier. However, this method is too slow.</p><p>However, we could let each thread use its local next frontier. Thus we could avoid critical section and make the code faster.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">top_down_step</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Graph g,</span></span></span><br><span class="line"><span class="params"><span class="function">    vertex_set* frontier,</span></span></span><br><span class="line"><span class="params"><span class="function">    vertex_set* localList,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* distances)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;frontier-&gt;count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = frontier-&gt;vertices[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> start_edge = g-&gt;outgoing_starts[node];</span><br><span class="line">        <span class="type">int</span> end_edge = (node == g-&gt;num_nodes - <span class="number">1</span>)</span><br><span class="line">                           ? g-&gt;num_edges</span><br><span class="line">                           : g-&gt;outgoing_starts[node + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// attempt to add all neighbors to the new frontier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor=start_edge; neighbor&lt;end_edge; neighbor++) &#123;</span><br><span class="line">            <span class="type">int</span> outgoing = g-&gt;outgoing_edges[neighbor];</span><br><span class="line">            <span class="keyword">if</span> (distances[outgoing] == NOT_VISITED_MARKER &amp;&amp;</span><br><span class="line">            __sync_bool_compare_and_swap(&amp;distances[outgoing], NOT_VISITED_MARKER, distances[node] + <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="type">int</span> index = localList[<span class="built_in">omp_get_thread_num</span>()].count++;</span><br><span class="line">                  localList[<span class="built_in">omp_get_thread_num</span>()].vertices[index] = outgoing;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">      count[i] = totalCount;</span><br><span class="line">      totalCount += localList[i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    frontier-&gt;count = totalCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parallel copy the data from `localList` to `frontier`</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(frontier-&gt;vertices + count[i], localList[i].vertices,</span><br><span class="line">                localList[i].count * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bottom-Up-BFS"><a href="#Bottom-Up-BFS" class="headerlink" title="Bottom Up BFS"></a>Bottom Up BFS</h3><p>The Top Down BFS is an easy job to do actually. Because it is a prior algorithm. However, in the code, we would do many logical operations especially the frontier size is large and its ancestors’ size is small. Look at the following code snippet, which would cause so many logical operations.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distances[outgoing] == NOT_VISITED_MARKER &amp;&amp;</span><br><span class="line">  __sync_bool_compare_and_swap(&amp;distances[outgoing], NOT_VISITED_MARKER, distances[node] + <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> index = localList[<span class="built_in">omp_get_thread_num</span>()].count++;</span><br><span class="line">    localList[<span class="built_in">omp_get_thread_num</span>()].vertices[index] = outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Well, I cannot understand the principle of Bottom Up BFS. So I decide to read an essay which is called <a href="https://downloads.hindawi.com/journals/sp/2013/702694.pdf">Direction-optimizing breadth-first-search</a>.</p><p>I think the paper is enough. So I omit detail here. You should carefully read the paper. And I record some information here.</p><blockquote><p>The majority of the computational work in BFS is checking edges of the frontier to see if the endpoint has been visited. The total number of edge checks in the conventional top-down algorithm is equal to the number of edges in the connected component containing the source vertex, as on each step every edge in the frontier is checked.</p></blockquote><p>Well, at now the bottom-up way is clear. For every step, we just traverse all the vertices. And we have the current <code>frontier</code> information. From Top Down BFS, we need to check for every vertex’s neighbor to add it to the <code>next_frontier</code>. In the Bottom Up BFS, we just find whether the <code>child</code> is the ancestor of the vertices in the <code>frontier</code>. Thus every child would only can be visited once.</p><p>Now we can code.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">bottom_up_step</span><span class="params">(Graph g, <span class="type">bool</span>* frontier, <span class="type">bool</span>* new_frontier, <span class="type">int</span>* distances)</span> </span>&#123;</span><br><span class="line">    uint count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+: count)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;num_nodes; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distances[i] == NOT_VISITED_MARKER) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Vertex* incoming = <span class="built_in">incoming_begin</span>(g, i); incoming != <span class="built_in">incoming_end</span>(g, i); ++incoming) &#123;</span><br><span class="line">                <span class="keyword">if</span> (frontier[*incoming]) &#123;</span><br><span class="line">                    distances[i] = distances[*incoming] + <span class="number">1</span>;</span><br><span class="line">                    new_frontier[i] = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs_bottom_up</span><span class="params">(Graph graph, solution* sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> *frontier = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line">    <span class="type">bool</span> *new_frontier = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> *current = frontier;</span><br><span class="line">    <span class="type">bool</span> *next = new_frontier;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">        current[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set for the root node</span></span><br><span class="line">    current[ROOT_NODE_ID] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="comment">// initialize all nodes to NOT_VISITED</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;graph-&gt;num_nodes; i++)</span><br><span class="line">        sol-&gt;distances[i] = NOT_VISITED_MARKER;</span><br><span class="line">    sol-&gt;distances[ROOT_NODE_ID] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    uint count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">            next[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">bottom_up_step</span>(graph, current, next, sol-&gt;distances);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swap the pointer</span></span><br><span class="line">        <span class="type">bool</span> * temp = next;</span><br><span class="line">        next = current;</span><br><span class="line">        current = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] frontier;</span><br><span class="line">    <span class="keyword">delete</span>[] new_frontier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, the result is illustrated below.</p><p><img src="https://s2.loli.net/2023/06/08/GM7OjLKNf98ipeq.png" alt="bottom_up_first"></p><p>As you can see, I cannot get the full grades. I am wondering the reason. You could look at this <a href="http://www.nic.uoregon.edu/~khuck/ts/acumem-report/manual_html/ch06s07.html">article</a>.</p><p>And the article provides some tips:</p><ul><li>Avoid writing to global data that is accessed from multiple threads.</li><li>Align shared global data to cache line boundaries.</li><li>Don’t store temporary, thread specific data in an array indexed by th thread id or rank.</li><li>When parallelizing an algorithm, partition data sets along cache lines, not across cache lines.</li></ul><p>The last tip is what we could do. So we could use <code>schedule(dynamic, chunk_size)</code> for openMP to improve efficiency.</p><h3 id="Hybrid-BFS"><a href="#Hybrid-BFS" class="headerlink" title="Hybrid BFS"></a>Hybrid BFS</h3><p>The pairing of the top-down approach with the bottom-up approach is complementary, since when the frontier is its largest, the bottom-up approach will be at its best whereas the top-down approach will be at its worst, and vice versa.</p><p>So the idea is simple. Uses the Top Down BFS for steps when the frontier is large. We begin each search with the Top Down BFS and continue until the frontier becomes too large, at which point we switch to the Bottom Up BFS.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs_hybrid</span><span class="params">(Graph graph, solution* sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A flag</span></span><br><span class="line">    <span class="type">bool</span> isUpDownBFS = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> switchFlag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up for Bottom Up BFS</span></span><br><span class="line">    <span class="type">int</span> chunk_size = MACHINE_CACHE_LINE_SIZE * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">while</span> (graph-&gt;num_nodes &lt; <span class="built_in">omp_get_max_threads</span>() * chunk_size) &#123;</span><br><span class="line">        chunk_size /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> *frontier_bottom_up_bfs = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line">    <span class="type">bool</span> *new_frontier_bottom_up_bfs = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line">    <span class="type">bool</span> *current = frontier_bottom_up_bfs;</span><br><span class="line">    <span class="type">bool</span> *next = new_frontier_bottom_up_bfs;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">        current[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current[ROOT_NODE_ID] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up for Top Down BFS</span></span><br><span class="line">    vertex_set list;</span><br><span class="line">    <span class="built_in">vertex_set_init</span>(&amp;list, graph-&gt;num_nodes);</span><br><span class="line">    <span class="type">int</span> maxThreadNum = <span class="built_in">omp_get_max_threads</span>();</span><br><span class="line">    vertex_set localList[maxThreadNum];</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxThreadNum; ++i) &#123;</span><br><span class="line">        <span class="built_in">vertex_set_init</span>(&amp;localList[i], graph-&gt;num_nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count[maxThreadNum];</span><br><span class="line">    vertex_set* frontier_top_down_bfs = &amp;list;</span><br><span class="line">    frontier_top_down_bfs-&gt;vertices[frontier_top_down_bfs-&gt;count++] = ROOT_NODE_ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global configuration</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="comment">// initialize all nodes to NOT_VISITED</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;graph-&gt;num_nodes; i++)</span><br><span class="line">        sol-&gt;distances[i] = NOT_VISITED_MARKER;</span><br><span class="line">    sol-&gt;distances[ROOT_NODE_ID] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    uint frontier_length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (frontier_length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUpDownBFS) &#123;</span><br><span class="line">            <span class="comment">// We come from Bottom Up BFS</span></span><br><span class="line">            <span class="keyword">if</span> (!switchFlag) &#123;</span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxThreadNum; ++i) &#123;</span><br><span class="line">                    <span class="built_in">vertex_set_clear</span>(&amp;localList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We need to copy the information from `current`</span></span><br><span class="line">                <span class="comment">// to the `frontier_top_down, it is trivial.</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current[i]) &#123;</span><br><span class="line">                        <span class="type">int</span> index = localList[<span class="built_in">omp_get_thread_num</span>()].count++;</span><br><span class="line">                        localList[<span class="built_in">omp_get_thread_num</span>()].vertices[index] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">                    count[i] = totalCount;</span><br><span class="line">                    totalCount += localList[i].count;</span><br><span class="line">                &#125;</span><br><span class="line">                frontier_top_down_bfs-&gt;count = totalCount;</span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(frontier_top_down_bfs-&gt;vertices + count[i], localList[i].vertices,</span><br><span class="line">                    localList[i].count * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                switchFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxThreadNum; ++i) &#123;</span><br><span class="line">                <span class="built_in">vertex_set_clear</span>(&amp;localList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">top_down_step</span>(graph, frontier_top_down_bfs, localList, count, sol-&gt;distances);</span><br><span class="line">            frontier_length = frontier_top_down_bfs-&gt;count;</span><br><span class="line">            <span class="keyword">if</span> (frontier_length != <span class="number">0</span> &amp;&amp; graph-&gt;num_nodes / frontier_length&lt; UP_THRESHOLD) &#123;</span><br><span class="line">              isUpDownBFS = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We come from Top Down BFS</span></span><br><span class="line">            <span class="keyword">if</span> (switchFlag) &#123;</span><br><span class="line">                <span class="comment">// We should first clear the `current` because it has</span></span><br><span class="line">                <span class="comment">// some dirty data.</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">                    current[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Transfer the information from `frontier_top_down_bfs` to</span></span><br><span class="line">                <span class="comment">// `current`. It is easy for converting from Top Down BFS to</span></span><br><span class="line">                <span class="comment">// Bottom Up BFS</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; frontier_top_down_bfs-&gt;count; ++i) &#123;</span><br><span class="line">                    current[frontier_top_down_bfs-&gt;vertices[i]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                switchFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">                next[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontier_length = <span class="built_in">bottom_up_step</span>(graph, current, next, sol-&gt;distances, chunk_size);</span><br><span class="line">            <span class="type">bool</span> * temp = next;</span><br><span class="line">            next = current;</span><br><span class="line">            current = temp;</span><br><span class="line">            <span class="keyword">if</span> (frontier_length != <span class="number">0</span> &amp;&amp; graph-&gt;num_nodes / frontier_length &gt; BOTTOM_THRESHOLD ) &#123;</span><br><span class="line">              isUpDownBFS = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] frontier_bottom_up_bfs;</span><br><span class="line">    <span class="keyword">delete</span>[] new_frontier_bottom_up_bfs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS149 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Assignment3 A Simple CUDA Renderer</title>
      <link href="/2023/06/07/CS149-Assignment3-A-Simple-CUDA-Renderer/"/>
      <url>/2023/06/07/CS149-Assignment3-A-Simple-CUDA-Renderer/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>The result is illustrated in the following figure.</p><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question 1"></a>Question 1</h3><p>As you can see, due to the parallelism of the GPU, the bandwidth is huge.</p><h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question 2"></a>Question 2</h3><p>From the results, we can get that the bottleneck is the memory and CPU of the host itself. For the execution time of the kernel, the speed is very fast. However, the speed is low for copying the host memory into the device memory and vice versa.</p><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><p>First, we need to implement the parallelism form of <code>scan</code>. The algorithm is super wonderful. You should first understand the algorithm.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exclusive_scan_iterative</span><span class="params">(<span class="type">int</span>* start, <span class="type">int</span>* end, <span class="type">int</span>* output)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N = end - start;</span><br><span class="line">    memmove(output, start, N*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// upsweep phase</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> two_d = <span class="number">1</span>; two_d &lt;= N/<span class="number">2</span>; two_d*=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> two_dplus1 = <span class="number">2</span>*two_d;</span><br><span class="line">        parallel_for (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += two_dplus1) &#123;</span><br><span class="line">            output[i+two_dplus1<span class="number">-1</span>] += output[i+two_d<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output[N<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// downsweep phase</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> two_d = N/<span class="number">2</span>; two_d &gt;= <span class="number">1</span>; two_d /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">int</span> two_dplus1 = <span class="number">2</span>*two_d;</span><br><span class="line">        parallel_for (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i += two_dplus1) &#123;</span><br><span class="line">            <span class="type">int</span> t = output[i+two_d<span class="number">-1</span>];</span><br><span class="line">            output[i+two_d<span class="number">-1</span>] = output[i+two_dplus1<span class="number">-1</span>];</span><br><span class="line">            output[i+two_dplus1<span class="number">-1</span>] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It may seem that we need <code>N</code> threads for every inner loop, however, this is a stupid idea, we should calculate how many threads we need for each inner loop.</p><h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h2><p>Before diving into how to write a render using CUDA. We first think about how to implement a render with cpp. And after that, you need to read the code written with CUDA.</p><h3 id="First-Implementation"><a href="#First-Implementation" class="headerlink" title="First Implementation"></a>First Implementation</h3><p>For the first implementation, I focus on how to write the correct code. The hint part <code>exclusive_scan</code> has made me think we could first store the circle render parameters for each pixel. Thus we can scan the circle render parameters for each pixel.</p><p>Thus, we can solve the two important questions:</p><ul><li><em>Atomicity</em>: we have made the memory independent for each pixel. So we can write whatever we want without any synchronization and mutation.</li><li><em>Order</em>: We have make an explicit array of render parameters. So the order doesn’t matter.</li></ul><p>So, We first need to construct an array to hold the render parameters for each pixel.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaMalloc</span>(&amp;cudaDevicePixelData, image-&gt;width * image-&gt;height * numCircles * <span class="number">4</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br></pre></td></tr></table></figure><p>Now, we first write the render information for every pixel. The core code is below:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pixelPtrStart = <span class="number">4</span> * cuConstRendererParams.numCircles * (pixelY * imageWidth + pixelX) + <span class="number">4</span> * circleIndex;</span><br><span class="line">float4* pixelPtr = (float4*)(&amp;cuConstRendererParams.pixelData[pixelPtrStart]);</span><br><span class="line">float4 color;</span><br><span class="line">color.x = rgb.x;</span><br><span class="line">color.y = rgb.y;</span><br><span class="line">color.z = rgb.z;</span><br><span class="line">color.w = alpha;</span><br><span class="line"></span><br><span class="line">*pixelPtr = color;</span><br></pre></td></tr></table></figure><p>Then we can launch a new kernel to calculate for each pixel:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCircles; ++i) &#123;</span><br><span class="line">    float4* pixelPtr = (float4*)(&amp;cuConstRendererParams.pixelData[startIndex + i * <span class="number">4</span>]);</span><br><span class="line">    color.x = (*pixelPtr).w * (*pixelPtr).x + (<span class="number">1</span> - (*pixelPtr).w) * color.x;</span><br><span class="line">    color.y = (*pixelPtr).w * (*pixelPtr).y + (<span class="number">1</span> - (*pixelPtr).w) * color.y;</span><br><span class="line">    color.z = (*pixelPtr).w * (*pixelPtr).z + (<span class="number">1</span> - (*pixelPtr).w) * color.z;</span><br><span class="line">    color.w += (*pixelPtr).w;</span><br><span class="line">  &#125;</span><br><span class="line">  *imagePtr = color;</span><br></pre></td></tr></table></figure><p>However, <code>cudaDevicePixelData</code> is too big, which will consume so much memory, which would exceed the maximum memory 16GB. So we need to reuse the render information. We should not store the information for every pixel. Because the render information of each circle is deterministic. But the things we need to make sure is that whether the circle has contributed to the pixel. So instead of storing the render information for each pixel, we could just use bit mask to indicate whether the circle has contributed to the pixel.</p><p>Now, the result is illustrated by below.</p><p><img src="https://s2.loli.net/2023/06/07/JyrZ64K8W2uI3Tp.png" alt="first render score"></p><p>As you can see, we have passed some tests and the performance is not good at all. The reason why there are some failed tests is that the bytes exceed $2^{63}$, which would overflow.</p><h3 id="Best-practice"><a href="#Best-practice" class="headerlink" title="Best practice"></a>Best practice</h3><p>We should use a clever way to solve this problem. The problem is a two-dimensional problem. So we’d better design the grid and block for two dimensions, as the following figures illustrates:</p><p><img src="https://s2.loli.net/2023/08/22/MWiVgyBYRU2CmlD.png" alt="grid and block design for rendering"></p><p>From the above figures, we could write the following code to initialize the grid and block size:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CudaRenderer::render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> block_x = <span class="number">16</span>, block_y = <span class="number">32</span>;</span><br><span class="line">  <span class="function">dim3 <span class="title">blockDim</span><span class="params">(block_x, block_y)</span></span>;</span><br><span class="line">  <span class="type">int</span> grid_x = (image-&gt;width + blockDim.x - <span class="number">1</span>) / blockDim.x;</span><br><span class="line">  <span class="type">int</span> grid_y = (image-&gt;height + blockDim.y - <span class="number">1</span>) / blockDim.y;</span><br><span class="line">  <span class="function">dim3 <span class="title">gridDim</span><span class="params">(grid_x, grid_y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And we should render a block each time, we have already split the pixels into the block. For each block, we should handle the each pixel, we could calculate the current pixel’s x coordinate and y coordinate and the current thread id:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> thread_id = threadIdx.y * blockDim.x + threadId.x;</span><br><span class="line"><span class="type">int</span> pixel_index_x = blockId.x * blockDim.x + threadId.x;</span><br><span class="line"><span class="type">int</span> pixel_index_y = blockId.y * blockDim.y + threadId.y;</span><br></pre></td></tr></table></figure><p>So what a thread should do? We have already mapped a pixel $(x, y)$ with a specified thread. So the idea should be simple enough.</p><ul><li><strong>We could traverse sequentially all the circles to tell whether the circle has contributed to this pixel, and we calculate to achieve rendering</strong>.</li></ul><p>However, this way is too slow. For every pixel, we could calculate a lot of useless calculation. For example, if there are total 100,000,000 circles, there would be many useless circles for this pixel. So we should find a way to find the circles in the current block. So we could use a shared memory (a bit map) to know whether the <em>BLOCK</em> size circle has contributed to the block. So for each pixel (each thread) we could calculate ONLY one circle to know whether it has contributed to this block. And for each pixel, we could use the contributed circles to sequentially achieve rendering.</p><p>Look at what parallelism we have done:</p><ul><li>Each pixel renders itself using two-dimension task split.</li><li>Each pixel handles 1 circle to tell whether it contributes to the current block for $num_{circles} &#x2F; size_{block}$ loops.</li></ul><p>It’s a really hard question, but it is very useful.</p>]]></content>
      
      
      <categories>
          
          <category> CS149 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《秽翼的尤斯蒂娅》——荒诞还是存在？</title>
      <link href="/2023/06/07/%E3%80%8A%E7%A7%BD%E7%BF%BC%E7%9A%84%E5%B0%A4%E6%96%AF%E8%92%82%E5%A8%85%E3%80%8B%E2%80%94%E2%80%94%E8%8D%92%E8%AF%9E%E8%BF%98%E6%98%AF%E5%AD%98%E5%9C%A8%EF%BC%9F/"/>
      <url>/2023/06/07/%E3%80%8A%E7%A7%BD%E7%BF%BC%E7%9A%84%E5%B0%A4%E6%96%AF%E8%92%82%E5%A8%85%E3%80%8B%E2%80%94%E2%80%94%E8%8D%92%E8%AF%9E%E8%BF%98%E6%98%AF%E5%AD%98%E5%9C%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>实际上，这部作品在我高中的时候我已经想玩了，然而伴随着时间的推移却是在我研二的时光用两天的时间就完了。回想起来仍然感谢自己是在现在这个时间段欣赏了这个作品。</p><p>故事的整体背景实际上是非常好理解的，伴随着整个国家牢狱、下层和上层的划分，人物的阶级属性也就十分鲜明了。整个故事的剧情是线性的，与许多感想讨论的最终章的电车理论相比，我个人将这部作品的基调定为对存在、虚无和荒诞的思考。实际上，我个人认为这部作品对于脚本家想表达的核心就是对存在的思考。然而，GalGame终究是GalGame，本作品在一些章节中考虑的东西过于幼稚，这也是没有办法的事情。然而，我认为这部作品成功的原因就是把其思考的问题贯穿到了整部作品中。</p><h2 id="菲奥奈"><a href="#菲奥奈" class="headerlink" title="菲奥奈"></a>菲奥奈</h2><p>菲奥奈篇可谓是本部作品中剧情和人物塑造最好的一个篇章。本篇章的开始即交代了当前的背景，不蚀金锁成为了目前牢狱的实质管辖人，由于黑羽的出现扰乱了牢狱本身的秩序，导致了防疫局和不蚀金锁进行合作（实际上，这一幕远没有这么简单，这个时候就已经为下一章的内容进行了铺垫）。菲奥奈作为防疫局队长，刚正不阿，为人正直，无不体现其正义性。菲奥奈深知工作不得牢狱人民的人心，但身怀荣耀，坚信自己的意志。然而，她拥有的是抽象的正义。她并不理解牢狱的人往往没有选择。但是，我认为她是明白这个世界的道理的，只是她也在挣扎。</p><p>在后续的剧情中，逐渐地揭示了菲奥奈的理念来源：</p><ul><li>集体荣誉感。</li><li>恩赐之剑：家族荣耀，父亲清廉的象征。</li><li>父亲也得了羽化病，然而父亲支持他们的工作，父亲是她公正信念的又一来源。</li><li>进入防疫局的原因就是因为哥哥，认为防疫局的工作就是命运。</li></ul><p>然而，在追捕黑羽的过程中，其依赖的东西接而破碎。首先是团队内部的叛徒破坏了团队内部保护羽化病人的信念，反而借黑羽的名杀戮羽化病人。其次是意识到了黑羽可能是自己的哥哥，对自己和男主之间进行的交易感到痛恨。再而是明白了防疫局的真相，防疫局从来不保护羽化病人，而是对这些羽化病人进行惨无人道的人体实验。在我个人看来，菲奥奈的信念已然崩塌。就如同“大崩落”一样，将菲奥奈奋斗至今的意义全部抹杀。其开始怀疑其自身存在的价值。</p><p>在这个篇章中，玩家有一个最重要的选择：</p><ol><li>不能让菲奥奈的双手染上亲人的鲜血</li><li>应该让菲奥奈来做决定</li></ol><p>如果这不是游戏，我们会做什么选择了，如果是以理性的角度来讨论这个问题，我们都应该选择第二个选项。因为这涉及到了菲奥奈自身的存在。值得玩味的是，如果选择了第一个选项，菲奥奈就会依赖男主，得到小小的幸福。我从来不认为小小的幸福就不是一个好的选择。而是，菲奥奈应该去寻找自己的意义。她已然虚无，自己的信念全部被打碎了。最后，菲奥奈哥哥给了他的忠告，告诉其应该关注具体的正义：</p><blockquote><p>剑的正义会随着挥剑之人而改变</p><p>你要役剑</p><p>绝对不要为剑所役</p><p>你不要被家族之名束缚地活下去</p><p>用自己的双眼看透何为正义</p></blockquote><p>在最后的剧情中，男主选择通过另一种方式告诉了菲奥奈要去寻找自身的意义。实际上我认为这部分能够写的更有深度的。但是，在我看来这个篇章描述了一个很重要的问题，菲奥奈的抽象正义从何而来，当其破碎了，她又该怎么走向存在呢？还是走向荒诞呢？</p><h2 id="艾莉丝"><a href="#艾莉丝" class="headerlink" title="艾莉丝"></a>艾莉丝</h2><p>个人认为这个篇章极其地鬼畜，主要在于在菲奥奈篇中艾莉丝的形象简直发生了翻天覆地的变化。我并不打算分析艾莉丝这个角色，其角色的塑造是显而易见的。然而，我认为在这个篇章中塑造的核心角色反而是男主。这个篇章中揭示了男主在“大崩落”发生的具体情况。实际上，这个篇章中男主的复杂性是第一次体现出来的。</p><p>男主为了摆脱男妓，成为了一名职业杀手。然而，男主内心实际上是痛苦和迷茫的。剧情中有许多他的心理暗示。</p><blockquote><p>我不想卖身，而先代给我指出了男妓之外的道路。这就已经足够了。</p><p>想要活下去，就必须要忍受、放弃很多的事情。</p><p>生活在这里，就只能考虑现在的自己能做些什么。</p><p>不管理想和不满反差有多么强烈，也不会产生任何改变。</p></blockquote><p>可以看出，男主是并认为牢狱有什么资格谈理想以及未来的，然而男主真的没有这个资格么？男主在牢狱这个环境里面，也是上层阶级。显然，男主扼杀了自己对生存的意义的追问。然而，男主却对艾莉丝说出了，“我希望你能成为一个自由的人”。实际上，在后面剧情中也证实了这是男主对自己的期望。正是因为自己没有去追问生存的意义，所以希望艾莉丝成为这样的人。</p><blockquote><p>每个人都必定会有其生存的意义。</p><p>人生中最重要的事情，就是努力地经营自己的人生，然后去找到生存的意义。</p></blockquote><p>当然，当男主回想起了上述的话，其本质也是在逃避的。男主认为这些话在牢狱里面都是不现实的想法，在牢狱里面优先考虑的就是食物。抱有这种想法，在牢狱是活不下去的。这一章中，男主的复杂性就展现出来了。实际上，男主一直在追问生存的意义。面对在牢狱里的虚无，男主通过荒诞的形式去反抗。</p><h2 id="圣女伊莲"><a href="#圣女伊莲" class="headerlink" title="圣女伊莲"></a>圣女伊莲</h2><p>我认为这条线可谓是本游戏中最为精彩的一条线。这条线是对荒诞最大深层次的思考。这个世间所有的人们都认为这个悬浮在空中的世界都是依靠圣女的天使的祈祷的。所以上一次“大崩落”的发生归咎于第一代圣女没有认真的履行自己的指责。然而，事实的真相却是圣女的祈祷是没有任何作用的，这个悬浮在空中的世界并不是依靠圣女的力量。人们只需要在发生“大崩落”的时候，把圣女送上刑场，平息百姓的愤怒。</p><p>当代圣女使用自己的方式来对抗这种荒诞，正因为她自己意识到了这种荒诞，她必须坚信自己的信仰来维持她自身，以维持自身的存在。为一个虚无的事物坚持是毫无意义的。正也是为什么其面对许多外界压力时，仍然坚持其信仰的根本原因。她的存在必须让她这么做。所以面对拉菲的质疑时，圣女伤心的真正原因就在此。其自身的存在容不得被消灭。为什么圣女的双眼看不清呢？难道不就是为了对抗这种荒诞吗？</p><p>这也是我对这条线最欣赏的原因。这条线的圣女展现出了完全与现阶段剧情中人们不一样的观念，面对这个世界的虚无，通过自己的方式尽力地走向存在。其次，圣女和男主下国际象棋博弈的过程，更为精彩，与其说是下棋，不如说是思想的斗争。圣女必须坚持自己的信仰，这是她存在这个世上最重要的意义，否则她就无法面对祈祷这件事情的虚无。而男主却认为手段无所谓，目的达成即可。</p><p>当男主得知了事情的真相后，如同菲奥奈的信念被破碎了一样。男主也产生了迷茫，其在牢狱的一切生存理由都被打破了。任谁都会觉得荒诞，本来认为的真相竟然全部都是虚伪的谎言：</p><blockquote><p>如果让都市浮起的不是圣女的话</p><p>为什么，大崩落会发生呢？</p><p>为什么，我的家人会不得不死呢？</p><p>为什么，我会被迫在那名为牢狱的地狱中生活呢？</p></blockquote><p>本剧情中，最精彩的可能就是圣女给男主传达的话语了：</p><blockquote><p>你一直停滞不前，该考虑一下自己的生存方式了。</p></blockquote><p>当然，我也很喜欢这段话。如果只有自己得到利益，才会肯定自己的生存方式，是得不到自由的。</p><blockquote><p>因为被拯救了而去相信，因为没有被拯救而不去相信</p><p>这种想法，是绝对得不到拯救的</p><p>咱们都很弱小，因为一点事就会飘摇不定</p><p>所以，才要相信</p><p>并不是在被拯救之后才去相信……而是要去相信而得到救赎</p></blockquote><p>在这一条线中，男主这个人物已然具体了。实际上男主的复杂性已经完全体现。由于生活在牢狱中，必须给自己的生存方式加以理由。然而，意义真的存在吗？其实到目前的剧情中，每个人都是伤痕累累的。信念也受到了崩塌，我无意探讨其细节之处。其真的走向存在了吗？实际上这个问题我回答不了，我们又有谁能说自己能够走向存在呢？</p><h2 id="莉西娅"><a href="#莉西娅" class="headerlink" title="莉西娅"></a>莉西娅</h2><p>莉西娅线纯粹就是为了爽。同样，我认为莉西娅线塑造的角色并不是莉西娅。当然，莉西娅也面临着意义的问题，走向为王路上的迷茫等。然而，我认为这个线最有趣的角色就是戈尔。戈尔就是男主。戈尔认为她和男主属于同一类人，都是在牢狱通过杀戮来生存的人。显然戈尔为了对抗这种虚无感，直接走向了荒诞。杀人与不杀人已然无所谓了。因为这就是她的生存方式。她为什么想杀死男主？难道不是因为她想把自己也杀死吗，她可能也嫉妒着男主吧。所以我认为她是本章中最为复杂的人。</p><p>在我看来，这就是写脚本的人的映射。男主实际上一直都是迷茫的，但是男主并没有直接选择荒诞来对抗这种虚无感。我认为这才是这一章最核心的东西。实际上男主的独白很值得玩味：</p><blockquote><p>不知为何，感觉死去的她就好像自己的某个亲人。</p><p>事实上，戈尔和我的人生轨迹几乎完全相同。</p><p>作为他人的所有物，而一直毫无道理地夺取他人的性命。</p><p>在这种生活之中，迷失了自己与他人的生存意义。</p><p>戈尔所面对的结局，应该就是像我们这样的人所经常会抵达的重点之一吧。</p><p>但是，我与戈尔不同。</p><p>我并没有输给自己所抱持的空虚，而将自己无谓地舍弃。</p><p>戈尔的死，让我再次加深了这个想法。</p></blockquote><h2 id="尤斯蒂娅"><a href="#尤斯蒂娅" class="headerlink" title="尤斯蒂娅"></a>尤斯蒂娅</h2><p>这一章节被许多人诟病。实际上我对这一章的看法完全没有从电车问题出发。当然，男主的哥哥持有的理念是牺牲牢狱的人而保护下层的人和上层的人，通过最小的代价来保证大多数的权益。而菲奥奈为了保护下层而战，吉克为牢狱而战。圣女为了坚持自己的信仰，为了自己的信仰而战。艾莉丝成为了一名称职的医生。</p><p>而男主呢？最后男主表示了自己确定了自己的生存信念：拯救尤斯蒂娅。我并不认可这种想法，实际上这是相当肤浅的。然而，没办法，受到商业的影响（毕竟需要恋爱故事）肯定有所妥协的。尤斯蒂娅为了拯救男主，选择净化了这个世界的污秽。</p><p>到这里，我不仅思考生存的意义对于男主而言到底是什么，实际上我认为终章并没有把这个问题阐述清楚。当然，我并不觉得只有男主在迷茫。难道其他角色没有迷茫过吗？哪怕他们的信念是坚定的，也只是他们必须要在这个虚无的世界中坚信信念才能走向存在。我并不认为存在才是解决问题的方式。可能这才是我对这一部分不满意的地方。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我的心里，我觉得这部作品最精彩的就是第一章，其紧凑的剧情以及优秀的人物塑造和背景让我一下就喜欢上了这部作品。然后后面的部分剧情是相对比较俗套的，但是圣女线这部分我认为是很多GalGame写不出的剧本，其探讨了很有价值的东西，反而是这部作品中很有深度的一章。然而，这部作品优秀的地方在于其对生存的意义的探讨。我们面对这个世界的虚无，应该做出怎么样的选择，我并不觉得里面的角色都能走向存在。然而，这部作品也温柔地探讨了这个问题。</p><p>这部作品有一个十分关键的词语：秽翼。浅薄的理解就是尤斯蒂娅能够净化这个世界的污秽，哪怕自己的翅膀染上污秽。然而在剧情中，天使的翅膀永远是纯净的。可能这就是这个世间。因为本身就是污秽，无论在牢狱、下层还是上层，我们都无可避免地去发问什么是生存的意义。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你写一个简单的SMTP服务器（五）</title>
      <link href="/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://luolibrary.com/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/">手把手教你写一个简单的SMTP服务器（一）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">手把手教你写一个简单的SMTP服务器（二）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/">手把手教你写一个简单的SMTP服务器（三）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/">手把手教你写一个简单的SMTP服务器（四）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/">手把手教你写一个简单的SMTP服务器（五）</a></li></ul><hr><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>在教程四中，我们已经实现了状态机，接下来我们定义一个<code>Context</code>类，其仅仅简单地封装一下，维持一个<code>current</code>变量指向当前的状态即可。我们需要在<code>miniSMTPServer/context</code>目录下创建<code>context.hpp</code>和<code>context.cpp</code>文件并修改<code>CMakeLists.txt</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/context.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;state.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;State&gt; *current;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Context</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span></span>;</span><br><span class="line">  ~<span class="built_in">Context</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/context.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;context.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;state.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line">Context::<span class="built_in">Context</span>() &#123; current = &amp;States::idleState; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">Context::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*current)-&gt;<span class="built_in">transitive</span>(parameters, current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/context/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(context STATIC state.cpp context.cpp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看出<code>Context</code>类十分的简单，这是因为大部分工作都已经实现了。</p><h2 id="SMTP-Server"><a href="#SMTP-Server" class="headerlink" title="SMTP Server"></a>SMTP Server</h2><p>现在，我们终于可以开始写我们的Server了，我们只需要完成一个简单得不能再简单的工作：按照空格分割字符串。然而你可能会想到最直接的方法就是定义一个<code>istringstream</code>。然而这是不正确的，因为可能会存在如下的情况：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAIL shejialuo@gmail.com OK</span><br><span class="line">MAIL  shejialuo@gmail.com NOT OK</span><br></pre></td></tr></table></figure><p>ABNF中严格地定义了只允许拥有一个空格。而所有命令的参数最多不超过1个。我们采取的策略就可以非常简单了，直接以一个空格分割字符串即可。但是值得注意的是，我们必须删除接收到的字符串的最后两个，根据协议其最后两个字符为<code>CRLF</code>，即<code>\r\n</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/miniSMTPServer.cpp</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">getParameters</span><span class="params">(std::string &amp;request)</span> </span>&#123;</span><br><span class="line">  request.<span class="built_in">pop_back</span>();</span><br><span class="line">  request.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="type">int</span> split = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; split &lt; request.<span class="built_in">size</span>(); split++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request[split] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string command = request.<span class="built_in">substr</span>(<span class="number">0</span>, split);</span><br><span class="line">  <span class="keyword">if</span> (split != request.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    std::string parameter = request.<span class="built_in">substr</span>(split + <span class="number">1</span>, request.<span class="built_in">size</span>() - split - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;command, parameter&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;command&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们只需要修改主函数就可以了，其逻辑十分的简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/miniSMTPServer.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, This is a simple SMTP server\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  TCPSocket socket&#123;&#125;;</span><br><span class="line">  socket.<span class="built_in">set_reuseaddr</span>();</span><br><span class="line">  socket.<span class="built_in">bind</span>();</span><br><span class="line">  socket.<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line">  std::string request&#123;&#125;;</span><br><span class="line">  Context context&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> s = socket.<span class="built_in">accept</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isDone = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isDone) &#123;</span><br><span class="line">      s.<span class="built_in">read</span>(request);</span><br><span class="line">      <span class="keyword">if</span> (request.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;S: Connection lost\n&quot;</span>;</span><br><span class="line">        s.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;C: &quot;</span> &lt;&lt; request;</span><br><span class="line">      std::string parameter&#123;&#125;;</span><br><span class="line">      std::vector&lt;std::string&gt; parameters = <span class="built_in">getParameters</span>(request);</span><br><span class="line"></span><br><span class="line">      std::string result = context.<span class="built_in">transitive</span>(parameters);</span><br><span class="line"></span><br><span class="line">      s.<span class="built_in">write</span>(result + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;S: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) == <span class="string">&quot;221&quot;</span>) &#123;</span><br><span class="line">        s.<span class="built_in">close</span>();</span><br><span class="line">        isDone = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要修改<code>miniSMTPServer/CMakeLists.txt</code>文件如下所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(miniSMTP miniSMTPServer.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(miniSMTP PROPERTIES RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(miniSMTP PRIVATE ./util ./context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(miniSMTP util context)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(./util)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(./context)</span><br></pre></td></tr></table></figure><p>然后进行编译最终运行<code>./miniSMTP</code>。你可以尝试许多的输入输出，如果你发现了Bug，欢迎给仓库提交<a href="https://github.com/shejialuo/miniSMTPServer">miniSMTPServer</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout finish-all</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你可能会发现我们没有对邮件进行任何的处理，之所以我不打算做这样的处理是因为这并不是我们应该做的重点。如果你想保存用户发送的邮件，是一个非常简单的事情。你可能会想是不是需要在<code>transitive</code>函数中做这样的处理。实际上最合理的方式是新增加一个<code>doAction</code>的虚函数。对于每一个状态其存在一个处理函数：</p><ul><li><code>IdleState</code>：清空邮件信息的缓存。</li><li><code>EhloState</code>：清空邮件信息的缓存。</li><li><code>MailState</code>：记录邮件的发送人。</li><li><code>RcptState</code>：记录邮件的接收人。</li><li><code>DataStartState</code>：记录发送的信息。</li><li><code>DataStartDone</code>：如果收到了<code>QUIT</code>命令，将邮件保存到硬盘。</li></ul><p>希望能够阅读到这儿的你，或多或少能有所收获。这是我第一次尝试写一个教程，终于明白了写一个教程的艰辛。希望你能有一天用自己的知识帮助到他人。</p>]]></content>
      
      
      <categories>
          
          <category> 手把手教你写一个简单的SMTP服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你写一个简单的SMTP服务器（四）</title>
      <link href="/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://luolibrary.com/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/">手把手教你写一个简单的SMTP服务器（一）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">手把手教你写一个简单的SMTP服务器（二）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/">手把手教你写一个简单的SMTP服务器（三）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/">手把手教你写一个简单的SMTP服务器（四）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/">手把手教你写一个简单的SMTP服务器（五）</a></li></ul><hr><p>在教程三中，我们已经完成了<code>IdleState</code>的操作，那么接下来的核心就是完成其他所有类的操作。为了方便读者的阅读，我们继续给出在教程二中绘制出了的状态图。</p><pre class="mermaid">stateDiagram-v2    [*] --> idle: server start    idle --> ehlo: EHLO    idle --> idle: RSET    ehlo --> mail: MAIL    mail --> rcpt: RCPT    rcpt --> rcpt: RCPT    rcpt --> dataStart: DATA    dataStart --> dataStart : except .    dataStart --> dataDone: .    ehlo --> ehlo: RSET, EHLO    mail --> ehlo: RSET, EHLO    rcpt --> ehlo: RSET, EHLO    dataStart --> ehlo: RSET, EHLO    dataDone --> ehlo: RSET, EHLO    dataDone --> mail: MAIL    idle --> [*]: QUIT    ehlo --> [*]: QUIT    mail --> [*]: QUIT    rcpt --> [*]: QUIT    dataStart --> [*]: QUIT    dataDone --> [*]: QUIT</pre><h2 id="EhloState"><a href="#EhloState" class="headerlink" title="EhloState"></a>EhloState</h2><p>对于<code>EhloState</code>，首先我们应该考虑其能够接收的额外命令。由状态图可知，我们需要<code>MAIL</code>命令。因此我们需要在<code>allowed</code>中添加额外的<code>MAIL</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line">EhloState::<span class="built_in">EhloState</span>() &#123; allowed.<span class="built_in">insert</span>(<span class="string">&quot;MAIL&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p>同时，我们也需要在<code>isCorrectParameters</code>中添加对<code>MAIL</code>命令参数的判断。我们给出<code>MAIL</code>命令请求和响应的ABNF范式。在这个范式中，我省略了对邮件格式正确性的描述，因为我认为这不是这个教程的重点，在本教程中，我们统一使用如下的正则表达式<code>regex = &quot;(\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+&quot;</code>来表示邮件的格式。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mail-request</span> <span class="operator">=</span> <span class="string">&quot;MAIL &lt;source&gt; CRLF&quot;</span></span><br><span class="line"><span class="attribute">mail-ok-reponse</span> <span class="operator">=</span> <span class="string">&quot;250&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Requested mail action okay, completed&quot;</span> <span class="keyword">CRLF</span></span><br></pre></td></tr></table></figure><p>因此，我们就可以修改<code>isCorrectParameters</code>函数，添加对<code>MAIL</code>命令的判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> std::regex pattern&#123;<span class="string">&quot;(\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;MAIL&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">2</span> || !std::<span class="built_in">regex_match</span>(parameters[<span class="number">1</span>], pattern)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们添加相应的单元测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="built_in">TEST</span>(State, isCorrectParametersMAIL) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;MAIL&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;MAIL&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;shejialuo@gamil..com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;shejialuo&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;shejialuo@.com.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;shejialuo@123.1.cn&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;test : tests) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = state-&gt;<span class="built_in">isCorrectParameters</span>(test);</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(result.<span class="built_in">has_value</span>());</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result.<span class="built_in">value</span>(), <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; successful&#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_FALSE</span>(state-&gt;<span class="built_in">isCorrectParameters</span>(successful).<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们仍然按照测试驱动的方式完成<code>EhloState</code>状态下的操作，测试的代码有许多可以重用<code>TEST(State, IdleStateTransitive)</code>。<code>RSET</code>和<code>EHLO</code>命令都不会改变其状态，与其说不改变而是从<code>EhloState</code>到<code>EhloState</code>。所以我们只需要关心<code>MAIL</code>命令，<code>MAIL</code>命令会转化到<code>MailState</code>中，根据上述分析，我们可以得出如下的测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="built_in">TEST</span>(State, EhloStateTransitive) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSTE&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;DATA&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;.&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RCPT&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;State&gt; *&gt;&gt; expects&#123;</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;221 &quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::mailState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;500 &quot;</span> + codeToMessages[<span class="string">&quot;500&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tests.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;EhloState&gt;();</span><br><span class="line">    std::unique_ptr&lt;State&gt; *current = &amp;States::ehloState;</span><br><span class="line">    std::string result = state-&gt;<span class="built_in">transitive</span>(tests[i], current);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(result, expects[i].first);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(current, expects[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始实现<code>EhloState::transitive</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::string <span class="title">EhloState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">transitiveHelper</span>(parameters, current); result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;MAIL&quot;</span>) &#123;</span><br><span class="line">    current = &amp;States::mailState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经发现了，我们的代码实际上非常的整洁，比起复杂的<code>if-else</code>，我们通过层层地抽象让代码变得十分的简单。你可以编译代码并执行测试。如果你的代码有问题你可以执行如下的命令切换到现在的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; make -j12 &amp;&amp; ctest --output-on-failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional</span></span><br><span class="line">git checkout ehlo-state</span><br></pre></td></tr></table></figure><h2 id="MailState"><a href="#MailState" class="headerlink" title="MailState"></a>MailState</h2><p>对于<code>MailState</code>，首先我们应该考虑其能够接收的额外命令。由状态图可知，我们需要<code>RCPT</code>命令。因此我们需要在<code>allowed</code>中添加额外的<code>RCPT</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line">MailState::<span class="built_in">MailState</span>() &#123; allowed.<span class="built_in">insert</span>(<span class="string">&quot;RCPT&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><p>同时，我们也需要在<code>isCorrectParameters</code>中添加对<code>RCPT</code>命令参数的判断。我们给出<code>RCPT</code>命令请求和响应的ABNF范式，其与<code>MAIL</code>命令类似，此处不赘述。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rcpt-request</span> <span class="operator">=</span> <span class="string">&quot;RCPT &lt;source&gt; CRLF&quot;</span></span><br><span class="line"><span class="attribute">rcpt-ok-reponse</span> <span class="operator">=</span> <span class="string">&quot;250&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Requested mail action okay, completed&quot;</span> <span class="keyword">CRLF</span></span><br></pre></td></tr></table></figure><p>因此，我们就可以修改<code>isCorrectParameters</code>函数，添加对<code>RCPT</code>命令的判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;MAIL&quot;</span> || parameters[<span class="number">0</span>] == <span class="string">&quot;RCPT&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">2</span> || !std::<span class="built_in">regex_match</span>(parameters[<span class="number">1</span>], pattern)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在<code>MAIL</code>命令中我们已经给出了很详细的单元测试，此处就忽略了单元测试。然后，我们仍然按照测试驱动的方式完成<code>MailState</code>状态下的操作，<code>RSET</code>和<code>EHLO</code>命令都改变其状态让其回到<code>EhloState</code>状态。对于<code>RCPT</code>命令，<code>RCPT</code>命令会令其转化到<code>RCPTState</code>中，根据上述分析，我们可以得出如下的测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="built_in">TEST</span>(State, MailStateTransitive) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;DATA&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;.&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;State&gt; *&gt;&gt; expects&#123;</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::mailState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;221 &quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::rcptState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::mailState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::mailState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::mailState&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tests.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;MailState&gt;();</span><br><span class="line">    std::unique_ptr&lt;State&gt; *current = &amp;States::mailState;</span><br><span class="line">    std::string result = state-&gt;<span class="built_in">transitive</span>(tests[i], current);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(result, expects[i].first);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(current, expects[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始实现<code>MailState::transitive</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::string <span class="title">MailState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">transitiveHelper</span>(parameters, current); result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;RCPT&quot;</span>) &#123;</span><br><span class="line">    current = &amp;States::rcptState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = &amp;States::ehloState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以编译代码并执行测试。如果你的代码有问题你可以执行如下的命令切换到现在的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; make -j12 &amp;&amp; ctest --output-on-failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional</span></span><br><span class="line">git checkout mail-state</span><br></pre></td></tr></table></figure><h2 id="RcptState"><a href="#RcptState" class="headerlink" title="RcptState"></a>RcptState</h2><p>对于<code>MailState</code>，首先我们应该考虑其能够接收的额外命令。由状态图可知，我们需要<code>RCPT</code>命令和<code>DATA</code>命令。因此我们需要在<code>allowed</code>中添加额外的<code>RCPT</code>和<code>DATA</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line">RcptState::<span class="built_in">RcptState</span>() &#123;</span><br><span class="line">  allowed.<span class="built_in">insert</span>(<span class="string">&quot;RCPT&quot;</span>);</span><br><span class="line">  allowed.<span class="built_in">insert</span>(<span class="string">&quot;DATA&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经处理了<code>RCPT</code>命令的判断，剩下就是<code>DATA</code>命令的判断，根据<code>DATA</code>命令的ABNF范式，我们可以做很简单的处理操作。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">data-request</span> <span class="operator">=</span> <span class="string">&quot;DATA CRLF&quot;</span></span><br><span class="line"><span class="attribute">data-ok-reponse</span> <span class="operator">=</span> <span class="string">&quot;250&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Requested mail action okay, completed&quot;</span> <span class="keyword">CRLF</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="string">&quot;NOOP&quot;</span> || command == <span class="string">&quot;QUIT&quot;</span> || command == <span class="string">&quot;RSET&quot;</span> || command == <span class="string">&quot;DATA&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们仍然按照测试驱动的方式完成<code>RCPTState</code>状态下的操作，<code>RSET</code>和<code>EHLO</code>命令都改变其状态让其回到<code>EhloState</code>状态。对于<code>RCPT</code>命令，<code>RCPT</code>命令并不会改变其状态。当其接收到<code>DATA</code>命令后，其会转化为<code>DataStartState</code>。根据上述分析，我们可以得出如下的测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(State, RCPTStateTransitive) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;DATA&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;.&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;State&gt; *&gt;&gt; expects&#123;</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::rcptState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;221 &quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::rcptState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::rcptState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::rcptState&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tests.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;RcptState&gt;();</span><br><span class="line">    std::unique_ptr&lt;State&gt; *current = &amp;States::rcptState;</span><br><span class="line">    std::string result = state-&gt;<span class="built_in">transitive</span>(tests[i], current);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(result, expects[i].first);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(current, expects[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们开始实现<code>RcptState::transitive</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">RcptState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">transitiveHelper</span>(parameters, current); result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;DATA&quot;</span>) &#123;</span><br><span class="line">    current = &amp;States::dataStartState;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;RCPT&quot;</span>) &#123;</span><br><span class="line">    current = &amp;States::rcptState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = &amp;States::ehloState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以编译代码并执行测试。如果你的代码有问题你可以执行如下的命令切换到现在的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; make -j12 &amp;&amp; ctest --output-on-failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional</span></span><br><span class="line">git checkout rcpt-state</span><br></pre></td></tr></table></figure><h2 id="DataStartState-DataDoneState"><a href="#DataStartState-DataDoneState" class="headerlink" title="DataStartState &amp; DataDoneState"></a>DataStartState &amp; DataDoneState</h2><p>对于<code>DataStartState</code>，首先我们应该考虑其能够接收的额外命令。由状态图可知，服务器端只能接收<code>.</code>命令，此时我们必须转换我们的思路了。我们原先的思路是通过<code>transitiveHelper</code>来处理，但由于在接收用户发送的数据阶段，哪怕用户发送<code>MAIL</code>，我们也不能将其作为命令。所以当且仅当服务器接收<code>.</code>命令时，我们才能进入到<code>DataDoneState</code>阶段。我们不能够重用任何以前的方法，哪怕用户输入了<code>. .</code>我们都必须认为这是邮件的内容。因此我们直接修改<code>transitive</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::string <span class="title">DataStartState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;.&quot;</span> &amp;&amp; parameters.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    current = &amp;States::dataDoneState;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于该方法的测试，我们需要考虑到更多的边界条件，首先我们必须要思考的是如何构建我们的测试，首先我们必须测试会不会解析除了<code>.</code>以外的命令，其次就是考虑类似于<code>. .</code>是否会解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="built_in">TEST</span>(State, DataStartStateTransitive) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;shejialuo@gmail.com&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;DATA&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;..&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;.&quot;</span>, <span class="string">&quot;.&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;.&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;State&gt; *&gt;&gt; expects&#123;</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;354 &quot;</span> + codeToMessages[<span class="string">&quot;354&quot;</span>], &amp;States::dataStartState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::dataDoneState&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tests.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;DataStartState&gt;();</span><br><span class="line">    std::unique_ptr&lt;State&gt; *current = &amp;States::dataStartState;</span><br><span class="line">    std::string result = state-&gt;<span class="built_in">transitive</span>(tests[i], current);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(result, expects[i].first);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(current, expects[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>DataDoneState</code> 由状态图可以观察出来，实际上其与<code>EhloState</code>是一致的，之所以用两个状态进行区分，是为了方便读者的理解。故这部分就不赘述了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line">DataDoneState::<span class="built_in">DataDoneState</span>() &#123; allowed.<span class="built_in">insert</span>(<span class="string">&quot;MAIL&quot;</span>); &#125;</span><br><span class="line"><span class="function">std::string <span class="title">DataDoneState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">transitiveHelper</span>(parameters, current); result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;MAIL&quot;</span>) &#123;</span><br><span class="line">    current = &amp;States::mailState;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = &amp;States::ehloState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以编译代码并执行测试。如果你的代码有问题你可以执行如下的命令切换到现在的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; make -j12 &amp;&amp; ctest --output-on-failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional</span></span><br><span class="line">git checkout finished-states</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你应该能够发现，这一节反而是简单的一节。我们所做的绝大多数工作都是重复。其实最重要的过程一直在我们是如何抽象出<code>State</code>这个虚基类的。希望读者阅读到这儿能够有所启发，理解到良好的架构对于代码的整洁和拓展性拥有很大的作用。</p>]]></content>
      
      
      <categories>
          
          <category> 手把手教你写一个简单的SMTP服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你写一个简单的SMTP服务器（三）</title>
      <link href="/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://luolibrary.com/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/">手把手教你写一个简单的SMTP服务器（一）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">手把手教你写一个简单的SMTP服务器（二）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/">手把手教你写一个简单的SMTP服务器（三）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/">手把手教你写一个简单的SMTP服务器（四）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/">手把手教你写一个简单的SMTP服务器（五）</a></li></ul><hr><p>在教程二中我们已经完成了最重要的工作，构建了最基本的虚基类<code>State</code>。回顾在教程二中我们对于状态的定义，我们拟定义如下6个类来表征状态机中的状态：</p><ol><li><code>IdleState</code></li><li><code>EhloState</code></li><li><code>MailState</code></li><li><code>RcptState</code></li><li><code>DataStartState</code></li><li><code>DataDoneState</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IdleState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IdleState</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  ~<span class="built_in">IdleState</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EhloState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EhloState</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  ~<span class="built_in">EhloState</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MailState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MailState</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  ~<span class="built_in">MailState</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RcptState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RcptState</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  ~<span class="built_in">RcptState</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataStartState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DataStartState</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  ~<span class="built_in">DataStartState</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataDoneState</span> : <span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DataDoneState</span>();</span><br><span class="line">  <span class="function">std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  ~<span class="built_in">DataDoneState</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们需要实现其方法，在现在这个阶段，我们当让其做空操作，或者返回默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add implementation for IdleState</span></span><br><span class="line">IdleState::<span class="built_in">IdleState</span>() &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">IdleState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add implementation for EhloState</span></span><br><span class="line">EhloState::<span class="built_in">EhloState</span>() &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">EhloState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add implementation for MailState</span></span><br><span class="line">MailState::<span class="built_in">MailState</span>() &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">MailState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add implementation for RcptState</span></span><br><span class="line">RcptState::<span class="built_in">RcptState</span>() &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">RcptState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add implementation for DataStartState</span></span><br><span class="line">DataStartState::<span class="built_in">DataStartState</span>() &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">DataStartState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> add implementation for DataDoneState</span></span><br><span class="line">DataDoneState::<span class="built_in">DataDoneState</span>() &#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">DataDoneState::transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据教程二中设计，我们可以知道当服务器端收到客户端的命令时，其会调用<code>transitive</code>方法进行状态的转换，一个思路是我们可以使用<code>make_unique</code>方法构造一个完整的新类来表述状态，但是这样不是很高效。为了提高效率，我们应该使用全局的生命周期的变量，因此我们可以构造一个新类<code>States</code>包含指向6个已经存在的类的指针，我们使用<code>unique_ptr</code>管理这些指针，从而避免内存的泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">States</span> &#123;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;State&gt; idleState;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;State&gt; ehloState;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;State&gt; mailState;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;State&gt; rcptState;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;State&gt; dataStartState;</span><br><span class="line">  <span class="type">static</span> std::unique_ptr&lt;State&gt; dataDoneState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line">std::unique_ptr&lt;State&gt; States::idleState = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line">std::unique_ptr&lt;State&gt; States::ehloState = std::<span class="built_in">make_unique</span>&lt;EhloState&gt;();</span><br><span class="line">std::unique_ptr&lt;State&gt; States::mailState = std::<span class="built_in">make_unique</span>&lt;MailState&gt;();</span><br><span class="line">std::unique_ptr&lt;State&gt; States::rcptState = std::<span class="built_in">make_unique</span>&lt;RcptState&gt;();</span><br><span class="line">std::unique_ptr&lt;State&gt; States::dataStartState = std::<span class="built_in">make_unique</span>&lt;DataStartState&gt;();</span><br><span class="line">std::unique_ptr&lt;State&gt; States::dataDoneState = std::<span class="built_in">make_unique</span>&lt;DataDoneState&gt;();</span><br></pre></td></tr></table></figure><p>完成了这一步，我们就可以修改<code>State</code>类的<code>transitiveFromQuit</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::string <span class="title">State::transitiveFromQuit</span><span class="params">(std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  current = &amp;States::idleState;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;221&quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们完成了我们的状态机的雏形。同时你也可以通过执行命令<code>git checkout all-states</code>获得上面的代码。</p><h2 id="IdleState"><a href="#IdleState" class="headerlink" title="IdleState"></a>IdleState</h2><p>当状态机一启动时，其应该位于<code>IdleState</code>状态，其能够接收4个命令：<code>RSET</code>，<code>NOOP</code>，<code>QUIT</code>以及<code>EHLO</code>命令。其中<code>NOOP</code>和<code>QUIT</code>已经统一处理了，我们并不需要关心。在后面的状态中，我们会忽略这两个命令。对于<code>RSET</code>命令来说，其在这个状态没有任何的作用（严格来说，不是没有作用，而是从<code>IdleState</code>转化为<code>IdleState</code>）。对于<code>EHLO</code>命令来说，其应该从<code>IdleState</code>状态转化为<code>EhloState</code>。在完成这个工作之前，我们首先使用ABNF范式定义<code>RSET</code>等命令的请求和响应，为了简单起见，本教程直接设置了一个静态的”127.0.0.1”。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rset-request</span> <span class="operator">=</span> <span class="string">&quot;RSET&quot;</span> <span class="keyword">CRLF</span></span><br><span class="line"><span class="attribute">rset-ok-response</span> <span class="operator">=</span> <span class="string">&quot;250&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Requested mail action okay, completed&quot;</span> <span class="keyword">CRLF</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">noop-request</span> <span class="operator">=</span> <span class="string">&quot;NOOP&quot;</span> <span class="keyword">CRLF</span></span><br><span class="line"><span class="attribute">noop-ok-response</span> <span class="operator">=</span> <span class="string">&quot;250&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Requested mail action okay, completed&quot;</span> <span class="keyword">CRLF</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">quit-request</span> <span class="operator">=</span> <span class="string">&quot;QUIT&quot;</span> <span class="keyword">CRLF</span></span><br><span class="line"><span class="attribute">quit-ok-response</span> <span class="operator">=</span> <span class="string">&quot;221&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Service closing transmission channel&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">ehlo-request</span> <span class="operator">=</span> <span class="string">&quot;EHLO&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;127.0.0.1&quot;</span> <span class="keyword">CRLF</span></span><br><span class="line"><span class="attribute">ehlo-ok-response</span> <span class="operator">=</span> <span class="string">&quot;250&quot;</span> <span class="keyword">SP</span> <span class="string">&quot;Requested mail action okay, completed&quot;</span> <span class="keyword">CRLF</span></span><br></pre></td></tr></table></figure><p>因此，我们首先更新<code>State</code>基类中的<code>isCorrectParameters</code>方法。其操作很简单，对于<code>NOOP</code>，<code>QUIT</code>和<code>RSET</code>而言，这些命令都不需要任何的参数。而对于<code>EHLO</code>命令，我们直接严格按照ABNF定义即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  std::string &amp;command = parameters[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="string">&quot;NOOP&quot;</span> || command == <span class="string">&quot;QUIT&quot;</span> || command == <span class="string">&quot;RSET&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;EHLO&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">2</span> || parameters[<span class="number">1</span>] != <span class="string">&quot;127.0.0.1&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能觉得这个功能很简单，但是就我个人而言，我认为此处我们应该写一点单元测试保证这个函数的正确性。显然，用cpp写单元测试也是相当的繁琐。首先，你需要在<code>miniSMTPServer/context</code>目录下创建一个新的目录<code>tests</code>。然后在<code>tests</code>目录下添加如下的文件：</p><ul><li><code>CMakeLists.txt</code></li><li><code>stateTest.cpp</code></li></ul><p>对于位于<code>miniSMTPServer/context/tests</code>目录下的<code>CMakeLists.txt</code>，添加如下的代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/context/tests/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(</span><br><span class="line">  stateTest</span><br><span class="line">  stateTest.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(stateTest PRIVATE ../)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">  stateTest</span><br><span class="line">  context</span><br><span class="line">  GTest::gtest_main</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(stateTest)</span><br></pre></td></tr></table></figure><p>然后修改位于<code>miniSMTPServer/context</code>目录下的<code>CMakeLists.txt</code>文件，添加如下的代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/context/CMakeLists.txt</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">add_subdirectory</span>(./tests)</span><br></pre></td></tr></table></figure><p>然后我们就可以开始写单元测试了，我们目前的单元测试主要关心<code>State::isCorrectParameters</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;state.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::unordered_map&lt;std::string, std::string&gt; codeToMessages&#123;</span><br><span class="line">    &#123;<span class="string">&quot;220&quot;</span>, <span class="string">&quot;Service ready&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;221&quot;</span>, <span class="string">&quot;Service closing transmission channel&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;250&quot;</span>, <span class="string">&quot;Requested mail action okay, completed&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;354&quot;</span>, <span class="string">&quot;Start mail input end &lt;CRLF&gt;.&lt;CRLF&gt;&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;500&quot;</span>, <span class="string">&quot;Syntax error, command unrecognized&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;501&quot;</span>, <span class="string">&quot;Syntax error in parameters or arguments&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;503&quot;</span>, <span class="string">&quot;Bad sequence of commands&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(State, isCorrectParametersNOOP) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;param1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;12&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;test : tests) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = state-&gt;<span class="built_in">isCorrectParameters</span>(test);</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(result.<span class="built_in">has_value</span>());</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result.<span class="built_in">value</span>(), <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; successful&#123;<span class="string">&quot;NOOP&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_FALSE</span>(state-&gt;<span class="built_in">isCorrectParameters</span>(successful).<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(State, isCorrectParametersQUIT) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;EHLO&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;14&quot;</span>, <span class="string">&quot;15&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;11111&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;11111&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;test : tests) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = state-&gt;<span class="built_in">isCorrectParameters</span>(test);</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(result.<span class="built_in">has_value</span>());</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result.<span class="built_in">value</span>(), <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; successful&#123;<span class="string">&quot;QUIT&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_FALSE</span>(state-&gt;<span class="built_in">isCorrectParameters</span>(successful).<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(State, isCorrectParametersRSET) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;EHLO&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;14&quot;</span>, <span class="string">&quot;15&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;11111&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;11111&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;test : tests) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = state-&gt;<span class="built_in">isCorrectParameters</span>(test);</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(result.<span class="built_in">has_value</span>());</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result.<span class="built_in">value</span>(), <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; successful&#123;<span class="string">&quot;RSET&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_FALSE</span>(state-&gt;<span class="built_in">isCorrectParameters</span>(successful).<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(State, isCorrectParametersEHLO) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.2&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.1.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;EHLO&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;12&quot;</span>, <span class="string">&quot;13&quot;</span>, <span class="string">&quot;14&quot;</span>, <span class="string">&quot;15&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;11111&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;11111&quot;</span>, <span class="string">&quot;22&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;test : tests) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = state-&gt;<span class="built_in">isCorrectParameters</span>(test);</span><br><span class="line">    <span class="built_in">ASSERT_TRUE</span>(result.<span class="built_in">has_value</span>());</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result.<span class="built_in">value</span>(), <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string&gt; successful&#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ASSERT_FALSE</span>(state-&gt;<span class="built_in">isCorrectParameters</span>(successful).<span class="built_in">has_value</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码提供的单元测试十分简单。不需要进行讲解，从后面开始，我们会以测试驱动来撰写代码，也就是我们先写测试文件再写相应的功能，当我们的代码能够通过测试后也就证明我们的代码是正确的。</p><p>现在我们要开始实现<code>IdleState</code>类中的方法。首先我们应该思考<code>IdleState</code>中允许存在什么命令，由上面的讲述可知，<code>IdleState</code>允许的命令与<code>State</code>中的<code>allowed</code>一致，所以对其构造函数我们可以不做任何的处理，那么关键的地方就在于<code>transitive</code>方法的实现。我们首先实现如下的单元测试的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">TEST</span>(State, IdleStateTransitive) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;State&gt; *&gt;&gt; expects&#123;</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;221 &quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tests.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line">    std::unique_ptr&lt;State&gt; *current = &amp;States::idleState;</span><br><span class="line">    std::string result = state-&gt;<span class="built_in">transitive</span>(tests[<span class="number">0</span>], current);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(result, expects[i].first);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(current, expects[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试的代码很简单，你可以编译然后使用<code>ctest --output-on-failure</code>可以发现很多错误，那么就让我们来更新<code>IdleState::transitive</code>方法，其更新的很简单，首先使用基类的方法<code>transitiveHelper</code>。然后只需要处理<code>EHLO</code>命令即可，因为<code>QUIT</code>和<code>NOOP</code>命令已经在<code>transitiveHelper</code>方法实现了，而<code>RSET</code>方法对于<code>idleState</code>没有任何作用。同时我也添加了许多其他测试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/tests/stateTest.cpp</span></span><br><span class="line"><span class="built_in">TEST</span>(State, IdleStateTransitive) &#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::string&gt;&gt; tests&#123;</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSTE&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOQ&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;NOOP&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;QUIT&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;127.0.1.1&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;DATA&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;State&gt; *&gt;&gt; expects&#123;</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;221 &quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>], &amp;States::ehloState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;500 &quot;</span> + codeToMessages[<span class="string">&quot;500&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;500 &quot;</span> + codeToMessages[<span class="string">&quot;500&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>], &amp;States::idleState&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tests.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> state = std::<span class="built_in">make_unique</span>&lt;IdleState&gt;();</span><br><span class="line">    std::unique_ptr&lt;State&gt; *current = &amp;States::idleState;</span><br><span class="line">    std::string result = state-&gt;<span class="built_in">transitive</span>(tests[i], current);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(result, expects[i].first);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(current, expects[i].second);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再完成了测试代码的编写后，我们开始修改<code>IdleState::transitive</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  std::string &amp;command = parameters[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="string">&quot;NOOP&quot;</span> || command == <span class="string">&quot;QUIT&quot;</span> || command == <span class="string">&quot;RSET&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;EHLO&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameters.<span class="built_in">size</span>() != <span class="number">2</span> || parameters[<span class="number">1</span>] != <span class="string">&quot;127.0.0.1&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;501 &quot;</span> + codeToMessages[<span class="string">&quot;501&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们编译代码运行测试:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; make -j12 &amp;&amp; ctest --output-on-failure</span><br></pre></td></tr></table></figure><p>其结果如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">80% tests passed, 1 tests failed out of 5</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.01 sec</span><br><span class="line"></span><br><span class="line">The following tests FAILED:</span><br><span class="line">          5 - State.IdleStateTransitive (Failed)</span><br><span class="line">Errors while running CTest</span><br></pre></td></tr></table></figure><p>产生这样的结果并不是我们代码的问题，而是由于<code>commands</code>变量的定义在教程二中没有完全定义，因此修改其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="type">static</span> std::unordered_set&lt;std::string&gt; commands&#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;DATA&quot;</span>, <span class="string">&quot;.&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>然后我们重新编译代码运行测试:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build &amp;&amp; make -j12 &amp;&amp; ctest --output-on-failure</span><br></pre></td></tr></table></figure><p>你会发现我们能够通过所有的测试。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节我们主要完善了我们的状态机并实现了第一个状态<code>IdleState</code>的操作，并通过测试驱动的方式写出了我们的代码。在后续的教程中我们将继续完善其他的状态操作。如果你产生了任何的问题，你可以运行如下的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout idle-state</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 手把手教你写一个简单的SMTP服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你写一个简单的SMTP服务器（二）</title>
      <link href="/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://luolibrary.com/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/">手把手教你写一个简单的SMTP服务器（一）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">手把手教你写一个简单的SMTP服务器（二）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/">手把手教你写一个简单的SMTP服务器（三）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/">手把手教你写一个简单的SMTP服务器（四）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/">手把手教你写一个简单的SMTP服务器（五）</a></li></ul><hr><p>在教程一中，我们已经完成了一个十分简单的TCP服务器。如果你跳过了教程一的某些部分，你可以执行以下的命令获取到在此阶段的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/shejialuo/miniSMTPServer</span><br><span class="line"><span class="built_in">cd</span> miniSMTPServer &amp;&amp; git checkout tcp-server</span><br></pre></td></tr></table></figure><p>我们终于来到了有意思的部分了，我们要开始实现一个简单的SMTP协议。然而，RFC标准定义的SMTP协议过于复杂了，故本教程拟提取出一些核心的东西将其简化。</p><h2 id="顺序定义"><a href="#顺序定义" class="headerlink" title="顺序定义"></a>顺序定义</h2><h3 id="会话启动及客户端初始化"><a href="#会话启动及客户端初始化" class="headerlink" title="会话启动及客户端初始化"></a>会话启动及客户端初始化</h3><p>当客户端连接到服务器时，服务器会发送<code>220</code>代码加上其版本等信息。而客户端会发送<code>EHLO</code>命令，加上客户端的IP地址等自定义信息（在本教程中默认只发送IP地址，其值只能为127.0.0.1）。其过程如下所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S: 200 Service ready</span><br><span class="line">C: EHLO 127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="邮件事务"><a href="#邮件事务" class="headerlink" title="邮件事务"></a>邮件事务</h3><p>邮件的事务总共有三步：事务的开始是通过<code>MAIL</code>命令开始的，<code>MAIL</code>命令需要指定发送人的邮箱。然后是一系列的<code>RCPT</code>命令指定接收人的邮箱。最后是<code>DATA</code>命令指定邮件的内容有哪些，最后以单独的<code>.</code>命令表示内容的结束。</p><h3 id="会话结束"><a href="#会话结束" class="headerlink" title="会话结束"></a>会话结束</h3><p>当客户端向服务器发送<code>QUIT</code>命令时，服务器发送回复就意味着本次SMTP会话的终结。</p><h3 id="命令顺序限制"><a href="#命令顺序限制" class="headerlink" title="命令顺序限制"></a>命令顺序限制</h3><ul><li>必须使用<code>EHLO</code>命令开启一个新的会话。</li><li><code>EHLO</code>命令可以在任何一个状态使用，其的使用将会清楚SMTP服务器所有的状态，其存储的发送人、收件人和邮件内容等缓存必须全部清空，该效果等同于客户端发送<code>RSET</code>命令一样。</li><li><code>RSET</code>命令可以在任意阶段使用，哪怕没有收到客户端发送的<code>EHLO</code>命令。</li><li><code>MAIL</code>命令开启一个新的邮件事务，其后面只能按照顺序依次接多个<code>RCPT</code>命令，然后是多个<code>DATA</code>命令。客户端可以通过<code>RSET</code>和<code>EHLO</code>命令重置本次邮件事务。当开启了一个新的邮件事务，<code>MAIL</code>命令就再也无法使用。在这个过程中，如果命令的参数不正确，服务器端必须发送<code>501</code>代码，且服务器维持的状态不能有任何的改变。如果命令顺序不对，服务器端就发送<code>503</code>代码。</li><li>会话里面最后的一个命令必须是<code>QUIT</code>。</li></ul><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>为了简单起见，我们首先定义如下的全局规则：客户端的每次请求必须恰好对应一次服务器的响应。除第一次的客户端请求外，客户端都必须在收到服务器对其上一次请求的响应后才能进行下一次的请求。</p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>我们只支持如下的6个请求，下面的请求有些需要使用参数，有些不需要使用参数，我们会在实现具体的命令功能时再进行详细的介绍，现在我们先从整体的角度出发：</p><ul><li><code>EHLO</code>：客户端请求开始会话。</li><li><code>MAIL</code>：客户端开始邮件事务。</li><li><code>RCPT</code>：指定收件人。</li><li><code>RSET</code>：重置会话。</li><li><code>NOOP</code>：空操作。</li><li><code>QUIT</code>：结束会话。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>对于返回值，我们给出如下的定义：</p><ul><li><code>220</code>: Service ready</li><li><code>221</code>: Service closing transmission channel</li><li><code>250</code>: Requested mail action okay, completed</li><li><code>354</code>: Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</li><li><code>500</code>: Syntax error, command unrecognized</li><li><code>501</code>: Syntax error in parameters or arguments</li><li><code>503</code>: Bad sequence of commands</li></ul><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>经过上述对协议规则的详细解释，我们可以作出下图所示的状态转换图。当客户端输入的命令与该状态转换图对应不上时，服务器端需要输出<code>503</code>错误代码。</p><pre class="mermaid">stateDiagram-v2    [*] --> idle: server start    idle --> ehlo: EHLO    idle --> idle: RSET    ehlo --> mail: MAIL    mail --> rcpt: RCPT    rcpt --> rcpt: RCPT    rcpt --> dataStart: DATA    dataStart --> dataStart : except .    dataStart --> dataDone: .    ehlo --> ehlo: RSET, EHLO    mail --> ehlo: RSET, EHLO    rcpt --> ehlo: RSET, EHLO    dataStart --> ehlo: RSET, EHLO    dataDone --> ehlo: RSET, EHLO    dataDone --> mail: MAIL    idle --> [*]: QUIT    ehlo --> [*]: QUIT    mail --> [*]: QUIT    rcpt --> [*]: QUIT    dataStart --> [*]: QUIT    dataDone --> [*]: QUIT</pre><p>由上图可知，我们根据规则设定了六个状态：<code>idle</code>, <code>ehlo</code>, <code>mail</code>, <code>rcpt</code>, <code>dataStart</code>和<code>dataDone</code>。在上述的状态图中，我们忽略了唯一一个命令<code>NOOP</code>，由于<code>NOOP</code>没有操作，就没有在图里面展示出来了。</p><h2 id="代码实现状态机"><a href="#代码实现状态机" class="headerlink" title="代码实现状态机"></a>代码实现状态机</h2><p>我们该如何通过代码实现上述的状态机了，有一个最简单的方式，就是定义一个<code>enum class State</code>包含状态机的6种状态，然后服务器端根据接收到的命令和目前现在维护的状态，判断是否应该前往下一步，其示例代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">State</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (state == State::idle &amp;&amp; command == <span class="string">&quot;ehlo&quot;</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == State::rcpt &amp;&amp; command == <span class="string">&quot;quit&quot;</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码是实现状态机最简单的方式，但是却是最不好的方式，原因如下：</p><ol><li>缺乏扩展性。如果我们的状态机新增了一个状态，我们需要不断地增加分支。</li><li>不断增加的分支会让代码的可读性下降。</li></ol><p>本教程拟采用c++运行时绑定机制（多态）来实现状态机，其基本的思路在于创建一个<code>Context</code>类，该<code>Context</code>类包含一个指向<code>State</code>类的指针，每当服务器收到了客户端发送的请求后，<code>Context</code>类将会执行<code>State</code>类的某个方法，根据该方法判断能否移动状态，进而处理客户端发送的请求。</p><p>因此我们需要定义虚基类<code>State</code>，此处我们必须尽最大可能抽象出基类应该所具备的能力。尽可能让代码变得干净一些。</p><ul><li><p>首先，我们在<code>miniSMTPServer/context/state.hpp</code>定义两个静态变量，其中一个为<code>commands</code>，表示所有能够接收的命令。其次是<code>codeToMessages</code>表明映射关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="type">static</span> std::unordered_set&lt;std::string&gt; commands&#123;<span class="string">&quot;EHLO&quot;</span>, <span class="string">&quot;MAIL&quot;</span>, <span class="string">&quot;RCPT&quot;</span>, <span class="string">&quot;RSET&quot;</span>, <span class="string">&quot;NOOP&quot;</span>, <span class="string">&quot;QUIT&quot;</span>, <span class="string">&quot;DATA&quot;</span>, <span class="string">&quot;.&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::unordered_map&lt;std::string, std::string&gt; codeToMessages&#123;</span><br><span class="line">    &#123;<span class="string">&quot;220&quot;</span>, <span class="string">&quot;Service ready&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;221&quot;</span>, <span class="string">&quot;Service closing transmission channel&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;250&quot;</span>, <span class="string">&quot;Requested mail action okay, completed&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;354&quot;</span>, <span class="string">&quot;Start mail input end &lt;CRLF&gt;.&lt;CRLF&gt;&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;500&quot;</span>, <span class="string">&quot;Syntax error, command unrecognized&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;501&quot;</span>, <span class="string">&quot;Syntax error in parameters or arguments&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;503&quot;</span>, <span class="string">&quot;Bad sequence of commands&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>其次，对于所有的类都应该根据其自身现有的状态去判断是否应该接收当前的客户端命令。故每一个状态需要维护一个<code>allowed</code>的变量，存储当前状态允许接收的命令。显然，<code>allowed</code>变量需要具备快速查找能力，故使用<code>unordered_set</code>容器。同时，在<code>State</code>类中我们应该定义一个函数<code>canTransitive</code>用于实现该功能。在虚基类中，我们应该添加<code>RSET</code>，<code>EHLO</code>，<code>NOOP</code>，<code>QUIT</code>命令。无论服务器端处于什么样的状态，其都应该支持这些命令。对于客户端的命令，我们将其抽象为<code>std::vector&lt;std::string&gt;</code>。同时我们将该操作封装到<code>checkCommand</code>函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief allowed operations for each state, it should be used in</span></span><br><span class="line"><span class="comment">  * derive class, so make it protected.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  std::unordered_set&lt;std::string&gt; allowed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief Construct a new State object. It will initialize the `allowed`</span></span><br><span class="line"><span class="comment">  * for adding four commands.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">State</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief can transitive to another state</span></span><br><span class="line"><span class="comment">  * @details check whether parameters[0] is in the allowed</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param parameters the command and its parameters</span></span><br><span class="line"><span class="comment">  * @return true the command is OK for transition</span></span><br><span class="line"><span class="comment">  * @return false the command is not OK for transition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canTransitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief check the command whether it is in the command</span></span><br><span class="line"><span class="comment">  * and call `canTransitive`.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param parameters</span></span><br><span class="line"><span class="comment">  * @return std::optional&lt;std::string&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">std::optional&lt;std::string&gt; <span class="title">checkCommand</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line">State::<span class="built_in">State</span>() &#123;</span><br><span class="line">  allowed.<span class="built_in">insert</span>(<span class="string">&quot;RSET&quot;</span>);</span><br><span class="line">  allowed.<span class="built_in">insert</span>(<span class="string">&quot;EHLO&quot;</span>);</span><br><span class="line">  allowed.<span class="built_in">insert</span>(<span class="string">&quot;QUIT&quot;</span>);</span><br><span class="line">  allowed.<span class="built_in">insert</span>(<span class="string">&quot;NOOP&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">State::canTransitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123; <span class="keyword">return</span> allowed.<span class="built_in">count</span>(parameters[<span class="number">0</span>]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::checkCommand</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!commands.<span class="built_in">count</span>(parameters[<span class="number">0</span>])) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;500 &quot;</span> + codeToMessages[<span class="string">&quot;500&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">canTransitive</span>(parameters)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;503 &quot;</span> + codeToMessages[<span class="string">&quot;503&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当服务器端收到命令时，其处理的逻辑如下：首先需要判断客户端的命令是否存在于<code>commands</code>中，然后判断在该状态下是否能够接收该命令，即在上述定义的<code>checkCommand</code>函数的作用，最后需要判断参数是否正确。观察可发现，前三者在所有的状态中都是共通的，故我们需要直接在基类定义这些函数，我们已经定义好了<code>checkCommand</code>函数，因此需要再定义<code>isCorrectParameters</code>用于判断当前的参数是否正确。在目前，我们对此不做任何的处理，只让其返回空值。我们会慢慢地完善这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief is the parameters are correct</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param[in] parameters the command and its parameters</span></span><br><span class="line"><span class="comment">  * @return std::optional&lt;std::string&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">std::optional&lt;std::string&gt; <span class="title">isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::isCorrectParameters</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> finish later</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后我们定义纯虚函数 <code>transitive</code>，用于表征状态转换过程应该实现的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief transitive to another state and return the response string.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param[in] parameters the command and its parameters</span></span><br><span class="line"><span class="comment">  * @param[out] current the current state</span></span><br><span class="line"><span class="comment">  * @return std::string the results should be sent back to the client</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">transitive</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>似乎现在我们已经尽可能地抽象出来了基类，但是我们还可以继续进一步地抽象，注意到<code>QUIT</code>和<code>NOOP</code>命令，对于任何状态来说，这个两个命令都是有确定的效果的。故我们直接可以在基类就直接处理。但是注意<code>QUIT</code>命令需要进行状态的转换，而我们现在却仅定义了一个虚基类，所以这部分我们将留在后面处理。同时，我们定义<code>transitiveHelper</code>函数抽象出所有状态都需要处理的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief QUIT command handle</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @param[in] current the current state</span></span><br><span class="line"><span class="comment">  * @return std::string the response code</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">std::string <span class="title">transitiveFromQuit</span><span class="params">(std::unique_ptr&lt;State&gt; *&amp;current)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief NOOP command handle</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @return std::string the response code</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">std::string <span class="title">transitiveFromNoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief The operations all the states need to do</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function">std::optional&lt;std::string&gt; <span class="title">transitiveHelper</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters, std::unique_ptr&lt;State&gt; *&amp;current)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.cpp</span></span><br><span class="line"><span class="function">std::string <span class="title">State::transitiveFromQuit</span><span class="params">(std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> add transition later</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;221 &quot;</span> + codeToMessages[<span class="string">&quot;221&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">State::transitiveFromNoop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;250 &quot;</span> + codeToMessages[<span class="string">&quot;250&quot;</span>]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">State::transitiveHelper</span><span class="params">(std::vector&lt;std::string&gt; &amp;parameters,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  std::unique_ptr&lt;State&gt; *&amp;current)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">checkCommand</span>(parameters); result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> result = <span class="built_in">isCorrectParameters</span>(parameters); result.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;QUIT&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">transitiveFromQuit</span>(current);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parameters[<span class="number">0</span>] == <span class="string">&quot;NOOP&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">transitiveFromNoop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>别忘记了将析构函数设置为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/context/state.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">State</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>最后别忘记了在再<code>miniSMTPServer/context</code>目录下创建<code>CMakeLists.txt</code>，同时修改<code>miniSMTPServer</code>中的<code>CMakeLists.txt</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/context/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(context STATIC state.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># miniSMTPServer/CMakeLists.txt</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">add_subdirectory</span>(./context)</span><br></pre></td></tr></table></figure><p>然后你就可以再次执行命令进行编译，如果你遇到了任何编译的问题，你可以先使用<code>git add . &amp;&amp; git stash</code>命令暂存你现在的工作区然后执行<code>git checkout state-class</code>发现你的错误。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在我看来，我们已经完成了最难部分的工作。看似我们的代码很少，但是我们已经抽象出了状态图并构建了最基本的代码结构，剩下的工作我们只需要定义每一个状态即可，根据每个状态实现相应的函数即可。</p>]]></content>
      
      
      <categories>
          
          <category> 手把手教你写一个简单的SMTP服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你写一个简单的SMTP服务器（一）</title>
      <link href="/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://luolibrary.com/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/">手把手教你写一个简单的SMTP服务器（一）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">手把手教你写一个简单的SMTP服务器（二）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/">手把手教你写一个简单的SMTP服务器（三）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E5%9B%9B%EF%BC%89/">手把手教你写一个简单的SMTP服务器（四）</a></li><li><a href="https://luolibrary.com/2023/03/14/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%BA%94%EF%BC%89/">手把手教你写一个简单的SMTP服务器（五）</a></li></ul><hr><p>本系列的教程拟使用现代C++一步一步地实现一个简单的SMTP服务器，其主要目的在于国内目前计算机网络教学多是针对于协议本身的教学而忽略了实践。<a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">Simple Mail Transfer Protocol (SMTP)</a>是应用层中较为简单的协议，十分适合用来进行实践。在这里，借用费曼的话：</p><blockquote><p>What I cannot create, I do not understand.</p></blockquote><p>然而，完整的SMTP协议也是相当繁琐的。故本教程会对完整的SMTP协议进行简化，并假设SMTP服务器运行在本地的环境，不需要扩展以支持通过Internet的TCP连接进而能用在现实世界中。服务器所有的通信都应包含在本地回环（local loopback）中。</p><p>在开始之前，你应该对SMTP协议有一些基本的了解，并对C++的现代特性有所了解，如果你对此没有把握，你可以参考互联网的资料进行学习。</p><h2 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h2><p>为了让教程聚焦于核心的部分，本教程做出了以下的前提条件：</p><ul><li>SMTP服务器仅只需要运行在本地，所有的通信都应包含在本地回环中。</li><li>对于每一次客户端的请求，SMTP服务器仅只产生一个响应。且只有客户端接收了服务器的相应，才能够再次发送请求。</li><li>SMTP服务器仅支持以下的命令：<ul><li><code>EHLO</code></li><li><code>MAIL</code></li><li><code>RCPT</code></li><li><code>DATA</code></li><li><code>RSET</code></li><li><code>NOOP</code></li><li><code>QUIT</code></li></ul></li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">扩充巴科斯范式（ABNF）</a>：本教程将采用ABNF来定义通信的协议。其思路很容易理解，读者可参考链接有一个初步的认识。</li><li>Socket网络编程基础：本教程拟在Linux环境下实现，读者需掌握Socket的基本使用。</li></ul><h2 id="初始代码"><a href="#初始代码" class="headerlink" title="初始代码"></a>初始代码</h2><p>不幸的是，<code>cpp</code>的编译构建系统远不如其他语言方便，为了减少读者的心智负担，本教程提供了最初的代码。读者可以通过以下的命令下载初始代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/shejialuo/miniSMTPServer</span><br><span class="line"></span><br><span class="line">git checkout start-code</span><br></pre></td></tr></table></figure><p>用你最喜欢的编辑器或者IDE打开，你应该看到如下的目录结构：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── miniSMTPServer</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── miniSMTPServer.cpp</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>然后你可以执行如下的命令进行编译并生成可执行文件（在这个过程中，你需要使用代理下载第三方库）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build &amp;&amp; cmake .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure><p>当你执行完后，你会在主目录下看到生成了一个名为<code>miniSMTP</code>的可执行文件。在终端运行<code>./miniSMTP</code>，产生如下的结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, This is a simple SMTP server</span><br></pre></td></tr></table></figure><h2 id="封装TCP-Server"><a href="#封装TCP-Server" class="headerlink" title="封装TCP Server"></a>封装TCP Server</h2><p>实际上，本教程可以直接通过<code>socket</code>编程进行实现，然而这样的实现过于地丑陋。故本教程拟对TCP Server进行一个简单地封装。其核心的内容的思路来源于<a href="https://github.com/CS144/sponge">CS144</a>，如果你对此部分不感兴趣或者感到困难的话，可以直接跳过本部分，毕竟此处不是教程的重点。</p><h3 id="封装系统调用"><a href="#封装系统调用" class="headerlink" title="封装系统调用"></a>封装系统调用</h3><p>首先我们在<code>miniSMTPServer</code>目录下创建一个名为<code>util</code>的目录，然后在<code>util</code>目录下创建<code>util.hpp</code>，<code>util.cpp</code>和<code>CMakeLists.txt</code>。 我们只需要实现一个功能，就是封装系统调用，并提供相应的错误检测机制。其实现逻辑十分简单，此处不赘述。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/util/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(util STATIC util.cpp)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/util/util.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief std::system_error plus the name of what was being</span></span><br><span class="line"><span class="comment"> * attempted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tagged_error</span> :</span> public <span class="built_in">std</span>::system_error &#123;</span><br><span class="line">private:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> attempt_and_error;  <span class="comment">//!&lt; what was attempted, and what happened</span></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Construct from a category, an attempt, and an error code.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param[in] category is the category of error</span></span><br><span class="line"><span class="comment">   * @param[in] attempt is what was supposed to happen</span></span><br><span class="line"><span class="comment">   * @param[in] error_code is the resulting error</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  tagged_error(<span class="type">const</span> <span class="built_in">std</span>::error_category &amp;category, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;attempt, <span class="type">const</span> <span class="type">int</span> error_code)</span><br><span class="line">      : <span class="built_in">std</span>::system_error&#123;error_code, category&#125;, attempt_and_error&#123;attempt + <span class="string">&quot;: &quot;</span> + <span class="built_in">std</span>::system_error::what()&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief Returns a C string describing the error</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *<span class="title function_">what</span><span class="params">()</span> <span class="type">const</span> noexcept override &#123; <span class="keyword">return</span> attempt_and_error.c_str(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief A tagged_error for syscalls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unix_error</span> :</span> public tagged_error &#123;</span><br><span class="line">public:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief  Construct from a syscall name and the resulting errno</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param[in] attempt is the name of the syscall attempted</span></span><br><span class="line"><span class="comment">   * @param[in] error is the [errno(3)](\ref man3::errno) that resulted</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  explicit <span class="title function_">unix_error</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;attempt, <span class="type">const</span> <span class="type">int</span> error = errno)</span></span><br><span class="line">      : tagged_error&#123;<span class="built_in">std</span>::system_category(), attempt, error&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Error-checking wrapper for most syscalls</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SystemCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask = <span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Version of SystemCall that takes a C++ std::string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SystemCall</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask = <span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/util/util.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SystemCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (return_value &gt;= <span class="number">0</span> || errno == errno_mask) &#123;</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  throw unix_error(attempt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SystemCall</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> SystemCall(attempt.c_str(), return_value, errno_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，需要在<code>miniSMTPServer</code>的<code>CMakeLists.txt</code>的末尾添加如下的语句：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/CMakeLists.txt</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">add_subdirectory</span>(./util)</span><br></pre></td></tr></table></figure><p>你也可以直接使用如下的命令获取到本小节的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout system-call</span><br></pre></td></tr></table></figure><h3 id="封装TCPSocket"><a href="#封装TCPSocket" class="headerlink" title="封装TCPSocket"></a>封装TCPSocket</h3><p>如何封装一个<code>TCPSocket</code>呢？我们可以分为一下三步走：</p><ol><li>封装文件描述符类<code>FileDescriptor</code></li><li>封装地址类<code>Address</code>。</li><li>继承<code>FileDescriptor</code>得到<code>TCPSocket</code>。</li></ol><p>首先我们在<code>util</code>目录下创建<code>socket.hpp</code>和<code>socket.cpp</code>，并修改<code>CMakeLists.txt</code>将<code>socket.cpp</code>加入编译单元中。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># miniSMTPServer/util/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(util STATIC util.cpp socket.cpp)</span><br></pre></td></tr></table></figure><p>首先，我们需要构造一个<code>FileDescriptor</code>类，实际上对于该类的封装的思路可以很简单，也可以很复杂，如果我们不考虑其复制等生命周期问题，我们完全可以直接使用一个<code>int</code>类型的变量然后添加一些操作文件描述符的方法。在此处，我们采用更为复杂的设计模式：</p><ol><li><code>FileDescriptor</code>包含一个私有的<code>FDWrapper</code>，其包含了真正的文件描述符的信息。<code>FDWrapper</code>不能被复制也不能被移动。</li><li>由于<code>FDWrapper</code>不能被复制也不能被移动，故<code>FileDescriptor</code>包含变量<code>internal_fd</code>的智能指针，表示<code>FDWrapper</code>被引用的数量，通过<code>shared_ptr</code>表示<code>FDWrapper</code>的生命周期。</li></ol><p>于是，我们就可以给出如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/util/socket.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief  A handle on a kernel file descriptor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @details FileDescriptor objects contain a std::shared_ptr to a FDWrapper.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">FDWrapper</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> fd;               <span class="comment">//!&lt; The file descriptor number returned by the kernel</span></span><br><span class="line">    <span class="type">bool</span> eof = <span class="literal">false</span>;     <span class="comment">//!&lt; Flag indicating whether FDWrapper::_fd is at EOF</span></span><br><span class="line">    <span class="type">bool</span> closed = <span class="literal">false</span>;  <span class="comment">//!&lt; Flag indicating whether FDWrapper::_fd has been closed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct from a file descriptor number returned by the kernel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FDWrapper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Closes the file descriptor upon destruction</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~<span class="built_in">FDWrapper</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Calls [close(2)](\ref man2::close) on FDWrapper::fd</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FDWrapper</span>(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    FDWrapper &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">FDWrapper</span>(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    FDWrapper &amp;<span class="keyword">operator</span>=(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! A reference-counted handle to a shared FDWrapper</span></span><br><span class="line">  std::shared_ptr&lt;FDWrapper&gt; internal_fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// private constructor used to duplicate the FileDescriptor (increase the reference count)</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(std::shared_ptr&lt;FDWrapper&gt; other_shared_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//! Construct from a file descriptor number returned by the kernel</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Free the std::shared_ptr; the FDWrapper destructor calls close() when the refcount goes to zero.</span></span><br><span class="line">  ~<span class="built_in">FileDescriptor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Read up to `limit` bytes</span></span><br><span class="line">  <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Read up to `limit` bytes into `str` (caller can allocate storage)</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(std::string &amp;str, <span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Write a string, possibly blocking until all is written</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Write a string, possibly blocking until all is written</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Close the underlying file descriptor</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; internal_fd-&gt;<span class="built_in">close</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Copy a FileDescriptor explicitly, increasing the FDWrapper refcount</span></span><br><span class="line">  <span class="function">FileDescriptor <span class="title">duplicate</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">fd_num</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> internal_fd-&gt;fd; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> internal_fd-&gt;eof; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">closed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> internal_fd-&gt;closed; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FileDescriptor</span>(<span class="type">const</span> FileDescriptor &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  FileDescriptor &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FileDescriptor &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">FileDescriptor</span>(FileDescriptor &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">  FileDescriptor &amp;<span class="keyword">operator</span>=(FileDescriptor &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/util/socket.cpp</span></span><br><span class="line">FileDescriptor::FDWrapper::<span class="built_in">FDWrapper</span>(<span class="type">const</span> <span class="type">int</span> f) : fd&#123;f&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid fd number:&quot;</span> + std::<span class="built_in">to_string</span>(fd));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> FileDescriptor::FDWrapper::<span class="built_in">close</span>() &#123;</span><br><span class="line">  <span class="built_in">SystemCall</span>(<span class="string">&quot;close&quot;</span>, ::<span class="built_in">close</span>(fd));</span><br><span class="line">  eof = closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileDescriptor::FDWrapper::~<span class="built_in">FDWrapper</span>() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception destructing FileWrapper: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileDescriptor::<span class="built_in">FileDescriptor</span>(<span class="type">const</span> <span class="type">int</span> fd) : internal_fd&#123;std::<span class="built_in">make_shared</span>&lt;FDWrapper&gt;(fd)&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">FileDescriptor::<span class="built_in">FileDescriptor</span>(std::shared_ptr&lt;FDWrapper&gt; other) : internal_fd&#123;std::<span class="built_in">move</span>(other)&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FileDescriptor <span class="title">FileDescriptor::duplicate</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">FileDescriptor</span>(internal_fd); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileDescriptor::read</span><span class="params">(std::string &amp;str, <span class="type">const</span> <span class="type">size_t</span> limit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> BUFFER_SIZE = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> size_to_read = std::<span class="built_in">min</span>(BUFFER_SIZE, limit);</span><br><span class="line">  str.<span class="built_in">resize</span>(size_to_read);</span><br><span class="line"></span><br><span class="line">  <span class="type">ssize_t</span> bytes_read = <span class="built_in">SystemCall</span>(<span class="string">&quot;read&quot;</span>, ::<span class="built_in">read</span>(<span class="built_in">fd_num</span>(), str.<span class="built_in">data</span>(), size_to_read));</span><br><span class="line">  <span class="keyword">if</span> (limit &gt; <span class="number">0</span> &amp;&amp; bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">    internal_fd-&gt;eof = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bytes_read &gt; <span class="built_in">static_cast</span>&lt;<span class="type">ssize_t</span>&gt;(size_to_read)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;read() read more than requested&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  str.<span class="built_in">resize</span>(bytes_read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">FileDescriptor::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> limit)</span> </span>&#123;</span><br><span class="line">  std::string ret;</span><br><span class="line">  <span class="built_in">read</span>(ret, limit);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">FileDescriptor::write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_written = <span class="number">0</span>;</span><br><span class="line">  bytes_written = <span class="built_in">SystemCall</span>(<span class="string">&quot;write&quot;</span>, ::<span class="built_in">write</span>(<span class="built_in">fd_num</span>(), str, <span class="built_in">strlen</span>(str)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bytes_written == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(str) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;write() returned 0 given non-empty input&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bytes_written &gt; <span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;write() wrote more than requested&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bytes_written;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">FileDescriptor::write</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">write</span>(str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><p>如果为了更好的扩展性，我们应该去新建一个<code>Address</code>类表示地址，但是此处我偷懒了，因为我们的重心并不在此处。<code>TCPSocket</code>的操作就比较简单了，只需要在<code>FileDescriptor</code>的基础上，增加以下的方法：</p><ul><li><code>bind</code></li><li><code>listen</code></li><li><code>accept</code></li><li><code>set_reuseaddr</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/util/socket.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSocket</span> : <span class="keyword">public</span> FileDescriptor &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//! Construct via [socket(2)](\ref man2::socket)</span></span><br><span class="line">  <span class="built_in">TCPSocket</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">TCPSocket</span><span class="params">(FileDescriptor &amp;&amp;fd)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Wrapper around [setsockopt(2)](\ref man2::setsockopt)</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Bind a socket to a specified address with [bind(2)](\ref man2::bind), usually for listen/accept</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> port = <span class="number">9400</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Mark a socket as listening for incoming connections</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> backlog = <span class="number">16</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Accept a new incoming connection</span></span><br><span class="line">  <span class="function">TCPSocket <span class="title">accept</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//! Allow local address to be reused sooner via [SO_REUSEADDR](\ref man7::socket)</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_reuseaddr</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// miniSMTPServer/util/socket.cpp</span></span><br><span class="line">TCPSocket::<span class="built_in">TCPSocket</span>() : FileDescriptor&#123;<span class="built_in">SystemCall</span>(<span class="string">&quot;socket&quot;</span>, ::<span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>))&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">TCPSocket::<span class="built_in">TCPSocket</span>(FileDescriptor &amp;&amp;fd) : <span class="built_in">FileDescriptor</span>(std::<span class="built_in">move</span>(fd)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> option_type&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSocket::setsockopt</span><span class="params">(<span class="type">const</span> <span class="type">int</span> level, <span class="type">const</span> <span class="type">int</span> option, <span class="type">const</span> option_type &amp;option_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SystemCall</span>(<span class="string">&quot;setsockopt&quot;</span>, ::<span class="built_in">setsockopt</span>(<span class="built_in">fd_num</span>(), level, option, &amp;option_value, <span class="built_in">sizeof</span>(option_value)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSocket::set_reuseaddr</span><span class="params">()</span> </span>&#123; <span class="built_in">setsockopt</span>(SOL_SOCKET, SO_REUSEADDR, <span class="built_in">int</span>(<span class="literal">true</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSocket::bind</span><span class="params">(<span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line"></span><br><span class="line">  address.sin_family = AF_INET;</span><br><span class="line">  address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">  <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;address.sin_addr);</span><br><span class="line">  <span class="built_in">SystemCall</span>(<span class="string">&quot;bind&quot;</span>, ::<span class="built_in">bind</span>(<span class="built_in">fd_num</span>(), (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="built_in">sizeof</span>(address)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSocket::listen</span><span class="params">(<span class="type">const</span> <span class="type">int</span> backlog)</span> </span>&#123; <span class="built_in">SystemCall</span>(<span class="string">&quot;listen&quot;</span>, ::<span class="built_in">listen</span>(<span class="built_in">fd_num</span>(), backlog)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TCPSocket <span class="title">TCPSocket::accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">TCPSocket</span>(<span class="built_in">FileDescriptor</span>(<span class="built_in">SystemCall</span>(<span class="string">&quot;accept&quot;</span>, ::<span class="built_in">accept</span>(<span class="built_in">fd_num</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以直接使用以下的命令得到上述的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tcp-socket</span><br></pre></td></tr></table></figure><p>你可以发现，我们其实绕了一大圈最终也只是为了实现这些命令，但是这些类的建立为我们写代码提供了良好的抽象能力。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在完成了<code>TCPSocket</code>类的实现后，我们就可以开始写一个简单的服务器了，在这个简单的服务器中，我们不使用任何的线程，不使用任何的I&#x2F;O复用，我们就简单地一个一个处理到来的请求。毕竟我们的重点并不在于服务器高性能的实现。</p><p>在<code>miniSMTPServer/miniSMTPServer.cpp</code>中编写如下的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;socket.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, This is a simple SMTP server\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  TCPSocket socket&#123;&#125;;</span><br><span class="line">  socket.<span class="built_in">bind</span>();</span><br><span class="line">  socket.<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line">  std::string result&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> s = socket.<span class="built_in">accept</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      s.<span class="built_in">read</span>(result);</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;S: Connection lost\n&quot;</span>;</span><br><span class="line">        s.<span class="built_in">close</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s.<span class="built_in">write</span>(<span class="string">&quot;Hello, this is the server\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，我们需要修改<code>miniSMTPServer/CMakeLists.txt</code>为其添加相应的头文件和库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(miniSMTP PRIVATE ./util)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(miniSMTP util)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>同样地，你也可以使用下面的命令得到如上所示的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout tcp-server</span><br></pre></td></tr></table></figure><p>编译代码运行<code>./miniSMTP</code>，然后执行命令<code>telnet 127.0.0.1 9400</code>，你应该能够得到如下图所示的执行的结果。</p><p><img src="https://s2.loli.net/2023/03/12/TnurykNBVoLYeXx.png" alt="Simple Server Test Result"></p>]]></content>
      
      
      <categories>
          
          <category> 手把手教你写一个简单的SMTP服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Assignment2 Building A Task Execution Library</title>
      <link href="/2023/02/01/CS149-Assignment2-Building-A-Task-Execution-Library/"/>
      <url>/2023/02/01/CS149-Assignment2-Building-A-Task-Execution-Library/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>First, we should understand the file <code>itasksys.h</code>. It defines two abstract classes <code>IRunable</code> and <code>ITaskSystem</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IRunable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">IRunnable</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">runTask</span><span class="params">(<span class="type">int</span> task_id, <span class="type">int</span> num_total_tasks = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>It is obvious that the user should define the <code>IRunable</code> class. And the <code>runTask</code> is provided by the user. And the core class is <code>ITaskSystem</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ITaskSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ITaskSystem</span>(<span class="type">int</span> num_threads);</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ITaskSystem</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TaskID <span class="title">runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For <code>ITaskSystem::run()</code>, it executes a bulk task launch of <code>num_total_tasks</code>. Task execution is synchronous with the calling thread, so it will return only when the execution of all tasks is complete.</p><p>For <code>ITaskSystem::runAsyncWithDeps</code>, Executes an asynchronous bulk task launch of <code>num_total_tasks</code>, but with a dependency on prior launched tasks.</p><p>In part A, we do not consider about the <code>ITaskSystem::runAsyncWithDeps</code>.</p><h3 id="Serial-Program"><a href="#Serial-Program" class="headerlink" title="Serial Program"></a>Serial Program</h3><p>We first look at class <code>TaskSystemSerial</code>. The function <code>run</code> is defined as follow.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemSerial::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_total_tasks; i++) &#123;</span><br><span class="line">    runnable-&gt;<span class="built_in">runTask</span>(i, num_total_tasks);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>The simplest answer is just to make the <code>run</code> function as the master, and create the threads to do the job. And join the thread at last. (However, I use C++14 for better lambda function).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelSpawn::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> thread_func = [runnable_ = runnable, num = _num_threads, total = num_total_tasks](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; total) &#123;</span><br><span class="line">            runnable_-&gt;<span class="built_in">runTask</span>(i, total);</span><br><span class="line">            i += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::thread threads[_num_threads];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">      threads[i] = std::<span class="built_in">move</span>(std::<span class="built_in">thread</span>(thread_func, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">      threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Well, it is not so easy to write a thread loop. There are so many details we need to deal with. The most important thing here is do remember <code>join</code> all the threads when the class’s lifetime ends.</p><p>It may seem that we need to accept every index to dynamic choose what to do. This is a stupid idea. Remember, we should reduce the size of synchronization. So we use the idea of step 1.</p><p>And you could see the following code for details. First we should add some private members.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _num_threads; <span class="comment">// to store the threads</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads; <span class="comment">// thread poll</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> jobs = <span class="number">0x00</span>; <span class="comment">// bitmap value for indicating whether there is a job</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bitmap_init_value = <span class="number">0x00</span>; <span class="comment">// initialized bitmap value with 0x1111</span></span><br><span class="line">  IRunnable* runnable_; <span class="comment">// we need to record the runnable</span></span><br><span class="line">  std::mutex queue_mutex; <span class="comment">// the big lock</span></span><br><span class="line">  <span class="type">bool</span> terminate = <span class="literal">false</span>; <span class="comment">// Whether we should terminate the thread</span></span><br><span class="line">  <span class="type">int</span> total_tasks = <span class="number">0</span>;    <span class="comment">// we should record the total task</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> num_threads)</span></span>; <span class="comment">// start the thread pool</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">threadLoop</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// thread functionality</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">busy</span><span class="params">()</span></span>; <span class="comment">// whether the threads are busy doing their jobs</span></span><br></pre></td></tr></table></figure><p>For constructor, we need to initialize the <code>bitmap_init_value</code> and start the thread pool.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSpinning::<span class="built_in">TaskSystemParallelThreadPoolSpinning</span>(<span class="type">int</span> num_threads)</span><br><span class="line">  : <span class="built_in">ITaskSystem</span>(num_threads), _num_threads(num_threads) &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> init = <span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">    bitmap_init_value |= init;</span><br><span class="line">    init &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">start</span>(_num_threads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For <code>start</code>, it is easy to understand.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::start</span><span class="params">(<span class="type">int</span> num_threads)</span> </span>&#123;</span><br><span class="line">  threads.<span class="built_in">resize</span>(num_threads);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    threads[i] = std::<span class="built_in">move</span>(std::<span class="built_in">thread</span>(&amp;TaskSystemParallelThreadPoolSpinning::threadLoop, <span class="keyword">this</span>, i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, we come to the most important part. For how to tell whether there is a job for the thread, we use <code>jobs</code> as a bit map. And when the job is finished, we make the corresponding to 0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::threadLoop</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span> &amp;&amp; !terminate) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      std::lock_guard&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">      flag = (jobs &gt;&gt; i) &amp; <span class="number">0x01</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="type">int</span> taskId = i;</span><br><span class="line">      <span class="keyword">while</span>(taskId &lt; total_tasks) &#123;</span><br><span class="line">        runnable_-&gt;<span class="built_in">runTask</span>(taskId, total_tasks);</span><br><span class="line">        taskId += _num_threads;</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">        jobs &amp;= ~(<span class="number">0x01</span> &lt;&lt; i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When the other calls <code>run</code>, it first initialize <code>jobs</code> to <code>bitmap_init_value</code>. And set the corresponding <code>runnable_</code> and the number of tasks. And if the <code>jobs</code> becomes 0, all the threads have competed their jobs. Thus, we can return.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">  total_tasks = num_total_tasks;</span><br><span class="line">  runnable_ = runnable;</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">    jobs = bitmap_init_value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">busy</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Do remember join the threads at the destructor:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSpinning::~<span class="built_in">TaskSystemParallelThreadPoolSpinning</span>() &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Here, we don&#x27;t need to synchronize the code, because</span></span><br><span class="line"><span class="comment">    * the thread will never write `terminate`. No matter</span></span><br><span class="line"><span class="comment">    * the thread may read some corrupted value, this doesn&#x27;t matter.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  terminate = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>In the step 2, we have pushed all the threads and <code>run</code> spin, which is inefficient. So we should make them sleep. The idea here is simple. We just use condition variables to achieve that. It is just consumer and producer problem. So I omit detail here.</p><h3 id="Conclusion-for-Part-A"><a href="#Conclusion-for-Part-A" class="headerlink" title="Conclusion for Part A"></a>Conclusion for Part A</h3><p>I wanna say sometimes spin is better than sleep. Because sleep would cause context switch, which may be inefficient when cpu speed is high.</p><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>For part B, the most interesting thing is how should we solve the dependency.</p><p>When the user calls <code>runAsyncWithDeps</code>, it will pass a bunch of task ids. So there is an important question: how can we find an efficient data structure to represent the dependency.</p><p>For every task, it will have dependencies, so I use <code>unordered_map&lt;TaskID, unordered_set&lt;Task*&gt;&gt;</code> to represent dependencies for the following several reasons:</p><ol><li>We can find the dependencies of a specified task.</li><li>Because the dependencies are represented as <code>unordered_set</code>, it is efficient to insert or delete.</li></ol><p>Because there are different tasks, I define a helper class <code>Task</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TaskID id;</span><br><span class="line">  IRunnable* runnable;</span><br><span class="line">  <span class="type">int</span> processing = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> finished = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> total_tasks;</span><br><span class="line">  <span class="type">size_t</span> dependencies;</span><br><span class="line">  std::mutex task_mutex;</span><br><span class="line">  <span class="built_in">Task</span>(TaskID id_, IRunnable* runnable_, <span class="type">int</span> total_tasks_, <span class="type">size_t</span> deps)</span><br><span class="line">    :<span class="built_in">id</span>(id_), <span class="built_in">runnable</span>(runnable_), <span class="built_in">total_tasks</span>(total_tasks_), <span class="built_in">dependencies</span>(deps) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>As you can see, the <code>processing</code> filed is to indicate the next job for this task we should handle, the <code>finished</code> field is used to indicate how many tasks we have finished. We need to protect the variable, so for each task, there is a <code>mutex</code>.</p><p>If a task’s dependencies (<code>Task::dependencies</code>) are not zero, we should not run this task. So I use the following data structures:</p><ul><li><code>vector&lt;Task*&gt; ready</code>: the tasks which are ready, so we can handle.</li><li><code>unordered_set&lt;Task*&gt; blocked</code>: the tasks which should not run at now.</li></ul><p>The whole idea is when user calls <code>runAsyncWithDeps</code>, we should update the <code>dependency</code> and just sends the task to <code>blocked</code>. And in the thread loop, we first check whether there is a task in the <code>ready</code>. If so, we random choose one task of the <code>ready</code> to handle, if the task is all finished, we should update the <code>dependency</code> again. When all tasks are finished, we should terminate.</p><p>It may sound easy, however the correct implementation is hard.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskSystemParallelThreadPoolSleeping</span>: <span class="keyword">public</span> ITaskSystem &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> terminate = <span class="literal">false</span>; <span class="comment">// To indicate whether to stop the thread pool</span></span><br><span class="line">  <span class="type">int</span> _num_threads = <span class="number">0</span>; <span class="comment">// To indicate how many threads</span></span><br><span class="line">  <span class="type">int</span> sleepThreadNum = <span class="number">0</span>; <span class="comment">// The number of thread which is sleeping</span></span><br><span class="line">  std::unordered_map&lt;TaskID, Task*&gt; finished &#123;&#125;; <span class="comment">// To record the finished task</span></span><br><span class="line">  std::vector&lt;Task*&gt; ready &#123;&#125;; <span class="comment">// The task is ready to be processed</span></span><br><span class="line">  std::unordered_set&lt;Task*&gt; blocked &#123;&#125;; <span class="comment">// The task is blocked</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  std::unordered_map&lt;TaskID, std::unordered_set&lt;Task*&gt;&gt; dependency &#123;&#125;; <span class="comment">// The dependency information</span></span><br><span class="line">  TaskID id = <span class="number">0</span>;</span><br><span class="line">  std::mutex queue_mutex;</span><br><span class="line">  std::condition_variable consumer;</span><br><span class="line">  std::condition_variable producer;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> num_threads)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">threadLoop</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deleteFinishedTask</span><span class="params">(Task* task)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">moveBlockTaskToReady</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signalSync</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskSystemParallelThreadPoolSleeping</span>(<span class="type">int</span> num_threads);</span><br><span class="line">  ~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>();</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span></span>;</span><br><span class="line">  <span class="function">TaskID <span class="title">runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then we first look at <code>runAsyncWithDeps</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For simplicity and easy-handling, we just make the new task to the `blocked`, and record</span></span><br><span class="line"><span class="comment"> * the dependency information and notify all the producers, and immediately return to the</span></span><br><span class="line"><span class="comment"> * user for async operation. And also we make the implementation more easily.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TaskID <span class="title">TaskSystemParallelThreadPoolSleeping::runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span> </span>&#123;</span><br><span class="line">  Task* task = <span class="keyword">new</span> <span class="built_in">Task</span>(id, runnable, num_total_tasks, deps.<span class="built_in">size</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">    <span class="comment">// We just simply add the task to the blocked.</span></span><br><span class="line">    blocked.<span class="built_in">insert</span>(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record dependency information for later processing</span></span><br><span class="line">    <span class="keyword">for</span> (TaskID dep : deps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependency.<span class="built_in">count</span>(dep)) &#123;</span><br><span class="line">        dependency[dep].<span class="built_in">insert</span>(task);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dependency[dep] = std::unordered_set&lt;Task*&gt;&#123;task&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We should notify the producer to continue processing</span></span><br><span class="line">    producer.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The main functionality is in the <code>threadLoop</code> function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::threadLoop</span><span class="params">(<span class="type">int</span> id_)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    Task* task = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">      <span class="keyword">if</span>(ready.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!blocked.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="comment">// We should check to move the blocked to the ready.</span></span><br><span class="line">          <span class="built_in">moveBlockTaskToReady</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If ready is still empty, we should sleep the thread.</span></span><br><span class="line">        <span class="keyword">if</span>(ready.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sleepThreadNum++;</span><br><span class="line">            producer.<span class="built_in">wait</span>(guard);</span><br><span class="line">            sleepThreadNum--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Here, we must tell whether the ready is empty,</span></span><br><span class="line"><span class="comment">        * when ready.size() == 0, rand() % 0 will cause</span></span><br><span class="line"><span class="comment">        * float point exception. It sucks.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span>(!ready.<span class="built_in">empty</span>()) &#123;index = <span class="built_in">rand</span>() % ready.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// Here, we use random to choose the task for each thread</span></span><br><span class="line">        <span class="comment">// for simplicity.</span></span><br><span class="line">        task = ready[index];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(terminate) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> processing = <span class="number">-1</span>, finished = <span class="number">-1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;task-&gt;task_mutex&#125;;</span><br><span class="line">      processing = task-&gt;processing;</span><br><span class="line">      <span class="comment">// There are some situations `processing` will exceed</span></span><br><span class="line">      <span class="comment">// the total number, because we don&#x27;t know when the</span></span><br><span class="line">      <span class="comment">// `deleteFinishedTask` is finished. We may choose the</span></span><br><span class="line">      <span class="comment">// task which is actually finished (or just only one)</span></span><br><span class="line">      <span class="keyword">if</span>(processing &gt;= task-&gt;total_tasks) <span class="keyword">continue</span>;</span><br><span class="line">      task-&gt;processing++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(processing &lt; task-&gt;total_tasks) &#123;</span><br><span class="line">      task-&gt;runnable-&gt;<span class="built_in">runTask</span>(processing, task-&gt;total_tasks);</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;task-&gt;task_mutex&#125;;</span><br><span class="line">      task-&gt;finished++;</span><br><span class="line">      finished = task-&gt;finished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(finished == task-&gt;total_tasks) &#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">      <span class="built_in">deleteFinishedTask</span>(task);</span><br><span class="line">      <span class="comment">// When we signalSync, there are may be some threads which</span></span><br><span class="line">      <span class="comment">// are processing useless. So it may just return to the</span></span><br><span class="line">      <span class="comment">// destructor. So in the destructor we must wait for all</span></span><br><span class="line">      <span class="comment">// the thread going to sleep. And we call `notify_all` to</span></span><br><span class="line">      <span class="comment">// make all the threads stop. The design here should be</span></span><br><span class="line">      <span class="comment">// optimized. However, I don&#x27;t have enough time...</span></span><br><span class="line">      <span class="built_in">signalSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And the other part is some auxiliary functions:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::deleteFinishedTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i &lt; ready.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready[i] == task) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  finished.<span class="built_in">insert</span>(&#123;ready[i]-&gt;id ,ready[i]&#125;);</span><br><span class="line">  ready.<span class="built_in">erase</span>(ready.<span class="built_in">begin</span>() + i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dependency.<span class="built_in">count</span>(task-&gt;id)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t: dependency[task-&gt;id]) &#123;</span><br><span class="line">      t-&gt;dependencies--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Move blocked task to the ready when the task&#x27;s dependency is</span></span><br><span class="line"><span class="comment"> * all finished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::moveBlockTaskToReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Task*&gt; moved &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> task : blocked) &#123;</span><br><span class="line">    <span class="keyword">if</span>(task-&gt;dependencies == <span class="number">0</span>) &#123;</span><br><span class="line">      ready.<span class="built_in">push_back</span>(task);</span><br><span class="line">      moved.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> task: moved) &#123;</span><br><span class="line">    blocked.<span class="built_in">erase</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When all the tasks are finished, which means `ready` and `blocked`</span></span><br><span class="line"><span class="comment"> * are are empty, we could signal the ONLY ONE consumer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::signalSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ready.<span class="built_in">empty</span>() &amp;&amp; blocked.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    consumer.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And for the destructor:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSleeping::~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>() &#123;</span><br><span class="line"></span><br><span class="line">  terminate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It may seem why here we need to use spin to test the sleepThreadNum</span></span><br><span class="line">  <span class="comment">// Because of the design, there may be some threads who is not sleeping at</span></span><br><span class="line">  <span class="comment">// this time, in order to make there is no dead-lock. See the `threadLoop`</span></span><br><span class="line">  <span class="comment">// for more detail.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">    <span class="keyword">if</span>(sleepThreadNum == _num_threads) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We should notify all the threads to return</span></span><br><span class="line">  producer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; i++) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We should free the memory</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> task : finished) &#123;</span><br><span class="line">   <span class="keyword">delete</span> task.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS149 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS149-Assignment1 Performance Analysis on a Quad-Core CPU</title>
      <link href="/2023/01/31/CS149-Assignment1-Performance-Analysis-on-a-Quad-Core-CPU/"/>
      <url>/2023/01/31/CS149-Assignment1-Performance-Analysis-on-a-Quad-Core-CPU/</url>
      
        <content type="html"><![CDATA[<h2 id="Program-1"><a href="#Program-1" class="headerlink" title="Program 1"></a>Program 1</h2><h3 id="Question-1-1"><a href="#Question-1-1" class="headerlink" title="Question 1.1"></a>Question 1.1</h3><p>It’s easy to split the task.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numRows =  args-&gt;height / args-&gt;numThreads;</span><br><span class="line"><span class="type">int</span> remainRows = args-&gt;height % args-&gt;numThreads;</span><br><span class="line"><span class="type">int</span> startRow = args-&gt;threadId * numRows;</span><br><span class="line"><span class="keyword">if</span>(args-&gt;threadId == args-&gt;numThreads - <span class="number">1</span> &amp;&amp; remainRows != <span class="number">0</span>) &#123;</span><br><span class="line">  numRows += remainRows;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mandelbrotSerial</span>(args-&gt;x0, args-&gt;y0, args-&gt;x1, args-&gt;y1,</span><br><span class="line">                 args-&gt;width, args-&gt;height, startRow, numRows,</span><br><span class="line">                 args-&gt;maxIterations ,args-&gt;output);</span><br></pre></td></tr></table></figure><h3 id="Question-1-2"><a href="#Question-1-2" class="headerlink" title="Question 1.2"></a>Question 1.2</h3><p>The data for view 1 is below:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># thread_num # speedup</span><br><span class="line">    1            1</span><br><span class="line">    2            1.99</span><br><span class="line">    3            1.65</span><br><span class="line">    4            2.46</span><br><span class="line">    5            2.50</span><br><span class="line">    6            3.28</span><br><span class="line">    7            3.43</span><br><span class="line">    8            4.07</span><br></pre></td></tr></table></figure><p>And I use gnuplot to plot the figure.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set title &quot;the speedup of the thread for view 1&quot;</span><br><span class="line">set xlabel &quot;thread number&quot;</span><br><span class="line">set ylabel &quot;speedup&quot;</span><br><span class="line">plot &quot;speedup_view1&quot; w lp</span><br><span class="line">set terminal pngcairo</span><br><span class="line">set output &quot;The speedup for view 1.png&quot;</span><br><span class="line">replot</span><br><span class="line">set terminal qt</span><br><span class="line">set output</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/31/xQVlHoSAOEngB5D.png" alt="The speedup for view 1"></p><p>By the way, I also plot the speedup for view 2.</p><p><img src="https://s2.loli.net/2023/01/31/iqCK2vWP3IuYQX5.png" alt="The speedup for view 2"></p><p>As this two picture shows, we can find that the speedup for view 2 is nearly linear but not for view 1. The reason is the imbalance of the data. For view 1, some threads handle more data but some handle little, and we still need to wait for all threads which wastes lots of time.</p><h3 id="Question-1-3"><a href="#Question-1-3" class="headerlink" title="Question 1.3"></a>Question 1.3</h3><p><img src="https://s2.loli.net/2023/01/31/zVNjd87tc91QJRk.png" alt="The imbalance of the workload for view 1"></p><p><img src="https://s2.loli.net/2023/01/31/Ru2kFrZjeo34PDY.png" alt="The imbalance of the workload for view 2"></p><h3 id="Question-1-4"><a href="#Question-1-4" class="headerlink" title="Question 1.4"></a>Question 1.4</h3><p>The most important thing to do is to balance the load. But we don’t know the actual load, so we should make slice for each thread job. Don’t let a thread do a consecutive area. Just handle only one raw.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThreadStartBalance</span><span class="params">(WorkerArgs * <span class="type">const</span> args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> startTime = CycleTimer::<span class="built_in">currentSeconds</span>();</span><br><span class="line">    <span class="type">int</span> numRows =  args-&gt;height / args-&gt;numThreads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; numRows; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> startRow = i * args-&gt;numThreads + args-&gt;threadId;</span><br><span class="line">      <span class="built_in">mandelbrotSerial</span>(args-&gt;x0, args-&gt;y0, args-&gt;x1, args-&gt;y1,</span><br><span class="line">                       args-&gt;width, args-&gt;height, startRow, <span class="number">1</span>,</span><br><span class="line">                       args-&gt;maxIterations ,args-&gt;output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we need to handle some corner case</span></span><br><span class="line">    <span class="type">int</span> remainRows = args-&gt;height % args-&gt;numThreads - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(remainRows &gt;= <span class="number">0</span> &amp;&amp; args-&gt;threadId &lt;= remainRows) &#123;</span><br><span class="line">      <span class="type">int</span> startRow = numRows * args-&gt;numThreads + args-&gt;threadId;</span><br><span class="line">      <span class="built_in">mandelbrotSerial</span>(args-&gt;x0, args-&gt;y0, args-&gt;x1, args-&gt;y1,</span><br><span class="line">                       args-&gt;width, args-&gt;height, startRow, <span class="number">1</span>,</span><br><span class="line">                       args-&gt;maxIterations ,args-&gt;output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> endTime = CycleTimer::<span class="built_in">currentSeconds</span>();</span><br><span class="line">    <span class="type">double</span> interval = endTime - startTime;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[thread %d]:\t\t[%.3f] ms\n&quot;</span>, args-&gt;threadId ,interval * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from thread %d\n&quot;</span>, args-&gt;threadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/31/7TN4ioGWXulPf6A.png" alt="The solution to the imbalance"></p><h3 id="Question-1-5"><a href="#Question-1-5" class="headerlink" title="Question 1.5"></a>Question 1.5</h3><p>It’s not, the reason is because that the <em>Amdahl’s</em> law. Which says that if a fraction $r$ of the serial program remain unparallelizm we can’t get a speedup better than $1&#x2F;r$. In this example, we have an important serial function <code>mandelbrotSerial</code>, so we can guess the value of $r$ to be 0.9 (I guess). So no matter how many threads we create, we could not get a speedup better than 9.</p><h2 id="Program-2"><a href="#Program-2" class="headerlink" title="Program 2"></a>Program 2</h2><p>This program is aimed at using SIMD. However, I have learned some basic ideas in CS61C.</p><h3 id="Question-2-1"><a href="#Question-2-1" class="headerlink" title="Question 2.1"></a>Question 2.1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">clampedExpVectorHelper</span><span class="params">(<span class="type">float</span>* values, <span class="type">int</span>* exponents, <span class="type">float</span>* output, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  __cs149_vec_float x;</span><br><span class="line">  __cs149_vec_int y;</span><br><span class="line">  __cs149_vec_float result;</span><br><span class="line">  __cs149_vec_int zero = _cs149_vset_int(<span class="number">0</span>);</span><br><span class="line">  __cs149_vec_int one = _cs149_vset_int(<span class="number">1</span>);</span><br><span class="line">  __cs149_vec_float max = _cs149_vset_float(<span class="number">9.999999f</span>);</span><br><span class="line">  __cs149_mask maskAll, maskIsExponentZero;</span><br><span class="line">  __cs149_mask maskIsNotExponentZero, loop, isExceedMax;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line">  <span class="keyword">for</span>(;i + VECTOR_WIDTH &lt;= N; i += VECTOR_WIDTH) &#123;</span><br><span class="line">    maskAll = _cs149_init_ones();</span><br><span class="line">    isExceedMax = _cs149_init_ones(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    result = _cs149_vset_float(<span class="number">0.0f</span>);</span><br><span class="line">    _cs149_vload_int(y, exponents + i, maskAll);</span><br><span class="line">    _cs149_veq_int(maskIsExponentZero, y, zero, maskAll);</span><br><span class="line">    _cs149_vset_float(result, <span class="number">1.f</span>, maskIsExponentZero);</span><br><span class="line"></span><br><span class="line">    maskIsNotExponentZero = _cs149_mask_not(maskIsExponentZero);</span><br><span class="line">    _cs149_vload_float(x, values + i, maskIsNotExponentZero);</span><br><span class="line">    _cs149_vadd_float(result, result, x , maskIsNotExponentZero);</span><br><span class="line">    _cs149_vsub_int(y, y, one, maskIsNotExponentZero);</span><br><span class="line">    _cs149_vgt_int(loop, y, zero, maskIsNotExponentZero);</span><br><span class="line">    <span class="keyword">while</span>(_cs149_cntbits(loop) != <span class="number">0</span>) &#123;</span><br><span class="line">      _cs149_vmult_float(result, result, x , loop);</span><br><span class="line">      _cs149_vsub_int(y, y, one, loop);</span><br><span class="line">      _cs149_vgt_int(loop, y, zero, loop);</span><br><span class="line">    &#125;</span><br><span class="line">    _cs149_vgt_float(isExceedMax, result, max, maskIsNotExponentZero);</span><br><span class="line">    _cs149_vset_float(result, <span class="number">9.999999f</span>, isExceedMax);</span><br><span class="line"></span><br><span class="line">    _cs149_vstore_float(output + i, result, maskAll);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clampedExpVector</span><span class="params">(<span class="type">float</span>* values, <span class="type">int</span>* exponents, <span class="type">float</span>* output, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="built_in">clampedExpVectorHelper</span>(values, exponents, output, N);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(index != N ) &#123;</span><br><span class="line">    <span class="type">float</span> valuesTemp[VECTOR_WIDTH] &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> exponentsTemp[VECTOR_WIDTH] &#123;&#125;;</span><br><span class="line">    <span class="type">float</span> outputTemp[VECTOR_WIDTH] &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = index; i &lt; N; ++i) &#123;</span><br><span class="line">      valuesTemp[i - index] = values[i];</span><br><span class="line">      exponentsTemp[i - index] = exponents[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clampedExpVectorHelper</span>(valuesTemp, exponentsTemp, outputTemp, VECTOR_WIDTH);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = index ; i &lt; N; ++i) &#123;</span><br><span class="line">      output[i] = outputTemp[i - index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Question-2-2"><a href="#Question-2-2" class="headerlink" title="Question 2.2"></a>Question 2.2</h3><p>When the vector width is 2:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector Width:              2</span><br><span class="line">Total Vector Instructions: 167727</span><br><span class="line">Vector Utilization:        77.3%</span><br><span class="line">Utilized Vector Lanes:     259325</span><br><span class="line">Total Vector Lanes:        335454</span><br></pre></td></tr></table></figure><p>When the vector width is 4:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector Width:              4</span><br><span class="line">Total Vector Instructions: 97075</span><br><span class="line">Vector Utilization:        70.2%</span><br><span class="line">Utilized Vector Lanes:     272541</span><br><span class="line">Total Vector Lanes:        388300</span><br></pre></td></tr></table></figure><p>When the vector width is 8:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector Width:              8</span><br><span class="line">Total Vector Instructions: 52877</span><br><span class="line">Vector Utilization:        66.5%</span><br><span class="line">Utilized Vector Lanes:     281229</span><br><span class="line">Total Vector Lanes:        423016</span><br></pre></td></tr></table></figure><p>When the vector width is 16:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector Width:              16</span><br><span class="line">Total Vector Instructions: 27592</span><br><span class="line">Vector Utilization:        64.8%</span><br><span class="line">Utilized Vector Lanes:     285861</span><br><span class="line">Total Vector Lanes:        441472</span><br></pre></td></tr></table></figure><p>As you can see, the vector utilization decreases, the reason I think is that the branch we make in each vector, when the vector size becomes bigger, the branch is more likely.</p><h3 id="Question-2-3"><a href="#Question-2-3" class="headerlink" title="Question 2.3"></a>Question 2.3</h3><p>It’s easy.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">arraySumVector</span><span class="params">(<span class="type">float</span>* values, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="type">float</span> value[VECTOR_WIDTH] &#123;&#125;;</span><br><span class="line">  __cs149_vec_float sum = _cs149_vset_float(<span class="number">0.0f</span>);</span><br><span class="line">  __cs149_vec_float num;</span><br><span class="line">  __cs149_mask maskAll = _cs149_init_ones();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i+=VECTOR_WIDTH) &#123;</span><br><span class="line">    _cs149_vload_float(num, values + i, maskAll);</span><br><span class="line">    _cs149_vadd_float(sum, sum, num, maskAll);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> number = VECTOR_WIDTH;</span><br><span class="line">  <span class="keyword">while</span> (number /= <span class="number">2</span>) &#123;</span><br><span class="line">    _cs149_hadd_float(sum, sum);</span><br><span class="line">    _cs149_interleave_float(sum, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  _cs149_vstore_float(value, sum, maskAll);</span><br><span class="line">  <span class="keyword">return</span> value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Program-3"><a href="#Program-3" class="headerlink" title="Program 3"></a>Program 3</h2><h3 id="Part-I"><a href="#Part-I" class="headerlink" title="Part I"></a>Part I</h3><p>We should first understand the code <code>mandelbrot_ispc</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export void mandelbrot_ispc(uniform float x0, uniform float y0,</span><br><span class="line">                            uniform float x1, uniform float y1,</span><br><span class="line">                            uniform int width, uniform int height,</span><br><span class="line">                            uniform int maxIterations,</span><br><span class="line">                            uniform int output[])</span><br><span class="line">&#123;</span><br><span class="line">    float dx = (x1 - x0) / width;</span><br><span class="line">    float dy = (y1 - y0) / height;</span><br><span class="line"></span><br><span class="line">    foreach (j = 0 ... height, i = 0 ... width) &#123;</span><br><span class="line">            float x = x0 + i * dx;</span><br><span class="line">            float y = y0 + j * dy;</span><br><span class="line"></span><br><span class="line">            int index = j * width + i;</span><br><span class="line">            output[index] = mandel(x, y, maxIterations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The idea here is obvious. We could split the graph into man $1 \times 1$ squares. And use 8-vector to solve. So the speedup should be 8. However the result is below.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#  ./mandelbrot_ispc -v 1</span><br><span class="line">[mandelbrot serial]:            [175.258] ms</span><br><span class="line">Wrote image file mandelbrot-serial.ppm</span><br><span class="line">[mandelbrot ispc]:              [30.405] ms</span><br><span class="line">Wrote image file mandelbrot-ispc.ppm</span><br><span class="line">                                (5.76x speedup from ISPC)</span><br><span class="line">#  ./mandelbrot_ispc -v 2</span><br><span class="line">[mandelbrot serial]:            [246.953] ms</span><br><span class="line">Wrote image file mandelbrot-serial.ppm</span><br><span class="line">[mandelbrot ispc]:              [50.832] ms</span><br><span class="line">Wrote image file mandelbrot-ispc.ppm</span><br><span class="line">                                (4.86x speedup from ISPC)</span><br></pre></td></tr></table></figure><p>Due to the reason that the ISPC compiler maps gangs of program instances to SIMD instructions executed on a single core. So we can know that the work is imbalance between each job.</p><h3 id="Part-II"><a href="#Part-II" class="headerlink" title="Part II"></a>Part II</h3><h4 id="Question-3-1"><a href="#Question-3-1" class="headerlink" title="Question 3.1"></a>Question 3.1</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ./mandelbrot_ispc -v 2 -t</span><br><span class="line">[mandelbrot serial]:            [246.911] ms</span><br><span class="line">Wrote image file mandelbrot-serial.ppm</span><br><span class="line">[mandelbrot ispc]:              [50.675] ms</span><br><span class="line">Wrote image file mandelbrot-ispc.ppm</span><br><span class="line">[mandelbrot multicore ispc]:    [30.390] ms</span><br><span class="line">Wrote image file mandelbrot-task-ispc.ppm</span><br><span class="line">                                (4.87x speedup from ISPC)</span><br><span class="line">                                (8.12x speedup from task ISPC)</span><br></pre></td></tr></table></figure><h4 id="Question-3-2"><a href="#Question-3-2" class="headerlink" title="Question 3.2"></a>Question 3.2</h4><p>We first look at <code>mandelbrot_ispc_task</code>, the idea of this function is easy, the whole procession is like <code>mandelbrot_ispc</code>. But with different tasks handle different areas.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">task void mandelbrot_ispc_task(uniform float x0, uniform float y0,</span><br><span class="line">                               uniform float x1, uniform float y1,</span><br><span class="line">                               uniform int width, uniform int height,</span><br><span class="line">                               uniform int rowsPerTask,</span><br><span class="line">                               uniform int maxIterations,</span><br><span class="line">                               uniform int output[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // taskIndex is an ISPC built-in</span><br><span class="line"></span><br><span class="line">    uniform int ystart = taskIndex * rowsPerTask;</span><br><span class="line">    uniform int yend = ystart + rowsPerTask;</span><br><span class="line"></span><br><span class="line">    uniform float dx = (x1 - x0) / width;</span><br><span class="line">    uniform float dy = (y1 - y0) / height;</span><br><span class="line"></span><br><span class="line">    foreach (j = ystart ... yend, i = 0 ... width) &#123;</span><br><span class="line">            float x = x0 + i * dx;</span><br><span class="line">            float y = y0 + j * dy;</span><br><span class="line"></span><br><span class="line">            int index = j * width + i;</span><br><span class="line">            output[index] = mandel(x, y, maxIterations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Well, the answer is the max thread you CPU could support.</p><h4 id="Question-3-3"><a href="#Question-3-3" class="headerlink" title="Question 3.3"></a>Question 3.3</h4><p>Tasks are independent work that can be executed with different cores. Contrary to threads, they do not have execution context and they are only pieces of work. The ISPC compiler takes the tasks and launches how many threads it decides.</p><h2 id="Program-4"><a href="#Program-4" class="headerlink" title="Program 4"></a>Program 4</h2><h3 id="Question-4-1"><a href="#Question-4-1" class="headerlink" title="Question 4.1"></a>Question 4.1</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ./sqrt</span><br><span class="line">[sqrt serial]:          [1747.862] ms</span><br><span class="line">[sqrt ispc]:            [366.439] ms</span><br><span class="line">[sqrt task ispc]:       [38.224] ms</span><br><span class="line">                                (4.77x speedup from ISPC)</span><br><span class="line">                                (45.73x speedup from task ISPC)</span><br></pre></td></tr></table></figure><h3 id="Question-4-2"><a href="#Question-4-2" class="headerlink" title="Question 4.2"></a>Question 4.2</h3><p>For this question, we should make sure that the load is balanced and time-consuming.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">  values[i] = <span class="number">2.99f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ./sqrt</span><br><span class="line">[sqrt serial]:          [2617.087] ms</span><br><span class="line">[sqrt ispc]:            [396.478] ms</span><br><span class="line">[sqrt task ispc]:       [45.276] ms</span><br><span class="line">                                (6.60x speedup from ISPC)</span><br><span class="line">                                (57.80x speedup from task ISPC)</span><br></pre></td></tr></table></figure><h3 id="Question-4-3"><a href="#Question-4-3" class="headerlink" title="Question 4.3"></a>Question 4.3</h3><p>For this question, we should make sure that the load is imbalanced.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">  i % <span class="number">8</span> ? values[i] = <span class="number">1.0f</span> : values[i] = <span class="number">2.99f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ./sqrt</span><br><span class="line">[sqrt serial]:          [132.275] ms</span><br><span class="line">[sqrt ispc]:            [142.305] ms</span><br><span class="line">[sqrt task ispc]:       [16.307] ms</span><br><span class="line">                                (0.93x speedup from ISPC)</span><br><span class="line">                                (8.11x speedup from task ISPC)</span><br></pre></td></tr></table></figure><h2 id="Program-5"><a href="#Program-5" class="headerlink" title="Program 5"></a>Program 5</h2><h3 id="Question-5-1"><a href="#Question-5-1" class="headerlink" title="Question 5.1"></a>Question 5.1</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ./saxpy</span><br><span class="line">[saxpy ispc]:           [21.670] ms     [13.753] GB/s   [1.846] GFLOPS</span><br><span class="line">[saxpy task ispc]:      [22.282] ms     [13.375] GB/s   [1.795] GFLOPS</span><br><span class="line">                                (0.97x speedup from use of tasks)</span><br></pre></td></tr></table></figure><p>I think in this question, we should use less tasks, due to the cache line the CPU writes, if there are many tasks, we would always meet a cache miss. So I change the task to be 2.</p><p>However, when I change the task to be 2, there is no speedup improvement, so the reason maybe the memory bandwidth.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[saxpy ispc]:           [21.400] ms     [13.927] GB/s   [1.869] GFLOPS</span><br><span class="line">[saxpy task ispc]:      [23.430] ms     [12.720] GB/s   [1.707] GFLOPS</span><br><span class="line">                                (0.91x speedup from use of tasks)</span><br></pre></td></tr></table></figure><h3 id="Question-5-2"><a href="#Question-5-2" class="headerlink" title="Question 5.2"></a>Question 5.2</h3><p>The reason is in Question 5.1. Put the content in the cache line and flash the cache line.</p>]]></content>
      
      
      <categories>
          
          <category> CS149 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念我的外婆</title>
      <link href="/2023/01/02/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E5%A4%96%E5%A9%86/"/>
      <url>/2023/01/02/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E5%A4%96%E5%A9%86/</url>
      
        <content type="html"><![CDATA[<p>我的外婆死于2022年12月26日的早上11点40分左右。</p><p>一到医院，我就听到了外婆去世的噩耗，死因呼吸衰竭。或许在决定放弃插管的那一刻起，这就是已经注定好的结局。然而，我却未能与外婆说上最后的一句话。任凭时间流失着，外公他们已经开始联系殡仪馆的人，准备火化。我的脑袋不知是被新冠侵染的厉害，还是被这残酷的事实击的难以恢复。我不仅回忆起过往的点点滴滴，难以忍受的寂寞与孤单感再次席卷我的全身。</p><p>由于身体的原因，我去灵堂的时候已经是第二天的下午了，望着灵堂上外婆的黑白照片，仍然觉得无比的寂寞。我心里很清楚地认识到外婆的人生已经画上了终结。然而，活在世上的人们仍然在继续生活。周围很是嘈杂，讨论着新冠死了不少的老年人。我和姐姐坐在一起，烧着纸。我的内心只觉压抑。</p><p>晚上，托新冠的“祝福”，我需要回家休息不能守夜。我送外公回家，回到了那个熟悉的房子，熟悉的家具，熟悉的位置。然而唯独少了个熟悉的人，我的内心似乎被人挖走了似的，我感觉到了无比的空虚，微笑地对外公说：“外公，记得早点休息哈”。又是令人厌恶的抽离感，外公他会觉得寂寞吗？我被这虚无所缠绕，难以忍受。我的外婆已然不存在，然而她的痕迹却存在于这个小小的房子里面。被遗留下的人儿，只会更加孤独与寂寞。这就是死亡吗？比起物质上的灭亡，更令我痛苦的是精神上的死亡。</p><p>隔了几天，家里面开始收拾外婆家的东西，我望着一件又一件丢失的东西，内心的孤独与寂寞再次涌上。我不禁回想起当时在外婆家那么多人吃着饭的场景，才明白小小的幸福对人来说是真的无比重要。</p><p>仅以此文纪念我的外婆。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 6 &amp; lab 7</title>
      <link href="/2022/11/30/CS144-Introduction-to-Computer-Networking-Lab-6-lab-7/"/>
      <url>/2022/11/30/CS144-Introduction-to-Computer-Networking-Lab-6-lab-7/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><h2 id="Lab-6"><a href="#Lab-6" class="headerlink" title="Lab 6"></a>Lab 6</h2><h3 id="add-route"><a href="#add-route" class="headerlink" title="add_route"></a>add_route</h3><p>To add a router, we need to store <code>route_prefix</code>, <code>prefix_length</code>, <code>next_hop</code> and <code>interface_num</code>.</p><p>So I design the following data structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//! The router information</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">RouterInformation</span> &#123;</span><br><span class="line">        <span class="type">uint32_t</span> route_prefix;</span><br><span class="line">        <span class="type">uint8_t</span> prefix_length;</span><br><span class="line">        std::optional&lt;Address&gt; next_hop;</span><br><span class="line">        <span class="type">size_t</span> interface_num;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! The router table</span></span><br><span class="line">    std::vector&lt;RouterInformation&gt; _router_table&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now it is easy to implement <code>add_route</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">(<span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">size_t</span> interface_num)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>(route_prefix).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">int</span>(prefix_length)</span><br><span class="line">         &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; (next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span>) &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    RouterInformation record&#123;&#125;;</span><br><span class="line">    record.route_prefix = route_prefix;</span><br><span class="line">    record.prefix_length = prefix_length;</span><br><span class="line">    record.next_hop = next_hop;</span><br><span class="line">    record.interface_num = interface_num;</span><br><span class="line">    _router_table.<span class="built_in">push_back</span>(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="route-one-datagram"><a href="#route-one-datagram" class="headerlink" title="route_one_datagram"></a>route_one_datagram</h3><p>The process is easy, we just do mask operation. The most tricky part is how to calculate the mask. For example, for <code>_prefix_length = 16</code>, we should produce <code>0x0000ffff</code>. where we could represent with <code>uint32_t mask = 0xffffffff &gt;&gt; _prefix_length</code>. But the trick thing is when <code>_prefix_length</code> equals to 32. We should handle this corner case.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_length = <span class="number">-1</span>;</span><br><span class="line">    optional&lt;Address&gt; next_hop &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> interface_num = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We just iterate the record and fined the longest-prefix-match</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; record : _router_table) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> mask = record.prefix_length == <span class="number">0</span> ? <span class="number">0</span> : numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">min</span>() &gt;&gt; (record.prefix_length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((dgram.<span class="built_in">header</span>().dst &amp; mask) == record.route_prefix &amp;&amp; max_length &lt; record.prefix_length) &#123;</span><br><span class="line">            max_length = record.prefix_length;</span><br><span class="line">            next_hop = record.next_hop;</span><br><span class="line">            interface_num = record.interface_num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_length == <span class="number">-1</span> || dgram.<span class="built_in">header</span>().ttl == <span class="number">0</span> || --dgram.<span class="built_in">header</span>().ttl == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_hop.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        _interfaces[interface_num].<span class="built_in">send_datagram</span>(dgram, next_hop.<span class="built_in">value</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _interfaces[interface_num].<span class="built_in">send_datagram</span>(dgram, Address::<span class="built_in">from_ipv4_numeric</span>(dgram.<span class="built_in">header</span>().dst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab-7"><a href="#Lab-7" class="headerlink" title="Lab 7"></a>Lab 7</h2><p>There is no content in the Lab 7. At last, I wanna appreciate the CS144 team which provides the public this wonderful series of labs.</p><blockquote><p>What I cannot build, I do not understand.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 5</title>
      <link href="/2022/11/29/CS144-Introduction-to-Computer-Networking-Lab-5/"/>
      <url>/2022/11/29/CS144-Introduction-to-Computer-Networking-Lab-5/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><p>First you should carefully read the docs provided by lab. I give some important things here.</p><blockquote><p>If the destination Ethernet address is unknown, broadcast an ARP request for the next hop’s Ethernet address and queue the IP datagram so it can be sent after the ARP reply is received. If the network already interface already sent an ARP request about the same IP address in the last five seconds, don’t send a second request.</p></blockquote><p>For the above description, it is obvious that we need to stores the IP datagram and also the time since it has been sent. When we receive a new IP datagram we need to check whether it is in the list. I use the following data structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! information for the block ethernet frame and the time since it has been sent</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BlockedEthernetFrame</span> &#123;</span><br><span class="line">    EthernetFrame _frame&#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> _time&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! mapping from next-hop-ip to BlockedEthernetFrame</span></span><br><span class="line">std::unordered_map&lt;<span class="type">uint32_t</span>, BlockedEthernetFrame&gt; blocked&#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>If the inbound frame is ARP, parse the payload as an <code>ARPMessage</code> and, if successful, remember the mapping between the sender’s IP address and Ethernet address for 30 seconds</p></blockquote><p>As you can see, we need to maintain the mapping cache from ip address to the Ethernet address and with expiration time 30 seconds. I use the following data structure.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! information for the Ethernet cache</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EthernetEntry</span> &#123;</span><br><span class="line">    EthernetAddress _mac&#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> _time&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! the mapping cache from next-hop-ip to EthernetAddress</span></span><br><span class="line">std::unordered_map&lt;<span class="type">uint32_t</span>, EthernetEntry&gt; _arp_cache&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="Auxiliary-functions"><a href="#Auxiliary-functions" class="headerlink" title="Auxiliary functions"></a>Auxiliary functions</h2><p>For this lab, we need to create <code>EthernetFrame</code> with different type (<code>TYPE_IPv4</code> and <code>TYPE_ARP</code>) and with different payload. For <code>TYPE_IPv4</code>, we do not consider payload, for <code>TYPE_ARP</code>, we need to consider its payload, we need to create the <code>ARPMessage</code> class.</p><p>So I first define a function named <code>new_ethernet_frame</code>, which unifies the process of creating different kinds of <code>EthernetFrame</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EthernetFrame <span class="title">NetworkInterface::new_ethernet_frame</span><span class="params">(<span class="type">uint16_t</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   EthernetAddress src,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   EthernetAddress dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   BufferList payload)</span> </span>&#123;</span><br><span class="line">    EthernetFrame frame&#123;&#125;;</span><br><span class="line">    frame.<span class="built_in">header</span>().type = type;</span><br><span class="line">    frame.<span class="built_in">header</span>().src = src;</span><br><span class="line">    frame.<span class="built_in">header</span>().dst = dst;</span><br><span class="line">    frame.<span class="built_in">payload</span>() = payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::set_ethernet_frame_dst</span><span class="params">(EthernetFrame &amp;frame, EthernetAddress dst)</span> </span>&#123; frame.<span class="built_in">header</span>().dst = dst; &#125;</span><br></pre></td></tr></table></figure><p>Then, i define a function named <code>create_arp_message</code>, which creates <code>ARPMessage</code> instance.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ARPMessage <span class="title">NetworkInterface::create_arp_message</span><span class="params">(<span class="type">uint32_t</span> sender_ip_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                EthernetAddress sender_ethernet_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">uint32_t</span> target_ip_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                EthernetAddress target_ethernet_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">uint16_t</span> opcode)</span> </span>&#123;</span><br><span class="line">    ARPMessage message&#123;&#125;;</span><br><span class="line">    message.sender_ip_address = sender_ip_address;</span><br><span class="line">    message.sender_ethernet_address = sender_ethernet_address;</span><br><span class="line">    message.target_ip_address = target_ip_address;</span><br><span class="line">    message.target_ethernet_address = target_ethernet_address;</span><br><span class="line">    message.opcode = opcode;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>This lab is not difficult, you could see my code for explanation, there are a lot of comments which describe the intent of the code.</p><h3 id="send-datagram"><a href="#send-datagram" class="headerlink" title="send_datagram"></a>send_datagram</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="type">const</span> InternetDatagram &amp;dgram, <span class="type">const</span> Address &amp;next_hop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> next_hop_ip = next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a ipv4 type EthernetFrame</span></span><br><span class="line">    EthernetFrame ipv4_ethernet_frame =</span><br><span class="line">        <span class="built_in">new_ethernet_frame</span>(EthernetHeader::TYPE_IPv4, _ethernet_address, &#123;&#125;, dgram.<span class="built_in">serialize</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the hardware address is in cache and it does not expire.</span></span><br><span class="line">    <span class="keyword">if</span> (_arp_cache.<span class="built_in">find</span>(next_hop_ip) != _arp_cache.<span class="built_in">end</span>() &amp;&amp; _arp_cache[next_hop_ip]._time &lt;= <span class="number">30000</span>) &#123;</span><br><span class="line">        <span class="built_in">set_ethernet_frame_dst</span>(ipv4_ethernet_frame, _arp_cache[next_hop_ip]._mac);</span><br><span class="line">        <span class="built_in">frames_out</span>().<span class="built_in">push</span>(ipv4_ethernet_frame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We do not allow ARP flood, add a rate limit</span></span><br><span class="line">        <span class="keyword">if</span> (blocked.<span class="built_in">find</span>(next_hop_ip) != blocked.<span class="built_in">end</span>() &amp;&amp; blocked[next_hop_ip]._time &lt;= <span class="number">5000</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ARPMessage arp_message = <span class="built_in">create_arp_message</span>(</span><br><span class="line">            _ip_address.<span class="built_in">ipv4_numeric</span>(), _ethernet_address, next_hop_ip, &#123;&#125;, ARPMessage::OPCODE_REQUEST);</span><br><span class="line">        EthernetFrame arp_ethernet_frame = <span class="built_in">new_ethernet_frame</span>(EthernetHeader::TYPE_ARP,</span><br><span class="line">                                                              _ethernet_address,</span><br><span class="line">                                                              ETHERNET_BROADCAST,</span><br><span class="line">                                                              BufferList&#123;std::<span class="built_in">move</span>(arp_message.<span class="built_in">serialize</span>())&#125;);</span><br><span class="line"></span><br><span class="line">        BlockedEthernetFrame new_blocked_datagram&#123;&#125;;</span><br><span class="line">        new_blocked_datagram._time = <span class="number">0</span>;</span><br><span class="line">        new_blocked_datagram._frame = ipv4_ethernet_frame;</span><br><span class="line"></span><br><span class="line">        blocked.<span class="built_in">insert</span>(&#123;next_hop_ip, new_blocked_datagram&#125;);</span><br><span class="line">        <span class="built_in">frames_out</span>().<span class="built_in">push</span>(arp_ethernet_frame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="recv-frame"><a href="#recv-frame" class="headerlink" title="recv_frame"></a>recv_frame</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="type">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">    optional&lt;InternetDatagram&gt; new_datagram&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to check whether the EthernetFrame is correct</span></span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().dst != _ethernet_address &amp;&amp; frame.<span class="built_in">header</span>().dst != ETHERNET_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">return</span> new_datagram;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the EthernetFrame type is IPv4, we just parse its payload</span></span><br><span class="line">    <span class="comment">// to get the ip segment</span></span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == frame.<span class="built_in">header</span>().TYPE_IPv4) &#123;</span><br><span class="line">        InternetDatagram ipv4_datagram&#123;&#125;;</span><br><span class="line">        ipv4_datagram.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>());</span><br><span class="line">        new_datagram.<span class="built_in">emplace</span>(ipv4_datagram);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ARPMessage arp_message&#123;&#125;;</span><br><span class="line">        arp_message.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it asks for mac</span></span><br><span class="line">        <span class="keyword">if</span> (arp_message.target_ip_address != _ip_address.<span class="built_in">ipv4_numeric</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> new_datagram;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// As long as we receive a ARPMessage, we should update the cache and</span></span><br><span class="line">        <span class="comment">// pushes the ipv4 segment.</span></span><br><span class="line">        _arp_cache[arp_message.sender_ip_address]._mac = arp_message.sender_ethernet_address;</span><br><span class="line">        _arp_cache[arp_message.sender_ip_address]._time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> iter = blocked.<span class="built_in">find</span>(arp_message.sender_ip_address);</span><br><span class="line">        <span class="keyword">if</span> (iter != blocked.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            iter-&gt;second._frame.<span class="built_in">header</span>().dst = arp_message.sender_ethernet_address;</span><br><span class="line">            <span class="built_in">frames_out</span>().<span class="built_in">push</span>(iter-&gt;second._frame);</span><br><span class="line">            blocked.<span class="built_in">erase</span>(iter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When sending</span></span><br><span class="line">        <span class="keyword">if</span> (arp_message.opcode == arp_message.OPCODE_REQUEST) &#123;</span><br><span class="line">            ARPMessage message = <span class="built_in">create_arp_message</span>(_ip_address.<span class="built_in">ipv4_numeric</span>(),</span><br><span class="line">                                                    _ethernet_address,</span><br><span class="line">                                                    arp_message.sender_ip_address,</span><br><span class="line">                                                    arp_message.sender_ethernet_address,</span><br><span class="line">                                                    ARPMessage::OPCODE_REPLY);</span><br><span class="line"></span><br><span class="line">            EthernetFrame arp_ethernet_frame = <span class="built_in">new_ethernet_frame</span>(EthernetHeader::TYPE_ARP,</span><br><span class="line">                                                                  _ethernet_address,</span><br><span class="line">                                                                  arp_message.sender_ethernet_address,</span><br><span class="line">                                                                  BufferList&#123;std::<span class="built_in">move</span>(message.<span class="built_in">serialize</span>())&#125;);</span><br><span class="line">            <span class="built_in">frames_out</span>().<span class="built_in">push</span>(arp_ethernet_frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_datagram;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We should iterate the `blocked`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;entry : blocked) &#123;</span><br><span class="line">        entry.second._time += ms_since_last_tick;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We should iterate the `_arp_cache`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;cache : _arp_cache) &#123;</span><br><span class="line">        cache.second._time += ms_since_last_tick;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 4</title>
      <link href="/2022/11/28/CS144-Introduction-to-Computer-Networking-Lab-4/"/>
      <url>/2022/11/28/CS144-Introduction-to-Computer-Networking-Lab-4/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><p>Before we write the code, we should think what would <code>TCPConnection</code> do. If you carefully read the docs provided by lab. You will understand the requirements easily. But the most important thing is to understand how <code>TCPConnection</code> combines the <code>TCPReceiver</code> and <code>TCPSender</code> and achieves the functionality.</p><p>Here, I give an example to illustrate the process. I named the two instances of <code>TCPConnection</code> called <code>TCPConnectionA</code> and <code>TCPConnectionB</code>. And the <code>TCPConnectionA</code> has two classes <code>TCPReceiverA</code> and <code>TCPSenderA</code>, respectively, the <code>TCPConnectionB</code> has two classes <code>TCPReceiverB</code> and <code>TCPSenderB</code>.</p><p>When <code>TCPConnectionA</code> sends the segment to <code>TCPConnectionB</code>, it will calls the <code>TCPSenderA</code>‘s <code>fill_window()</code> method to extract the data to the segments. It will maintain the absolute sequence number for the next byte to be sent. However, <em>there is one thing we do not consider, how about the acknowledge number in the header?</em>. We need to do this in the <code>TCPConnection</code> class.</p><p>And when <code>TCPConnectionB</code> using <code>segment_received</code> method to handle the received segments. It should do the following things:</p><ul><li>It should uses <code>TCPReceiverB</code>‘s method <code>segment_received</code> method which updates its acknowledge number which should later be sent to the <code>TCPConnectionA</code>. Now we can understand the above question: the acknowledge number comes from itself receiver’s stored acknowledge number.</li><li>Next it should use <code>TCPSenderB</code>‘s <code>ack_received</code> to update the <code>TCPSenderA</code>‘s acknowledge number and its window size.</li><li>Then we should call the <code>fill_window</code> method and pops the <code>TCPSenderB</code>‘s <code>_segments_out</code> to <code>TCPConnectionB</code>‘s <code>_segments_out</code>. And also we need to change the header part, set the acknowledge number to the <code>TCPReceiverB</code>‘s acknowledge number.</li></ul><p>I am really appreciating the nice abstraction for this design. You can look at the following picture for better understanding.</p><p><img src="https://s2.loli.net/2022/11/28/Hcbp5rQ6qK8fCzF.png" alt="TCPConnection Example"></p><h2 id="Easy-functions"><a href="#Easy-functions" class="headerlink" title="Easy functions"></a>Easy functions</h2><p>There are some easy functions which just some getters. We can implement these functions immediately.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPConnection</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! the flag to indicate whether it is alive</span></span><br><span class="line">    <span class="type">bool</span> _active&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the time interval since last segment received.</span></span><br><span class="line">    <span class="type">size_t</span> _time_since_last_segment_received&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _time_since_last_segment_received; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _active; &#125;</span><br></pre></td></tr></table></figure><h2 id="TCP-Connection"><a href="#TCP-Connection" class="headerlink" title="TCP Connection"></a>TCP Connection</h2><p>It’s not hard to write the code about sending the data or receiving the data. I have already talked about a lot above. However, we need to handle the connection and close carefully.</p><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>In the <code>TCPSender</code> class, we actually do not consider the ack. So we need to use <code>_sender.send_empty_segment()</code> to produce a new segment when connecting.</p><h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><p>The most difficult part is how to gracefully close the <code>TCPConnection</code>. For unclean shutdown, it’s easy. We just send or receive a segment with the <code>RST</code> flag set.</p><p>However, for clean shutdown. There are so many things we need to do.</p><ul><li><p><em>Prereq #1</em> The inbound stream has been fully assembled and has ended. I use a private function called <code>check_inbound_stream_assembled_and_ended</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::check_inbound_stream_assembled_and_ended</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>(); &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>Prereq #2</em> The outbound stream has been ended by the local application and fully sent the fact that it ended to the remote peer. Remember, I have provided a <code>end</code> flag but without no public method to get that value. So I do this and uses a function called <code>check_outbound_stream_ended_and_send_fin</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::check_outbound_stream_ended_and_send_fin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">is_end</span>(); &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>Prereq #3</em> The outbound stream has been fully acknowledged by the remote peer. I use a function called <code>check_outbound_fully_acknowledged</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::check_outbound_fully_acknowledged</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p><em>Prereq #4</em> It’s important to understand the reason why there are two situations. We would implement this in the <code>tick</code> function</p></li></ul><p>We can code now.</p><h2 id="Auxiliary-functions"><a href="#Auxiliary-functions" class="headerlink" title="Auxiliary functions"></a>Auxiliary functions</h2><p>Here, I first define a function called <code>set_ack_and_window</code>, it inspects the <code>_receiver</code>‘s acknowledge number and window size. And updates the corresponding fields of itself.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_ack_and_window</span><span class="params">(TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> window_size = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (window_size &gt; numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">        window_size = numeric_limits&lt;<span class="type">uint16_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    seg.<span class="built_in">header</span>().win = window_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And I define <code>send_new_segments</code>, which recursively adds new segments to the <code>_segments_out</code>. The most importantly, we should indicate whether we could write new segments. There are situations the segment we need to send with no payload but with SYN or FIN set or a keep-alive message.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TCPConnection::send_new_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> is_really_send = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        is_really_send = <span class="literal">true</span>;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_really_send;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Also, there are two situations we should send a segment with RST set. So I use a function named <code>send_rst_flag_segment</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::send_rst_flag_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">    segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Also, I define <code>set_error</code> function to handle the RST set segment or we want to send a new RST set segment.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::set_error</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>Now we comes to the most important part, when the client wants to connect the server, it calls the <code>connect</code>. It is simple enough, because I have done the job in the <code>TCPSender</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_new_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file: tcp_sender.cc</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">        _next_seqno += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="segment-received"><a href="#segment-received" class="headerlink" title="segment_received"></a>segment_received</h2><p>For <code>segment_received</code>, it is tricky.</p><ol><li>We handle the segment with RST set. It is easy.</li><li>We should call <code>_receiver.segment_received</code> method to update the acknowledge number and window size.</li><li>We check whether the inbound stream is end (the opposite sender would tell us this information), if so, we are the passive, we don’t need the <code>TIME_WAIT</code> timer, set the <code>_linger_after_streams_finish</code> to be <code>false</code>.</li><li>When the received segment with ACK set, we should first checkout whether we should accept the segment. If the <code>receiver_ackno()</code> doesn’t exist, we just return. Otherwise, we should call <code>_sender.ack_received</code> and <code>_fill_window()</code> and calls <code>send_new_segments</code>.</li><li>Next, we need to handle the situation with no payload.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Reset the accumulated time</span></span><br><span class="line">    _time_since_last_segment_received = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the `rst` flag is set, sets both the inbound and outbound</span></span><br><span class="line">    <span class="comment">// streams to the error state and kills the connection permanently.</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        <span class="built_in">set_error</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the receiver would update the acknowledge number and window size</span></span><br><span class="line">    <span class="comment">// of itself.</span></span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the inbound stream ends before the `TCPConnection` has reached EOF</span></span><br><span class="line">    <span class="comment">// on its outbound stream, `_linger_after_streams_finish` should be false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_inbound_stream_assembled_and_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">        <span class="comment">// Corner case: When listening, we should drop all the ACK.</span></span><br><span class="line">        <span class="keyword">if</span> (!_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        <span class="built_in">send_new_segments</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">send_new_segments</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">            _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>Simple enough.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_new_segments</span>();</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="end-input-stream"><a href="#end-input-stream" class="headerlink" title="end_input_stream"></a>end_input_stream</h2><p><code>end_input_stream</code> aims at doing active close. So we first signal the <code>_sender</code>‘s ByteStream to be end and calls <code>_fill_window</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="built_in">send_new_segments</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h2><p>For <code>tick</code>, we should retransmit the segment. If the retransmission time <code>consecutive_retransmissions()</code> is greater than <code>_cfg.MAX_RETX_ATTEMPTS</code>, we should produce a segment with RST set. However, this is not the most important point. When <code>tick</code> is called, for passive closer, it just returns. For active closer we need to make sure that the passive closer has successfully received the <code>ACK</code> sent by the active closer. But we have no idea, so if the passive closer doesn’t retransmit the segment in a period of time, we can think that passive closer has already been closed. Thus we can close the active closer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _time_since_last_segment_received += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to retransmit the segments</span></span><br><span class="line">    <span class="keyword">if</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment segment = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">set_ack_and_window</span>(segment);</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; _cfg.MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">            <span class="built_in">set_error</span>();</span><br><span class="line">            segment.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(segment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_inbound_stream_assembled_and_ended</span>() &amp;&amp; <span class="built_in">check_outbound_stream_ended_and_send_fin</span>() &amp;&amp;</span><br><span class="line">        <span class="built_in">check_outbound_fully_acknowledged</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_linger_after_streams_finish) &#123;</span><br><span class="line">            _active = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">            _active = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 3</title>
      <link href="/2022/11/23/CS144-Introduction-to-Computer-Networking-Lab-3/"/>
      <url>/2022/11/23/CS144-Introduction-to-Computer-Networking-Lab-3/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><p>First, you should read carefully read the docs provided by the lab.</p><blockquote><p>It will be your <code>TCPSender</code>‘s responsibility to:</p><ul><li>Keep track of the receiver’s window</li><li>Fill the window when possible, by reading from the <code>ByteStream</code>, creating new TCP segments, and sending them. The sender should keep sending segments until either the window is full or the <code>ByteStream</code> is empty.</li><li>Keep track of which segments have been sent but not yet acknowledged by the receiver——we call these “outstanding” segments.</li><li>Re-send outstanding segments if enough time passes since they were sent, and they haven’t been acknowledged yet.</li></ul></blockquote><h2 id="Retransmission-timer"><a href="#Retransmission-timer" class="headerlink" title="Retransmission timer"></a>Retransmission timer</h2><p>According to the docs, the first thing we need to do is to implement a class for retransmission timer. So I have created two files <code>retransmission_timer.hh</code> and <code>retransmission_timer.cc</code>. However, before we implement this class in action, we should understand the requirements:</p><ul><li><code>tick(const size_t ms_since_last_tick)</code> method is aimed at simulating the time. So every time the <code>tick</code> is called, we need to add the <code>ms_since_last_tick</code> to the <code>_accumulate_time</code>. When the <code>_accumulate_time</code> is greater than the <code>_rto</code>, the timer has elapsed. So we need to call a function called <code>tick_callback</code> every time <code>tick</code> is called.</li><li>If the timer has elapsed, and the window size is not zero: double the value of the <code>_rto</code>, so we need a function called <code>handle_expired</code>. Also, we need to set the <code>_accumulate_time</code> to be 0.</li><li>Every time a segment <em>containing data</em> is sent, if the timer is not running, start it running. So we need to maintain a state. I use a function called <code>start_timer</code> to start the timer.</li><li>When receiver gives the sender an <code>ackno</code> that acknowledges the successful receipt of <em>new</em> data: we use <code>reset_timer</code> to set the <code>_rto</code> to its initial value and clear the <code>_accumulate_timer</code>. If all the outstanding segments are received, we should stop the timer called <code>stop_timer</code>.</li></ul><p>At now, we can code.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: retransmission_timer.hh</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TimerState</span> &#123; running, stop &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RetransmissionTimer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    TimerState state;             <span class="comment">//! the state of the timer</span></span><br><span class="line">    <span class="type">size_t</span> _initial_rto;          <span class="comment">//! the initial retransmission timeout</span></span><br><span class="line">    <span class="type">size_t</span> _rto;                  <span class="comment">//! current retransmission timeout</span></span><br><span class="line">    <span class="type">size_t</span> _accumulate_time = <span class="number">0</span>;  <span class="comment">//! the accumulate time</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! \brief constructor</span></span><br><span class="line">    <span class="built_in">RetransmissionTimer</span>(<span class="type">const</span> <span class="type">size_t</span> retx_timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief check whether the time is expired</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">tick_callback</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief when receiving a valid ack, reset the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset_timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief when the timer is expired we should handle this situation</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_expired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief start the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start_timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief stop the timer</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop_timer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: retransmission_timer.cc</span></span><br><span class="line">RetransmissionTimer::<span class="built_in">RetransmissionTimer</span>(<span class="type">const</span> <span class="type">size_t</span> retx_timeout)</span><br><span class="line">    : state&#123;TimerState::stop&#125;, _initial_rto&#123;retx_timeout&#125;, _rto&#123;retx_timeout&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RetransmissionTimer::tick_callback</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//! Only when the timer is running, we add the `_accumulate_time`.</span></span><br><span class="line">    <span class="keyword">if</span> (state == TimerState::running) &#123;</span><br><span class="line">        _accumulate_time += ms_since_last_tick;</span><br><span class="line">        <span class="comment">//! Check whether the timer has elapsed.</span></span><br><span class="line">        <span class="keyword">return</span> _rto &lt;= _accumulate_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::reset_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _rto = _initial_rto;</span><br><span class="line">    _accumulate_time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::start_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == TimerState::stop) &#123;</span><br><span class="line">        state = TimerState::running;</span><br><span class="line">        <span class="built_in">reset_timer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::stop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == TimerState::running) &#123;</span><br><span class="line">        state = TimerState::stop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RetransmissionTimer::handle_expired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _rto *= <span class="number">2</span>;</span><br><span class="line">    _accumulate_time = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP-sender"><a href="#TCP-sender" class="headerlink" title="TCP sender"></a>TCP sender</h2><p>There are four public interfaces we need to implement for <code>TCPSender</code>:</p><ul><li><code>void fill_window()</code>.</li><li><code>void ack_received(const WrappingInt32 ackno, const uint16_t window_size)</code>.</li><li><code>void tick(const size_t ms_since_last_tick)</code>.</li><li><code>void send_empty_segment()</code>.</li></ul><p>Well, the main purpose for <code>fill_window()</code> is to translate ByteStream to TCPSegment. And we need to push these segments to <code>_segments_out</code>. And writes a reference copy to <code>_outstanding_segments</code> .In this process, there are some many things we need to consider:</p><ul><li>We should record the receiver’s acknowledge number <code>_receiver_ack</code> and window size <code>_receiver_window_size</code> to know whether we could transmit the new segments to the receiver.</li><li>We also need to consider about the ByteStream size.</li><li>We need to think about the data structure of the <code>_outstanding_segments</code>. In <code>full_window()</code>, it should support insertion.</li></ul><p>For <code>ack_received()</code>, when we receiving the acknowledge number from the receiver, first we update <code>_receiver_ack</code> and delete the fully acknowledged segments from <code>_outstanding_segments</code> and calls <code>fill_window()</code>. So the data structure for <code>_outstanding_segments</code> should support deletion.</p><p>For <code>tick()</code>, it should check whether the retransmission timer has expired. If so, it should retransmit the <em>earliest</em> (lowest sequence number) segment. So we need to make the <code>_outstanding_segments</code> sorted.</p><h3 id="The-data-structure-of-outstanding-segments"><a href="#The-data-structure-of-outstanding-segments" class="headerlink" title="The data structure of outstanding segments"></a>The data structure of outstanding segments</h3><p>I decide to use <code>list</code> to represent the data structure of outstanding segments. The reasons are as follows:</p><ul><li>We could easily make it sorted.</li><li>We could add and delete a segment fast.</li></ul><h3 id="Some-private-members"><a href="#Some-private-members" class="headerlink" title="Some private members"></a>Some private members</h3><p>Before implementing the interfaces, we can define the following fields:</p><ul><li><code>_retransmission_timer</code>: the timer defined above.</li><li><code>_receiver_ack</code>: the absolute receiver ack.</li><li><code>_receiver_window_size</code>: the receiver window size which should be 1 when initialized.</li><li><code>_outstanding_segments</code>: the outstanding segments</li><li><code>_consecutive_retransmissions</code>: the consecutive retransmissions.</li><li><code>window_not_full</code>: a helper function to tell whether the window is not full.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//! the retransmission timer</span></span><br><span class="line">    RetransmissionTimer _retransmission_timer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the (absolute) receiver ack.</span></span><br><span class="line">    <span class="type">uint64_t</span> _receiver_ack&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the initial window size should be 1</span></span><br><span class="line">    <span class="type">uint64_t</span> _receiver_window_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the outstanding segments</span></span><br><span class="line">    std::list&lt;TCPSegment&gt; _outstanding_segments&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the consecutive retransmissions</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _consecutive_retransmissions&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! a helper function to tell whether the window is not full</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">window_not_full</span><span class="params">(<span class="type">uint64_t</span> window_size)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> window_size &gt; <span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a>fill_window</h3><p>There are two special cases we should consider for the <code>fill_window</code> functions:</p><ul><li>TCP connection</li><li>TCP disconnection</li></ul><p>For the TCP connection where <code>_next_seqno == 0</code>, we should set the <code>syn</code> to be <code>true</code> and sends the datagram out.</p><p>For the TCP disconnection, things could be much more complicated. There are two cases:</p><ul><li>An empty payload which indicates the disconnection where <code>stream_in().eof()</code> is <code>true</code>.</li><li>Nonempty payload which indicates the disconnection where <code>stream_in().eof()</code> is <code>true</code>.</li></ul><p>For transferring the data, we want to transfer as much as we want. We should consider about the following three things:</p><ul><li>For a TCP segment, the length which should not exceed <code>TCPConfig::MAX_PAYLOAD_SIZE</code>.</li><li>We can only transfer the length which should not exceed <code>_receiver_window_size - bytes_in_flight()</code>.</li><li>We can only transfer the length which should not exceed <code>stream_in().buffer_size()</code>.</li></ul><p>At the end, we need to start the timer.</p><p>Well, It may seem easy, however, there are some many corner cases. Please look at the following code for details.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Special case: we have already sent the `FIN`.</span></span><br><span class="line">    <span class="keyword">if</span> (end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCPSegment segment&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case: when the `_receiver_window_size` equals 0</span></span><br><span class="line">    <span class="type">uint64_t</span> window_size = _receiver_window_size == <span class="number">0</span> ? <span class="number">1</span> : _receiver_window_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special case : TCP connection</span></span><br><span class="line">    <span class="keyword">if</span> (_next_seqno == <span class="number">0</span>) &#123;</span><br><span class="line">        segment.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">        _next_seqno += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Find the length to read from the `stream_in()`</span></span><br><span class="line">        <span class="type">uint64_t</span> length =</span><br><span class="line">            std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(window_size - <span class="built_in">bytes_in_flight</span>(), <span class="built_in">stream_in</span>().<span class="built_in">buffer_size</span>()), TCPConfig::MAX_PAYLOAD_SIZE);</span><br><span class="line">        segment.<span class="built_in">payload</span>() = Buffer&#123;std::<span class="built_in">move</span>(<span class="built_in">stream_in</span>().<span class="built_in">read</span>(length))&#125;;</span><br><span class="line">        segment.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">        _next_seqno += length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When the `stream_in` is end of file,  we need to set the `fin` to `true`.</span></span><br><span class="line">        <span class="comment">// Pay attention, we should check whether there is an enough window size</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; <span class="built_in">window_not_full</span>(window_size)) &#123;</span><br><span class="line">            segment.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            end = <span class="literal">true</span>;</span><br><span class="line">            _next_seqno++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We should do nothing</span></span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span> &amp;&amp; !end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segments_out</span>().<span class="built_in">push</span>(segment);</span><br><span class="line">    _outstanding_segments.<span class="built_in">push_back</span>(segment);</span><br><span class="line">    _retransmission_timer.<span class="built_in">start_timer</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window_not_full</span>(window_size)) &#123;</span><br><span class="line">        <span class="built_in">fill_window</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a>ack_received</h3><p>For receiving new acknowledge number from the receiver, which means the <code>ackno</code> is greater than the next sequence number need to be sent. And <code>ackno</code> is less than the current <code>_receiver_ack</code>. We just return.</p><p>And next we need to step by step to check the <code>_outstanding_segments</code>, if the <code>ackno</code> can accept the full segments, we update the <code>_receiver_ack</code> value. If not, we break the loop. Also, we need to update the value of <code>_receiver_window_size</code>. However, there would be a corner case: <em>what if the window size is zero</em>:</p><blockquote><p>If the receiver has announced a window size of zero, the fill window method should act like the window size is one. The sender might end up sending a single byte that gets rejected (and not acknowledged) by the receiver, but this can also provoke the receiver into sending a new acknowledgment segment where it reveals that more space has opened up in its window. Without this, the sender would never learn that it was allowed to start sending again.</p></blockquote><p>And also we should not double the retransmission timeout in this case. So we need to test whether the <code>_receiver_window_size</code> equals to 0 in <code>tick</code> method.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="type">const</span> WrappingInt32 ackno, <span class="type">const</span> <span class="type">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When receiving unneeded ack, just return.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unwrap</span>(ackno, _isn, <span class="built_in">next_seqno_absolute</span>()) &gt; _next_seqno ||</span><br><span class="line">        <span class="built_in">unwrap</span>(ackno, _isn, <span class="built_in">next_seqno_absolute</span>()) &lt; _receiver_ack) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> absolute_ack = <span class="built_in">unwrap</span>(ackno, _isn, <span class="built_in">next_seqno_absolute</span>());</span><br><span class="line">    _receiver_window_size = window_size;</span><br><span class="line">    <span class="type">bool</span> is_ack_update = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = _outstanding_segments.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (iter != _outstanding_segments.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> sequence_num = <span class="built_in">unwrap</span>(iter-&gt;<span class="built_in">header</span>().seqno, _isn, <span class="built_in">next_seqno_absolute</span>());</span><br><span class="line">        <span class="keyword">if</span> (sequence_num + iter-&gt;<span class="built_in">length_in_sequence_space</span>() &lt;= absolute_ack) &#123;</span><br><span class="line">            _receiver_ack = sequence_num + iter-&gt;<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            iter = _outstanding_segments.<span class="built_in">erase</span>(iter);</span><br><span class="line">            is_ack_update = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When there is no outstanding segments, we should stop the timer</span></span><br><span class="line">    <span class="keyword">if</span> (_outstanding_segments.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _retransmission_timer.<span class="built_in">stop_timer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the receiver gives the sender an ackno that acknowledges</span></span><br><span class="line">    <span class="comment">// the successful receipt of new data</span></span><br><span class="line">    <span class="keyword">if</span> (is_ack_update) &#123;</span><br><span class="line">        _retransmission_timer.<span class="built_in">reset_timer</span>();</span><br><span class="line">        _consecutive_retransmissions = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><p><code>tick</code> is easy, because the most important logic we have already implemented:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_retransmission_timer.<span class="built_in">tick_callback</span>(ms_since_last_tick)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_receiver_window_size == <span class="number">0</span>) &#123;</span><br><span class="line">            _retransmission_timer.<span class="built_in">reset_timer</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _retransmission_timer.<span class="built_in">handle_expired</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _consecutive_retransmissions++;</span><br><span class="line">        <span class="built_in">segments_out</span>().<span class="built_in">push</span>(_outstanding_segments.<span class="built_in">front</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="send-empty-segment"><a href="#send-empty-segment" class="headerlink" title="send_empty_segment"></a>send_empty_segment</h3><p>It is easy to implement <code>send_empty_segment</code>. Just change the <code>seq</code> of the segment.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment empty&#123;&#125;;</span><br><span class="line">    empty.<span class="built_in">header</span>().seqno = _isn + _next_seqno;</span><br><span class="line">    <span class="built_in">segments_out</span>().<span class="built_in">push</span>(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 2</title>
      <link href="/2022/11/22/CS144-Introduction-to-Computer-Networking-Lab-2/"/>
      <url>/2022/11/22/CS144-Introduction-to-Computer-Networking-Lab-2/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><p>First, you should read carefully read the docs provided by the lab.</p><blockquote><p>In addition to writing to the incoming stream, the <code>TCPReceiver</code> is responsible for telling the sender two things:</p><ol><li>the index of the “first unassembled” byte which is called the “acknowledgment number”.</li><li>the distance between the “first unassembled” index and the “first unacceptable” index. This is called the “window size “</li></ol></blockquote><p>For these requirements, we have already done in the lab 0 and lab1.</p><h2 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h2><p>In <code>StreamReassembler</code>, each individual datagram has a 64-bit <em>stream index</em> and a 64-bit index is big enough that we can treat it as never overflowing. In the TCP headers, we only have a 32-bit sequence number. So the requirement is below:</p><ul><li><em>Your implementation needs to plan for 32-bit integers to wrap around</em>.</li><li><em>TCP sequence numbers start at a random value</em>.</li><li><em>The logical beginning and ending each occupy one sequence number</em></li></ul><p>The public interface is below:</p><ul><li><code>WrappingInt32 wrap(uint64_t n, WrappingInt32 isn)</code>: give an absolute sequence number and an Initial Sequence Number, produce the relative sequence number for <code>n</code>.</li><li><code>uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint)</code>: Given a sequence number, the Initial Sequence Number, and an absolute checkpoint sequence number, compute the absolute sequence number that corresponds to <code>n</code> that is closes to the checkpoint.</li></ul><p>For <code>wrap</code>, it may seem that we need to round the value. However, the addition of the two unsigned integer would automatically overflow, we could use this feature to gracefully deal with this problem.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Because adding unsigned integer would automatically overflow</span></span><br><span class="line">    <span class="comment">// thus we can utilize this feature to gracefully deal with this problem.</span></span><br><span class="line">    <span class="keyword">return</span> isn + <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For <code>unwrap</code>, we need to find the closest, we just use the overflow of the unsigned again.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="type">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> offset = n.<span class="built_in">raw_value</span>() - <span class="built_in">wrap</span>(checkpoint, isn).<span class="built_in">raw_value</span>();</span><br><span class="line">    <span class="type">uint64_t</span> result = checkpoint + offset;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; (<span class="number">1u</span> &lt;&lt; <span class="number">31</span>) &amp;&amp; result &gt;= (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>))</span><br><span class="line">        result -= (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP-receiver"><a href="#TCP-receiver" class="headerlink" title="TCP receiver"></a>TCP receiver</h2><p>The public interface for <code>TCPReceiver</code> class is:</p><ul><li><code>TCPReceiver(const size_t capacity)</code>: Construct a <code>TCPReceiver</code> that will store up to <code>capacity</code> bytes.</li><li><code>void segment_received(const TCPSegment &amp;seg)</code>: Handle an inbound TCP segment.</li><li><code>sdt::optional&lt;WrappingInt32&gt; ackno() const</code>: The acknowledgment number should be sent to the peer.</li><li><code>size_t window_size() const</code>: The window size that should be sent to the peer.</li><li><code>size_t unassembled_bytes() const</code>: number of bytes stored but not yet reassembled.</li><li><code>ByteStream &amp;stream_out()</code>: Access the reassembled byte stream.</li></ul><p>Well, we need to think what data structure we need when receiving the TCP datagram. First, we need to record the sender’s Initial Sequence Number <code>_sender_isn</code>. Because, we need this to use <code>wrap</code> to calculate the absolute acknowledge number <code>_ack</code>. We just need this two:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPReceiver</span> &#123;</span><br><span class="line">    <span class="comment">//! Our data structure for re-assembling bytes.</span></span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line">    <span class="comment">//! The maximum number of bytes we&#x27;ll store.</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    std::optional&lt;WrappingInt32&gt; _sender_isn&#123;&#125;;  <span class="comment">//! The initial sequence number from the sender</span></span><br><span class="line">    std::optional&lt;WrappingInt32&gt; _ack&#123;&#125;;         <span class="comment">//! The acknowledge number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>From the perspective of receiver, connection is easy. We will receive two datagrams from the sender. The first datagram is important because the <code>SYN</code> bit is set to 1. So we need to handle this case.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Here, we should ensure we set the initial sequence number</span></span><br><span class="line">    <span class="comment">// when we first time receive the SYN.</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">        _sender_isn.<span class="built_in">emplace</span>(seg.<span class="built_in">header</span>().seqno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When we receive the <code>syn</code>, we just set the <code>_sender_isn</code> to the <code>seg.header().seqno</code>. You may wonder why we not set the <code>_ack</code> to be the <code>_sender_sin.value() + 1</code>. The reason is that:</p><blockquote><p>Note that the SYN flag is just one flag in the header. The same segment could also carry data and could even have the FIN flag set.</p></blockquote><p>Before transferring the data, we need to understand how to get the window size, actually, it is super easy. Remember what we have done in the lab 0, yes, there is a method called <code>remaining_capacity</code> which means that the ringBuffer remain size, we use this as the window size. So you could know what we use <code>stream_out().bytes_written()</code> as the acknowledge number.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">stream_out</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _ack; &#125;</span><br></pre></td></tr></table></figure><p>However, this is not the reality. Here, I assume all the operation is not async. However, in kernel, things would be much more complicate.</p><p>So, at now it is easy for us to implement transferring the data. However, there is a corner case, the process of three-way handshake, the ACK should increment, so I use a <em>stupid</em> way to substitute the <code>_sender_isn</code> and <code>_ack</code>. (Please see the comment for more descriptive explanation).</p><p>And how should we close the TCP connection. We just add 1 to <code>_ack</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="type">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Do the operation</span></span><br><span class="line">    <span class="comment">// Pay attention to `stream_out().bytes_written()`, this is one</span></span><br><span class="line">    <span class="comment">// of the most interesting abstraction provided by ByteStream class.</span></span><br><span class="line">    <span class="comment">// When we use `push_substring`, we would push the bytes to ByteStream.</span></span><br><span class="line">    <span class="comment">// Thus, we can get one important idea:</span></span><br><span class="line">    <span class="comment">// stream_out().bytes_written() is always pointing to the</span></span><br><span class="line">    <span class="comment">// absolute current window size start</span></span><br><span class="line">    <span class="keyword">if</span> (_sender_isn.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        _reassembler.<span class="built_in">push_substring</span>(seg.<span class="built_in">payload</span>().<span class="built_in">copy</span>(),</span><br><span class="line">                                    <span class="built_in">unwrap</span>(seg.<span class="built_in">header</span>().seqno, _sender_isn.<span class="built_in">value</span>(), <span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>()),</span><br><span class="line">                                    seg.<span class="built_in">header</span>().fin);</span><br><span class="line">        _ack.<span class="built_in">emplace</span>(<span class="built_in">wrap</span>(<span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>(), _sender_isn.<span class="built_in">value</span>()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When we first accept the SYN, we should pay attention there is no</span></span><br><span class="line">        <span class="comment">// payload, in this situation, `_ack` would be equal to `_isn`. We should</span></span><br><span class="line">        <span class="comment">// avoid this situation.</span></span><br><span class="line">        <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">            _ack.<span class="built_in">emplace</span>(_ack.<span class="built_in">value</span>() + <span class="number">1</span>);</span><br><span class="line">            _sender_isn.<span class="built_in">emplace</span>(_ack.<span class="built_in">value</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only we have initialized the connection and we have made all</span></span><br><span class="line">        <span class="comment">// the bytes written into the ByteStream. We can plus one to `_ack`.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The reason why we should plus one to `_ack` is simple. Because</span></span><br><span class="line">        <span class="comment">// when closing the TCP connection, we receive the sender&#x27;s seq</span></span><br><span class="line">        <span class="comment">// number, because of no payload, our `_ack` is equal to `seg.header().seqno`</span></span><br><span class="line">        <span class="comment">// Don&#x27;t consider the sending, if we need the second FIN from the sender,</span></span><br><span class="line">        <span class="comment">// we should plus one to the `_ack` thus receiving the second FIN.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">            _ack = <span class="built_in">WrappingInt32</span>(_ack.<span class="built_in">value</span>() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 1</title>
      <link href="/2022/11/21/CS144-Introduction-to-Computer-Networking-Lab-1/"/>
      <url>/2022/11/21/CS144-Introduction-to-Computer-Networking-Lab-1/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><p>First, you should carefully read the docs provided by the lab</p><blockquote><p>The TCP sender is dividing its byte stream up into short <em>segments</em> so that they can fit inside a datagram. But the network might reorder these datagrams, or drop them, or deliver them more than once. The receiver must reassemble the segments into the contiguous stream of bytes that they started out as.</p><p>In this lab you’ll write the data structure that will be responsible for this reassembly: a <code>StreamReassembler</code>. It will receive substrings, consisting of a string of bytes, and the index of the first byte of that string within the larger stream. Each byte of the steam has its own unique index, starting from zero and counting upwards. The <code>StreamReassembler</code> will own a ByteStream for the output: as soon as the reassembler knows the next byte of the stream, it will write it into the <code>ByteStream</code>. The owner can access and read from the <code>ByteStream</code> whenever it wants.</p></blockquote><p>And it provides the following public interface:</p><ul><li><code>StreamReassembler(const size_t capacity)</code>: Construct a <code>StreamReassembler</code> that will store up to <code>capacity</code> bytes.</li><li><code>push_substring(const string &amp;data, const size_t index, const bool eof)</code>: Receive a substring and write any newly contiguous bytes into the stream.</li><li><code>ByteStream &amp;stream_out()</code>: Access the reassembled ByteStream (Lab 0)</li><li><code>size_t unaseembled_bytes() const</code>: The number of bytes in the substrings stored but not yet reassembled.</li></ul><p>So, the requirement is obvious. We need to maintain a window. When the datagram comes, we should check whether we should accept the datagram. In order to achieve the functionality, we should consider the following things:</p><ul><li>Indicate the start index of the current window we want to accept.</li><li>The capacity of the window.</li></ul><p>So we need an array to hold the data which I named <code>_stream</code>. And for this array, the logical index is <code>_next_index</code> which means the next index we need. The logical index must exceed the actual length of the <code>stream</code> but we could easily deal with that using <code>_next_index % _capacity</code>. Also, we need a value <code>_unassembly</code> to record the current number of bytes stored but not yet reassembled. And we need a way to know whether the array index is accessed. So maybe hash is a good idea, however, I think here I can only need an array called <code>_dirty</code> to indicate whether the array index is accessed. Simple idea.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamReassembler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ByteStream _output;           <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="type">size_t</span> _capacity;             <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">    <span class="type">size_t</span> _next_index = <span class="number">0</span>;       <span class="comment">//!&lt; The next index we except</span></span><br><span class="line">    <span class="type">size_t</span> _unassembly = <span class="number">0</span>;       <span class="comment">//!&lt; The number of bytes in the substrings stored but not yet reassembled</span></span><br><span class="line">    <span class="type">bool</span> _should_eof = <span class="literal">false</span>;     <span class="comment">//!&lt; Flag about telling ByteStream to end input</span></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; _stream&#123;&#125;;  <span class="comment">//!&lt; The window</span></span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; _dirty&#123;&#125;;   <span class="comment">//!&lt; A table to indicate whether the element is stored</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">next</span><span class="params">(<span class="type">size_t</span> ptr)</span> </span>&#123; <span class="keyword">return</span> (ptr + <span class="number">1</span>) % _capacity; &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>For constructor, it is easy, we should initialize the <code>_capacity</code> and <code>_output</code>, and initialize the <code>_stream</code> and <code>_dirty</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : _output(capacity), _capacity(capacity) &#123;</span><br><span class="line">    _stream.<span class="built_in">resize</span>(capacity, <span class="number">0</span>);</span><br><span class="line">    _dirty.<span class="built_in">resize</span>(capacity, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Easy-Functions"><a href="#Easy-Functions" class="headerlink" title="Easy Functions"></a>Easy Functions</h2><p>There are some extremely easy functions:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_unassembly&#125;; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> &#123;_unassembly == <span class="number">0</span>&#125;; &#125;</span><br></pre></td></tr></table></figure><h2 id="Reassembler"><a href="#Reassembler" class="headerlink" title="Reassembler"></a>Reassembler</h2><p>Now we come to the most interesting part. We should consider the following situations:</p><ul><li>When the data is totally before the <code>_next_index</code>: we should reject.</li><li>When the data is totally after the <code>_next_index + _capacity</code>: we should reject.</li><li>When the data is inside the window: we should store the value to <code>_stream</code>, and sets the corresponding <code>_dirty</code> to <code>true</code>. If we can find continuos range from <code>_next_index</code>, we should write the data to the ByteStream and move the <code>_next_index</code> pointer.</li><li>When the data is partially inside the window: do as above.</li></ul><p>And next we should indicate whether we should signal the ByteStream that the input is end. The <code>push_substring</code> function provides a boolean value <code>eof</code> to indicate this string is the end. However, when should we accept this information. This should be a <em>valid</em> data, which means that we could write the data to the ByteStream. However, pay attention to the corner case: the data could be empty in this situation.</p><p>However, there are some trivial details. You could see the following code with descriptive comments.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="type">const</span> string &amp;data, <span class="type">const</span> <span class="type">size_t</span> index, <span class="type">const</span> <span class="type">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When the string is out of the `_next_index+_capacity` or the end of the string</span></span><br><span class="line">    <span class="comment">// is before the `_next_index`, we should do NOTHING.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= _capacity + _next_index || _next_index &gt; index + data.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we should consider the situation that we should accept part of</span></span><br><span class="line">    <span class="comment">// the string, when `actual_index &lt; _next_index`. We should set the `actual_index`</span></span><br><span class="line">    <span class="comment">// to be the `_next_index` to drop the previous string, and make `data_index`</span></span><br><span class="line">    <span class="comment">// to be the `_next_index-index`.</span></span><br><span class="line">    <span class="type">size_t</span> actual_index = index;</span><br><span class="line">    <span class="type">size_t</span> data_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; _next_index) &#123;</span><br><span class="line">        actual_index = _next_index;</span><br><span class="line">        data_index += _next_index - index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we need to find the start index and loop index</span></span><br><span class="line">    <span class="type">size_t</span> start_index = _next_index % _capacity;</span><br><span class="line">    <span class="type">size_t</span> loop_index = actual_index % _capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corner case: when the data is empty. This is important</span></span><br><span class="line">    <span class="comment">// Because the below iteration does not consider</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">            _should_eof = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here, when `_dirty[index] == false` We store the byte into</span></span><br><span class="line">    <span class="comment">// the `_stream[index]` and set the `_dirty[index]` to be true.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = loop_index, j = data_index; j &lt; data.<span class="built_in">size</span>(); i = <span class="built_in">next</span>(i), j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_dirty[i]) &#123;</span><br><span class="line">            _stream[i] = data[j];</span><br><span class="line">            _unassembly++;</span><br><span class="line">            _dirty[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> == data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">            _should_eof = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">next</span>(i) == start_index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We should calculate consecutive `_dirty[index]` from `_next_index`.</span></span><br><span class="line">    <span class="comment">// Pay attention, you shouldn&#x27;t set the `dirty[index]` to false,</span></span><br><span class="line">    <span class="comment">// because we DO NOT KNOW the ByteStream&#x27;s size, so we</span></span><br><span class="line">    <span class="comment">// need to get the bytes actually written into the `_output`.</span></span><br><span class="line">    string send_str&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = start_index; _dirty[i]; i = <span class="built_in">next</span>(i)) &#123;</span><br><span class="line">        send_str.<span class="built_in">push_back</span>(_stream[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">next</span>(i) == start_index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there is need to send the bytes</span></span><br><span class="line">    <span class="keyword">if</span> (!send_str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">size_t</span> write_num = <span class="built_in">stream_out</span>().<span class="built_in">write</span>(send_str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = start_index, j = <span class="number">0</span>; j &lt; write_num; i = <span class="built_in">next</span>(i), ++j) &#123;</span><br><span class="line">            _dirty[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _next_index += write_num;</span><br><span class="line">        _unassembly -= write_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_should_eof &amp;&amp; <span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">stream_out</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking Lab 0</title>
      <link href="/2022/11/21/CS144-Introduction-to-Computer-Networking-Lab-0/"/>
      <url>/2022/11/21/CS144-Introduction-to-Computer-Networking-Lab-0/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><h2 id="Writing-webget"><a href="#Writing-webget" class="headerlink" title="Writing webget"></a>Writing webget</h2><p>It is easy to write the <code>webget</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    TCPSocket tcpSocket&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">const</span> Address <span class="title">addr</span><span class="params">(host, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> string request = <span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="string">&quot; \r\nConnection: close \r\n\r\n&quot;</span>;</span><br><span class="line">    tcpSocket.<span class="built_in">connect</span>(addr);</span><br><span class="line">    tcpSocket.<span class="built_in">write</span>(request);</span><br><span class="line">    <span class="keyword">while</span> (!tcpSocket.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; tcpSocket.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h2><p>First, you should carefully read the docs provided by the lab. The abstract requirement is below:</p><blockquote><p>Bytes are written on the “input” side and can be read, in the same sequence, from the output “side”. The byte steam is finite: the writer can end the input, and then no bytes can be written. When the reader has read to the end of the stream, it will reach “EOF” and no more bytes can be read.</p><p>Your byte stream will also be flow-controlled to limit its memory consumption at any given time. The object is initialized with a particular “capacity”: the maximum number of bytes it’s willing to store in its own memory at any given point. The byte stream will limit the writer in how much it can write at any given moment, to make sure that the stream doesn’t exceed its storage capacity. As the reader reads bytes and drains them from the stream, the writer is allowed to write more. Your byte stream is for use in a single thread—you don’t have to worry about concurrent writers&#x2F;readers, locking, or race conditions.</p></blockquote><p>The idea I use is simple. I use <code>vector&lt;char&gt;</code> to maintain a RingBuffer. In the class, I use two pointers <code>_write_ptr</code> and <code>read_ptr</code> to indicate the position. And some other fields to make the implementation easier.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _capacity;                   <span class="comment">//!&lt; the capacity of the ByteStream.</span></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; ringBuffer&#123;&#125;;  <span class="comment">//!&lt; the ringBuffer.</span></span><br><span class="line">    <span class="type">size_t</span> _write_ptr = <span class="number">0</span>;           <span class="comment">//!&lt; the write pointer.</span></span><br><span class="line">    <span class="type">size_t</span> _read_ptr = <span class="number">0</span>;            <span class="comment">//!&lt; the read pointer.</span></span><br><span class="line">    <span class="type">size_t</span> _write_bytes_count = <span class="number">0</span>;   <span class="comment">//!&lt; record how many bytes are written.</span></span><br><span class="line">    <span class="type">size_t</span> _read_bytes_count = <span class="number">0</span>;    <span class="comment">//!&lt; record how many bytes are read.</span></span><br><span class="line">    <span class="type">size_t</span> _size = <span class="number">0</span>;                <span class="comment">//!&lt; the current size of the ringBuffer</span></span><br><span class="line">    <span class="type">bool</span> _input_end = <span class="literal">false</span>;         <span class="comment">//!&lt; whether the writing should be end</span></span><br><span class="line">    <span class="type">bool</span> _error = <span class="literal">false</span>;             <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">advance_write</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123; _write_ptr = (_write_ptr + size) % _capacity; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">advance_read</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123; _read_ptr = (_read_ptr + size) % _capacity; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we could go to implementation, the public interface of <code>ByteStream</code> class is below:</p><ul><li><code>ByteStream(const size_t capacity)</code>: Construct a stream with room for <code>capacity</code> bytes.</li><li><code>size_t write(const std::string &amp;data)</code>: Write a string of bytes into the stream. Write as many<br>as will fit, and return how many were written.</li><li><code>size_t remaining_capacity() const</code>: Returns the number of additional bytes that the stream<br>has space for.</li><li><code>void end_input()</code>: Signal that the byte stream has reached its ending.</li><li><code>void set_error()</code>: Indicate that the stream suffered an error.</li><li><code>std::string peek_output(const size_t len) const</code>: Peek at next “len” bytes of the stream.</li><li><code>void pop_output(const size_t len)</code>: Remove bytes from the buffer.</li><li><code>std::string read(const size_t len)</code>: Read the next “len” bytes of the stream.</li><li><code>bool input_ended() const</code>: returns <code>true</code> if the stream input has ended.</li><li><code>bool error() const</code>: returns <code>true</code> if the stream has suffered an error</li><li><code>size_t buffer_size() const</code>: returns the maximum amount that can currently be read<br>from the stream.</li><li><code>bool buffer_empty() const</code>: returns <code>true</code> if the buffer is empty.</li><li><code>bool eof() const</code>: returns <code>true</code> if the output has reached the ending.</li><li><code>size_t bytes_written() const</code>: Total number of bytes written.</li><li><code>size_t bytes_read() const</code>: Total number of bytes popped.</li></ul><p>There are some easy parts we can implement immediately.</p><h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="type">const</span> <span class="type">size_t</span> capacity) : _capacity(capacity) &#123; ringBuffer.<span class="built_in">resize</span>(_capacity); &#125;</span><br></pre></td></tr></table></figure><p>For the constructor, we set the <code>_capacity</code> value and resize the <code>ringBuffer</code> to a fixed size. And we will never change the size of the <code>ringBuffer</code>.</p><h3 id="Setter-and-Getter"><a href="#Setter-and-Getter" class="headerlink" title="Setter and Getter"></a>Setter and Getter</h3><p>There are some easy public interfaces.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span> </span>&#123; _error = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">error</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _error; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _input_end = <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _size; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _size == <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _write_bytes_count; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _read_bytes_count; &#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _size; &#125;</span><br></pre></td></tr></table></figure><h3 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h3><p>The tricky here is when the file will reach the end:</p><ul><li>Input is end.</li><li>The buffer is empty.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">input_ended</span>() &amp;&amp; <span class="built_in">buffer_empty</span>(); &#125;</span><br></pre></td></tr></table></figure><h3 id="Write-Operation"><a href="#Write-Operation" class="headerlink" title="Write Operation"></a>Write Operation</h3><p>It is easy to write. We just first get the maximum length we could write and write the data into the RingBuffer. And we need to do some error handling. When the <code>input_ended()</code> is true, we should not write.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">        <span class="built_in">set_error</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> length = std::<span class="built_in">min</span>(<span class="built_in">remaining_capacity</span>(), data.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        ringBuffer[_write_ptr] = data[i];</span><br><span class="line">        <span class="built_in">advance_write</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _size += length;</span><br><span class="line">    _write_bytes_count += length;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For <code>peek_output</code>, we just copy it to a new <code>string</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::string str&#123;&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> length = std::<span class="built_in">min</span>(len, <span class="built_in">buffer_size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        str.<span class="built_in">push_back</span>(ringBuffer[(i + _read_ptr) % _capacity]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read-Operation"><a href="#Read-Operation" class="headerlink" title="Read Operation"></a>Read Operation</h3><p>We first consider the <code>pop_output</code> operation, we should do nothing about the RingBuffer itself. Just move the <code>_read_ptr</code>, changes the <code>_size</code> and adds the <code>_read_bytes_count</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> length = std::<span class="built_in">min</span>(len, <span class="built_in">buffer_size</span>());</span><br><span class="line">    <span class="built_in">advance_read</span>(length);</span><br><span class="line">    _size -= length;</span><br><span class="line">    _read_bytes_count += length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For <code>read</code>, we should do no error check even if the file is end. If the EOF is true, we just return an empty string. It’s important here because in reality this situation happens!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    std::string str&#123;&#125;;</span><br><span class="line">    str = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144: Introduction to Computer Networking initial source code reading</title>
      <link href="/2022/11/21/CS144-Introduction-to-Computer-Networking-initial-source-code-reading/"/>
      <url>/2022/11/21/CS144-Introduction-to-Computer-Networking-initial-source-code-reading/</url>
      
        <content type="html"><![CDATA[<p>You can get the whole series from <a href="https://luolibrary.com/categories/CS144/">here</a></p><hr><h2 id="File-Descriptor"><a href="#File-Descriptor" class="headerlink" title="File Descriptor"></a>File Descriptor</h2><p>First, the source code uses <code>FileDescriptor</code> class to wrap the file descriptor. The <code>FileDescriptor</code> class first defines a private <code>FDWrapper</code> class, and also defines a private <code>shared_ptr</code> to point to the <code>FDWrapper</code> class. The code has also provided the private constructor to duplicate the <code>FileDescriptor</code>, and a public constructor to accept a <code>const int</code> file descriptor for initialization. Because there is no need to copy or move the <code>FDWrapper</code>, we disable all these operations. And due to the principle of the RAII, we should close the file in the destructor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FDwrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> _fd;</span><br><span class="line">  <span class="type">bool</span> _eof = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> _closed = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">unsigned</span> _read_count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> _read_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FDWrapper</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    _fd = fd;</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;invalid fd number:&quot;</span> + <span class="built_in">to_string</span>(fd));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">FDWrapper</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(_closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> exception &amp;e) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;Exception destructing FDWrapper: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SystemCall</span>(<span class="string">&quot;close&quot;</span>, ::<span class="built_in">close</span>(_fd));</span><br><span class="line">    _eof = _closed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">FDWrapper</span>(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  FDWrapper &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FDWrapper &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">FDWrapper</span>(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">  FDWrapper &amp;<span class="keyword">operator</span>=(FDWrapper &amp;&amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>This code uses <code>SystemCall</code> in <code>util.cc</code>, it just wraps to easily deal with the return value and error handle.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(return_value &gt;= <span class="number">0</span> || errno == errno_mask) &#123;</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">unix_error</span>(attempt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SystemCall</span><span class="params">(<span class="type">const</span> string &amp;attempt, <span class="type">const</span> <span class="type">int</span> return_value, <span class="type">const</span> <span class="type">int</span> errno_mask)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SystemCall</span>(attempt.<span class="built_in">c_str</span>(), return_value errno_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The code defines new exception class <code>unix_error</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">unix_error</span> : <span class="keyword">public</span> tagged_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">unix_error</span><span class="params">(<span class="type">const</span> std::string &amp;attempt, <span class="type">const</span> <span class="type">int</span> error = errno)</span></span></span><br><span class="line"><span class="function">    :tagged_error(std::system_category(), attempt, error)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Well, let’s look at the <code>tagged_error</code>, which just wraps the attempt to make the information of the exception more precise.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">tagged_error</span> : <span class="keyword">public</span> std::system_error &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string _attempt_and_error;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">tagged_error</span>(<span class="type">const</span> std::error_category&amp; category,<span class="type">const</span> std::string &amp;attempt, <span class="type">const</span> <span class="type">int</span> error_code)</span><br><span class="line">    : <span class="built_in">system_error</span>(error_code, category), _attempt_and_error(attempt + <span class="string">&quot;: &quot;</span> + std::system_error::<span class="built_in">what</span>()) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _attempt_and_error.<span class="built_in">c_str</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now we have explained the <code>FDWrapper</code>, the <code>FileDescriptor</code> is easy, and the most operation we will use is to read and write the file, however, we will talk the operation later.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">FDWrapper</span>;</span><br><span class="line">  std::shared_ptr&lt;FDWrapper&gt; _internal_fd;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(std::shared_ptr&lt;FDWrapper&gt; other_shared_ptr)</span> </span>&#123;</span><br><span class="line">    _internal_fd = <span class="built_in">move</span>(other_shared_ptr)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">void</span> <span class="built_in">register_read</span>() &#123;</span><br><span class="line">    ++_internal_fd-&gt;_read_count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">register_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++_internal_fd-&gt;_write_count;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileDescriptor</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd)</span> </span>&#123;</span><br><span class="line">    _internal_fd = <span class="built_in">make_shared</span>&lt;FDWrapper&gt;(fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">FileDescriptor <span class="title">duplicate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FileDescriptor</span>(_internal_fd);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">FileDescriptor</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _internal_fd-&gt;<span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">fd_num</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _internal_fd-&gt;_fd; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _internal_fd-&gt;_eof; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">closed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _internal_fd-&gt;_closed; &#125;</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">read_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _internal_fd-&gt;_read_count; &#125;</span><br><span class="line">  <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">write_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _internal_fd-&gt;_write_count; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FileDescriptor</span>(<span class="type">const</span> FileDescriptor &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    FileDescriptor &amp;<span class="keyword">operator</span>=(<span class="type">const</span> FileDescriptor &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">FileDescriptor</span>(FileDescriptor &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    FileDescriptor &amp;<span class="keyword">operator</span>=(FileDescriptor &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Buf"><a href="#Buf" class="headerlink" title="Buf"></a>Buf</h2><p>It’s important to store a buffer, so the code first defines the basic class <code>Buffer</code>. The <code>Buffer</code> class use <code>string</code> as the buffer, just like <code>FileDescriptor</code>, it will holds a shared ptr to the buffer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;std::string&gt; _storage&#123;&#125;;</span><br><span class="line">  <span class="type">size_t</span> _starting_offset&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Buffer</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Buffer</span>(std::string &amp;&amp;str) <span class="keyword">noexcept</span></span><br><span class="line">    : _storage(std::<span class="built_in">make_shared</span>&lt;std::string&gt;(std::<span class="built_in">move</span>(str))) &#123;&#125;</span><br><span class="line">  <span class="function">std::string_view <span class="title">str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> _storage) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;_storage-&gt;<span class="built_in">data</span>() + _starting_offset, _storage-&gt;<span class="built_in">size</span>() - _starting_offset&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">std::string_view</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">uint8_t</span> <span class="title">at</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>().<span class="built_in">at</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">str</span>().<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">std::string <span class="title">copy</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="built_in">str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="built_in">str</span>().size) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Buffer::remove_prefix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _starting_offset += n;</span><br><span class="line">    <span class="keyword">if</span>(_storage <span class="keyword">and</span> _starting_offset == _storage-&gt;<span class="built_in">size</span>()) &#123;</span><br><span class="line">      _storage.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The <code>Buffer</code> class uses C++17 <code>string_view</code> to substitute the <code>const string</code> to avoid unnecessary copy, <code>string_view</code> don’t do any copy operation, it just points to the same memory. However, in order to manage the buffers, the code defines <code>BufferList</code> class. It is easy to understand.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BufferList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::deque&lt;Buffer&gt; _buffers&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BufferList</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">BufferList</span>(Buffer buffer) : _buffers&#123;buffer&#125; &#123;&#125;</span><br><span class="line">  <span class="built_in">BufferList</span>(std::string &amp;&amp;str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    Buffer buf&#123;std::<span class="built_in">move</span>(str)&#125;;</span><br><span class="line">    <span class="built_in">append</span>(buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::deque&lt;Buffer&gt; &amp;<span class="title">buffers</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _buffers;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> BufferList &amp;other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; buf: other._buffers) &#123;</span><br><span class="line">      _buffers.<span class="built_in">push_back</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">Buffer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> _buffers[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;</span></span><br><span class="line"><span class="string">                BufferList: please use concatenate() to combine a multi-Buffer BufferList into one Buffer&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::string <span class="title">concatenate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::string ret;</span><br><span class="line">    ret.<span class="built_in">reserve</span>(<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;buf : _buffers) &#123;</span><br><span class="line">      ret.<span class="built_in">append</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; buf: _buffers) &#123;</span><br><span class="line">      ret += buf.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(_buffers.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;BufferList::remove_prefix&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(n &lt; _buffers.<span class="built_in">front</span>().<span class="built_in">size</span>()) &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n -= _buffers.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line">        _buffers.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Now we have <code>BufferList</code>, sometimes we just want to view the buffer content, so we utilize the c++17 <code>string_view</code> to make a <code>BufferViewList</code> class.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BufferViewList</span> &#123;</span><br><span class="line">  std::deque&lt;std::string_view&gt; _views&#123;&#125;;</span><br><span class="line">  <span class="built_in">BufferViewList</span>(<span class="type">const</span> std::string &amp;str) : <span class="built_in">BufferViewList</span>(std::<span class="built_in">string_view</span>(str)) &#123;&#125;</span><br><span class="line">  <span class="built_in">BufferViewList</span>(<span class="type">const</span> <span class="type">char</span> *s) : <span class="built_in">BufferViewList</span>(std::<span class="built_in">string_view</span>(s)) &#123;&#125;</span><br><span class="line">  <span class="built_in">BufferViewList</span>(std::string_view str) &#123; _views.<span class="built_in">push_back</span>(&#123;<span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(str.<span class="built_in">data</span>()), str.<span class="built_in">size</span>()&#125;); &#125;</span><br><span class="line">  <span class="built_in">BufferViewList</span>(<span class="type">const</span> BufferList &amp;buffers) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;x : buffers.<span class="built_in">buffers</span>()) &#123;</span><br><span class="line">      _views.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_views.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;BufferListView::remove_prefix&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(n &lt; _views.<span class="built_in">front</span>().<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _views.<span class="built_in">front</span>().<span class="built_in">remove_prefix</span>(n);</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n -= _views.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line">        _views.<span class="built_in">pop_front</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; buf: _views) &#123;</span><br><span class="line">        ret += buf.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Here, I omit <code>as_iovecs</code> function. Later for it.</p><h2 id="Reading-and-Writing-File"><a href="#Reading-and-Writing-File" class="headerlink" title="Reading and Writing File"></a>Reading and Writing File</h2><p>We have talked about the source code of the buffer, it’s time to find how <code>FileDescriptor</code> to read and write files. Well, actually, it is not complicated.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(std::string &amp;str, <span class="type">const</span> <span class="type">size_t</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> BUFFER_SIZE = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size_to_read = <span class="built_in">min</span>(BUFFER_SIZE, limit);</span><br><span class="line">    str.<span class="built_in">resize</span>(size_to_read);</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> bytes_read = <span class="built_in">SystemCall</span>(<span class="string">&quot;read&quot;</span>, ::<span class="built_in">read</span>(<span class="built_in">fd_num</span>(), str.<span class="built_in">data</span>(), size_to_read));</span><br><span class="line">    <span class="keyword">if</span>(limit &gt; <span class="number">0</span> &amp;&amp; bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">      _internal_fd-&gt;_eof = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bytes_read &gt; <span class="built_in">static_cast</span>&lt;<span class="type">ssize_t</span>&gt;(size_to_read)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;read() read more than requested&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    str.<span class="built_in">resize</span>(bytes_read);</span><br><span class="line">    <span class="built_in">register_read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::string <span class="title">read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> limit = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::max())</span> </span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="built_in">read</span>(ret, limit);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>For <code>read</code> operation, it is easy. The most important thing is that the class provides user allocation string or string allocated by class. The encapsulation is wonderful.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileDescriptor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(BufferViewList buffer, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> total_ bytes_written = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> iovecs = buffer.<span class="built_in">as_iovecs</span>();</span><br><span class="line">      <span class="type">const</span> <span class="type">ssize_t</span> bytes_written = <span class="built_in">SystemCall</span>(<span class="string">&quot;writev&quot;</span>, ::<span class="built_in">writev</span>(<span class="built_in">fd_num</span>(), iovecs.<span class="built_in">data</span>(), iovecs.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(bytes_written == <span class="number">0</span> <span class="keyword">and</span> buffer.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;write returned 0 given non-empty input buffer&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(bytes_written &gt; <span class="built_in">ssize_t</span>(buffer.<span class="built_in">size</span>())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;write wrote more than length of input buffer&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">register_write</span>();</span><br><span class="line">      buffer.<span class="built_in">remove_prefix</span>(bytes_written);</span><br><span class="line">      total_bytes_written += bytes_written;</span><br><span class="line">    &#125;<span class="keyword">while</span> (write_all <span class="keyword">and</span> buffer.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_bytes_written;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string &amp;str, <span class="type">const</span> <span class="type">bool</span> write_all = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">write</span>(<span class="built_in">BufferViewList</span>(str), write_all);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>From the code above, we have known that for <code>string</code> and <code>c-string</code>, we all convert them into the <code>BufferViewList</code> class. Now, we don’t consider how <code>BufferViewList::as_iovecs()</code> works. First, we look at the <code>iovec</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> &#123;</span><br><span class="line">  <span class="type">ptr_t</span> iov_base;</span><br><span class="line">  <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So we could make an array of <code>iovec</code> for system call <code>writev</code>. Now let’s what <code>BufferViewList::as_iovecs()</code> does:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;iovec&gt; <span class="title">BufferViewList::as_iovecs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  vector&lt;iovec&gt; ret;</span><br><span class="line">  ret.<span class="built_in">reserve</span>(_views.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x : _views) &#123;</span><br><span class="line">    ret.<span class="built_in">push_back</span>(&#123;<span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(x.<span class="built_in">data</span>()), x.<span class="built_in">size</span>()&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Well, it converts the <code>_views</code> to be a vector of the <code>struct iovec</code>. What a beautiful abstraction!</p><h2 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h2><p>Well, for <code>Address</code> class, the content is tedious. Because it does the wrapper for the system call. And it is not difficult to understand.</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>Well, I think the most interesting part is the <code>EventLoop</code> class, which waits for events on file descriptors and executing callbacks.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">Direction</span>: <span class="type">short</span> &#123;</span><br><span class="line">    In = POLLIN,</span><br><span class="line">    Out = POLLOUT</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">using</span> CallbackT = std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt;;</span><br><span class="line">  <span class="keyword">using</span> InterestT = std::function&lt;<span class="built_in">bool</span>(<span class="type">void</span>)&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Rule</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    FileDescriptor fd;</span><br><span class="line">    Direction direction;</span><br><span class="line">    CallbackT callback;</span><br><span class="line">    InterestT interest;</span><br><span class="line">    CallbackT cancel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">service_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> direction == Direction::In ? fd.<span class="built_in">read_count</span>() : fd.<span class="built_in">write_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::list&lt;Rule&gt; _rules&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>At this time, we have known that EventLoop abstracts the <code>Rule</code> class, which holds the activity.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    Success,</span><br><span class="line">    Timeout,</span><br><span class="line">    Exit</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_rule</span><span class="params">(<span class="type">const</span> FileDescriptor &amp;fd,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> Direction direction,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> CallbackT &amp;callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> InterestT &amp;interest = [] &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> CallbackT &amp;cancel = [] &#123;&#125;)</span> </span>&#123;</span><br><span class="line">    _rules.<span class="built_in">push_back</span>(&#123;fd.<span class="built_in">duplicate</span>(), direction, callback, interest, cancel&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Well, the logic is simple, when we want to do a new activity, we add a new rule.</p><p>How should we do the loop? Well, this is the multiplexing I&#x2F;O, the code use <code>poll</code> to deal with that, first, it creates the <code>vector&lt;pollfd&gt;</code> to wrap the array of the <code>pollfd</code>. How we process the event loop, the idea is simple, we just iterate the <code>_rules</code>:</p><ul><li>When the event is done, we delete it from the <code>list&lt;_rules&gt;</code>.</li><li>When the event’s file descriptor is closed, we do the above.</li><li>When event’s <code>interest()</code> is true, add it to the <code>vector&lt;pollfd&gt;</code>.</li></ul><p>Now we use system call <code>poll</code> to do I&#x2F;O. Then process the I&#x2F;O result.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop::Result <span class="title">EventLoop::wait_next_event</span><span class="params">(<span class="type">const</span> <span class="type">int</span> timeout_ms)</span> </span>&#123;</span><br><span class="line">  vector&lt;pollfd&gt; pollfds&#123;&#125;;</span><br><span class="line">  pollfds.<span class="built_in">reserve</span>(_rules.<span class="built_in">size</span>());</span><br><span class="line">  <span class="type">bool</span> something_to_poll = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> it = _rules.<span class="built_in">cbegin</span>(); it != _rules.<span class="built_in">cend</span>();) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;this_rule = *it;</span><br><span class="line">    <span class="keyword">if</span> (this_rule.direction == Direction::In &amp;&amp; this_rule.fd.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">      this_rule.<span class="built_in">cancel</span>();</span><br><span class="line">      it = _rules.<span class="built_in">erase</span>(it);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(this_rule.fd.<span class="built_in">closed</span>()) &#123;</span><br><span class="line">      this_rule.<span class="built_in">cancel</span>();</span><br><span class="line">      it = _rules.<span class="built_in">erase</span>(it);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (this_rule.<span class="built_in">interest</span>()) &#123;</span><br><span class="line">      pollfds.<span class="built_in">push_back</span>(&#123;this_rule.fd.<span class="built_in">fd_num</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">short</span>&gt;(this_rule.direction), <span class="number">0</span>&#125;);</span><br><span class="line">        something_to_poll = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pollfds.<span class="built_in">push_back</span>(&#123;this_rule.fd.<span class="built_in">fd_num</span>(), <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> something_to_poll) &#123;</span><br><span class="line">      <span class="keyword">return</span> Result::Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">SystemCall</span>(<span class="string">&quot;poll&quot;</span>, ::<span class="built_in">poll</span>(pollfds.<span class="built_in">data</span>(), pollfds.<span class="built_in">size</span>(), timeout_ms))) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result::Timeout;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (unix_error <span class="type">const</span> &amp;e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.<span class="built_in">code</span>().<span class="built_in">value</span>() == EINTR) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result::Exit;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the polling</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Well, <code>Socket</code> is also a file descriptor, but there are many more details. But I don’t think it is meaningful to talk about the source code. Because file descriptor is a wonderful wrapper which contains the most trivial part.</p>]]></content>
      
      
      <categories>
          
          <category> CS144 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes client-go 源码解析——WorkQueue</title>
      <link href="/2022/11/14/Kubernetes-client-go-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94WorkQueue/"/>
      <url>/2022/11/14/Kubernetes-client-go-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94WorkQueue/</url>
      
        <content type="html"><![CDATA[<p>WorkQueue称为工作队列，支持如下的特性：</p><ul><li>有序：按照添加顺序处理元素</li><li>去重：相同元素在同一时间不会被重复处理，例如一个元素在处理之前被添加了多次，它只会被处理一次。</li><li>并发性：多生产者与多消费者。</li><li>标记机制：支持标记功能，标记一个元素是否被处理，也允许元素在处理时重新排队。</li><li>通知机制：<code>ShutDown</code>方法通过信号量通知队列不再接收新的元素，并通过<code>metric goroutine</code>退出。</li><li>延迟：支持延迟队列，延迟一段时间后再将元素存入队列。</li><li>限速：支持限速队列，元素存入队列时进行速率限制。限制一个元素被重新排队的次数。</li><li>Metric：支持metric监控指标，可用于Prometheus监控。</li></ul><p>WorkQueue支持3种队列，并提供了3种接口，不同队列实现可应对不同的使用场景：</p><ul><li><code>Interface</code>：FIFO队列接口，支持去重机制。</li><li><code>DelayingInterface</code>：延迟队列接口，基于<code>Interface</code>封装，延迟一段时间后再将元素存入队列。</li><li><code>RateLimitingInterface</code>：限速队列接口，基于<code>DelayingInterface</code>封装，支持元素存入队列时进行速率限制。</li></ul><h2 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h2><p>此部分代码实现位于<code>util/workqueue/queue.go</code>中。首先，client-go定义了一个<code>Type</code>类型作为FIFO队列的数据结构实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">struct</span> &#123;</span><br><span class="line">  queue []t</span><br><span class="line">  dirty set</span><br><span class="line">  processing set</span><br><span class="line">  cond *sync.Cond</span><br><span class="line">  shuttingDown <span class="type">bool</span></span><br><span class="line">  drain <span class="type">bool</span></span><br><span class="line">  metrics queueMetrics</span><br><span class="line">  unfinishedWorkUpdatePeriod time.Duration</span><br><span class="line">  clock clock.WithTicker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些重要字段的含义如下：</p><ul><li><code>queue</code>：包含按照顺序需要处理的事件。类型<code>t</code>只是一个别名<code>type t interface&#123;&#125;</code>。其本质的目的在于用于保证元素的有序。</li><li><code>dirty</code>：包含所有需要处理的事件，按照这个定义所有在<code>queue</code>的事件必然在<code>dirty</code>中。类型<code>set</code>也是一个别名 <code>type set map[t]empty</code>，<code>empty</code>也是一个别名，<code>type empty struct&#123;&#125;</code>。既保证了去重，还能保证在处理一个元素之前哪怕其被添加了多次，但也只会被处理一次。</li><li><code>processing</code>：包含正在处理的事件。<code>dirty</code>也可能包含某些<code>processing</code>中的事件。</li><li><code>cond</code>：条件变量。</li><li><code>shuttingDown</code>：是否关闭队列。</li><li><code>drain</code>：关闭队列时是否立即消耗完仍然存在的元素。</li><li><code>metrics</code>：指标接口，定义在<code>util/workqueue/metrics.go</code>。</li><li><code>unfinishedWorkUpdatePeriod</code>：每次时钟更新的时间，用于初始化时钟。</li><li><code>clock</code>：时钟。</li></ul><p>然后，client-go定义了用于FIFO队列的接口<code>Interface</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">  Add(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  Len() <span class="type">int</span></span><br><span class="line">  Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>)</span><br><span class="line">  Done(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  ShutDown()</span><br><span class="line">  ShutDownWithDrain()</span><br><span class="line">  ShuttingDown() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Add</code>：给队列添加元素。</li><li><code>Len</code>：返回当前队列的长度。</li><li><code>Get</code>：获取队列头部的一个元素。</li><li><code>Done</code>：标记队列中该元素已被处理。</li><li><code>ShutDown</code>：关闭队列。</li><li><code>ShutDownWithDrain</code>：关闭队列并立即处理完在<code>processing</code>中的元素。</li><li><code>ShuttingDown</code>：查询队列是否正在关闭。</li></ul><p>为了更好地理解FIFO队列，我们首先对两个场景进行描述。一个场景是无并发环境，一个是存在并发的环境。</p><p>场景一：通过<code>Add</code>方法往FIFO队列中分别插入1、2、3三个元素，此时队列中的<code>queue</code>和<code>dirty</code>字段分别存有1、2、3元素，<code>processing</code>字段为空。元素1被放入<code>processing</code>字段，表示该元素正在被处理。最后，当处理完1元素时，通过<code>Done</code>方法标记该元素已经处理完成，此时队列中的<code>processing</code>字段中的1元素会被删除。</p><p><img src="https://s2.loli.net/2022/07/19/s5NhxylkIJX2CUm.png" alt="FIFO无并发场景下存储过程"></p><p>场景二：在并发场景下，假设goroutine A通过<code>Get</code>方法获取1元素，1元素此时被添加到<code>processing</code>字段中，同一时间，goroutine B通过<code>Add</code>方法插入另一个元素，由于<code>processing</code>已经有元素1，故不会存入<code>queue</code>中而是存入<code>dirty</code>中。当元素1处理完成后，则将1元素追加到<code>queue</code>字段中的尾部。</p><p><img src="https://s2.loli.net/2022/07/19/ypdvTi47Um1Vwfn.png" alt="FIFO并发场景下存储过程"></p><h3 id="队列初始化及其生命周期"><a href="#队列初始化及其生命周期" class="headerlink" title="队列初始化及其生命周期"></a>队列初始化及其生命周期</h3><p><code>queue.go</code>首先定义了一个辅助函数<code>updateUnfinishedWorkLoop</code>用于对整个队列的生命周期进行管理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> updateUnfinishedWorkLoop() &#123;</span><br><span class="line">  t := q.clock.NewTicker(q.unfinishedWorkUpdatePeriod)</span><br><span class="line">  <span class="keyword">defer</span> t.Stop()</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">range</span> t.C() &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      q.cond.L.Lock()</span><br><span class="line">      <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">      <span class="keyword">if</span> !q.shuttingDown &#123;</span><br><span class="line">        q.metrics.updateUnfinishedWork()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;() &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法利用<code>for range t.C()</code>，每隔<code>q.unfinishedWorkUpdatePeriod</code>秒，都会判断队列是否被关闭，如果队列没有被关闭，则返回<code>true</code>，继续执行循环。如果队列被关闭，则直接返回<code>false</code>，然后退出循环，结束函数执行。</p><p>然后是对其进行初始化。首先定义了一个基本的<code>New</code>函数。然后层层抽象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Type &#123;</span><br><span class="line">  <span class="keyword">return</span> NewNamed(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNamed</span><span class="params">(name <span class="type">string</span>)</span></span> *Type &#123;</span><br><span class="line">  rc := clock.RealClock&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> newQueue(</span><br><span class="line">    rc,</span><br><span class="line">    globalMetricsFactory.newQueueMetrics(name, rc),</span><br><span class="line">    defaultUnfinishedWorkUpdatePeriod,</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>defaultUnfinishedWorkUpdatePeriod</code>只是一个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultUnfinishedWorkUpdatePeriod = <span class="number">500</span> * time.Millisecond</span><br></pre></td></tr></table></figure><p>然后就是最关键的就是<code>newQueue</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newQueue</span><span class="params">(c clock.WithTicker, metrics queueMetrics,updatePeriod time.Duration)</span></span> *Type &#123;</span><br><span class="line">  t := &amp;Type&#123;</span><br><span class="line">    clock: c,</span><br><span class="line">    dirty: set&#123;&#125;,</span><br><span class="line">    processing: set&#123;&#125;,</span><br><span class="line">    cond: sync.NewCond(&amp;sync.Mutex&#123;&#125;),</span><br><span class="line">    metrics: metrics,</span><br><span class="line">    unfinishedWorkUpdatePeriod: updatePeriod,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _, ok := metrics.(noMetrics); !ok &#123;</span><br><span class="line">    <span class="keyword">go</span> t.updateUnfinishedWorkLoop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，当定义了一个FIFO队列后，<code>updateUnfinishedWorkLoop</code>将会一直运行然后每隔一定的时间检测队列的<code>shuttingDown</code>的值。可见，利用该值作为信号来传递。</p><h3 id="set方法定义"><a href="#set方法定义" class="headerlink" title="set方法定义"></a>set方法定义</h3><p>为了更加方便地对<code>set</code>，即<code>map[t]empty</code>类型进行操作。<code>queue.go</code>定义了一系列方法简化，把基本的<code>map</code>方法封装了一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> has(item t) <span class="type">bool</span>&#123;</span><br><span class="line">  _, exists := s[item]</span><br><span class="line">  <span class="keyword">return</span> exists</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> insert(item t) &#123;</span><br><span class="line">  s[item] = empty&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> <span class="built_in">delete</span>(item t) &#123;</span><br><span class="line">  <span class="built_in">delete</span>(s, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s set)</span></span> <span class="built_in">len</span>() <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type方法定义"><a href="#Type方法定义" class="headerlink" title="Type方法定义"></a>Type方法定义</h3><p>首先是实现<code>Interface</code>的<code>Add</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Add(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">if</span> q.shuttingDown &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q.metrics.add(item)</span><br><span class="line"></span><br><span class="line">  q.dirty.insert(item)</span><br><span class="line">  <span class="keyword">if</span> q.processing.has(item) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">  q.cond.Signal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保持互斥首先需要上锁，然后判断队列是否已经被关闭。如果没有被关闭，首先添加到<code>dirty</code>中，然后判断<code>item</code>是否位于<code>processing</code>中，如果没有添加到<code>queue</code>中。然后释放信号用于同步。这是一个典型的生产者与消费者的问题。生产者是<code>Add</code>方法，消费者是<code>Get</code>方法。</p><p>同样实现<code>Interface</code>的<code>Len</code>方法。很简单，加个锁即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(q.queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现<code>Interface</code>的<code>Get</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Get() (item <span class="keyword">interface</span>&#123;&#125;, shutdown <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &amp;&amp; !q.shuttingDown &#123;</span><br><span class="line">    q.cond.Wait()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  item = q.queue[<span class="number">0</span>]</span><br><span class="line">  q.queue[<span class="number">0</span>] = <span class="literal">nil</span></span><br><span class="line">  q.queue = q.queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">  q.metrics.get(item)</span><br><span class="line"></span><br><span class="line">  q.processing.insert(item)</span><br><span class="line">  q.dirty.<span class="built_in">delete</span>(item)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> item, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>Get</code>方法作为一个消费者当队列为空时，应该等待故调用了<code>q.cond.Wait</code>。然后取出第一个元素，置<code>queue[0]</code>为空以便进行垃圾回收，插入到<code>processing</code>中，然后从<code>dirty</code>中删除。</p><p><code>Done</code>方法用于告知队列该元素已被处理，如果该元素存在<code>dirty</code>中，我们需要将其重新加入到<code>queue</code>中来处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> Done(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  q.metrics.done(item)</span><br><span class="line"></span><br><span class="line">  q.processing.<span class="built_in">delete</span>(item)</span><br><span class="line">  <span class="keyword">if</span> q.dirty.has(item) &#123;</span><br><span class="line">    q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> q.processing.<span class="built_in">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ShutDown</code>方法让队列忽略所有需要新增的item然后立即告知worker goroutine退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q* Type)</span></span> ShutDown() &#123;</span><br><span class="line">  q.setDrain(<span class="literal">false</span>)</span><br><span class="line">  q.shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了两个辅助函数<code>setDrain</code>和<code>shutdown</code>进行抽象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q* Type)</span></span> setDrain(shouldDrain <span class="type">bool</span>) &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  q.drain = shouldDrain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q* Type)</span></span> shutdown() &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  q.shuttingDown = <span class="literal">true</span></span><br><span class="line">  q.cond.Broadcast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>q.cond.Broadcast</code>的使用，尽管关闭了队列，但我们仍然可以使用<code>Get</code>方法去获取元素。可能此时<code>q.queue</code>有元素或者没有，但我们必须使用避免阻塞了其他函数。</p><p>然后<code>queue.go</code>定义了<code>ShutDownWithDrain</code>关闭队列并立即处理<code>q.queue</code>中的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> ShutDownWithDrain() &#123;</span><br><span class="line">  q.setDrain(<span class="literal">true</span>)</span><br><span class="line">  q.shutdown()</span><br><span class="line">  <span class="keyword">for</span> q.isProcessing() &amp;&amp; q.shouldDrain() &#123;</span><br><span class="line">    q.waitForProcessing()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> isProcessing() <span class="type">bool</span> &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">return</span> q.processing.<span class="built_in">len</span>() != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> shouldDrain() <span class="type">bool</span> &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">  <span class="keyword">return</span> q.drain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Type)</span></span> waitForProcessing() &#123;</span><br><span class="line">  q.cond.L.Lock()</span><br><span class="line">  <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> q.processing.<span class="built_in">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.cond.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步机制总结"><a href="#同步机制总结" class="headerlink" title="同步机制总结"></a>同步机制总结</h3><p>在FIFO队列中，存在许多同步的东西，总结如下：</p><ul><li>基本的生产者-消费者模型。<code>Add</code>方法需要调用<code>q.cond.Signal</code>通知等待的<code>Get</code>方法。<code>Done</code>方法可能也会添加新的item。故如果新增了新的item，也需要调用<code>q.cond.Signal</code>通知等待的<code>Get</code>方法。</li><li><code>Done</code>方法在<code>q.processing.len() == 0</code>时也会调用<code>q.cond.Signal</code>实现同步，这是因为<code>ShutDownWithDrain</code>方法会调用<code>waitForProcessing</code>然后再调用<code>q.cond.Wait</code>阻塞自身。显然对于<code>drain</code>来说，开发者必须对每个方法item调用<code>Done</code>方法，以便在<code>q.processing</code>的长度为0时，唤醒<code>ShutDownWithDrain</code>方法。</li></ul><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p>指标定义在<code>metrics.go</code>中，可以看见我们在处理item的时候，也会对其的指标进行操作，由于该部分不是核心代码，此处不进行分析。</p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>此部分代码定义在<code>util/workqueue/delaying_queue.go</code>中。延迟队列基于FIFO队列接口封装，在原有的功能上增加了<code>AddAfter</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DelayingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  Interface</span><br><span class="line">  AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先看延迟队列的<code>AddAfter</code>方法是如何实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *delayingType)</span></span> AddAfter(item <span class="keyword">interface</span>&#123;&#125;, duration time.Duration) &#123;</span><br><span class="line">  <span class="keyword">if</span> q.ShuttingDown() &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  q.metrics.retry()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> duration &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    q.Add(item)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-q.stopCh:</span><br><span class="line">    <span class="keyword">case</span> q.waitingForAddCh &lt;- &amp;waitFor&#123;data: item, readyAt: q.clock.Now().Add(duration)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这个函数就做了一个极其简单的事情，当<code>duration</code>小于0时，直接加入队列中。</p><p>我们首先需要看<code>delayingType</code>这个类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> delayingType <span class="keyword">struct</span> &#123;</span><br><span class="line">  Interface</span><br><span class="line">  clock           clock.Clock</span><br><span class="line">  stopCh          <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  stopOnce        sync.Once</span><br><span class="line">  heartbeat       clock.Ticker</span><br><span class="line">  waitingForAddCh <span class="keyword">chan</span>* waitFor</span><br><span class="line">  metrics         retryMetrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些重要的字段含义如下：</p><ul><li><code>stopCh</code>：利用channel作信号量。</li><li><code>stopOnce</code>：只能Stop一次。</li><li><code>waitingForAddCh</code>：用来存储待加入的<code>item</code>。</li></ul><p>其中<code>waitFor</code>的类型定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitFor <span class="keyword">struct</span> &#123;</span><br><span class="line">  data    t</span><br><span class="line">  readyAt time.Time</span><br><span class="line">  index   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码维护了一个优先队列<code>waitForPriorityQueue</code>，其本质的思路在于实现<code>heap</code>的接口，内容比较简单，此处忽略细节。</p><p><code>newDelayingQueue</code>函数创建了一个新的延迟队列，然后启用<code>waitingLoop</code> goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDelayingQueue</span><span class="params">(clock clock.WithTicker, q Interface, name <span class="type">string</span>)</span></span> *delayingType &#123;</span><br><span class="line">  ret := &amp;delayingType&#123;</span><br><span class="line">    Interface:       q,</span><br><span class="line">    clock:           clock,</span><br><span class="line">    heartbeat:       clock.NewTicker(maxWait),</span><br><span class="line">    stopCh:          <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    waitingForAddCh: <span class="built_in">make</span>(<span class="keyword">chan</span> *waitFor, <span class="number">1000</span>),</span><br><span class="line">    metrics:         newRetryMetrics(name),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> ret.waitingLoop()</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitingLoop</code>是延迟队列实现的核心所在。其本质的思路仍然是实现同步，此处忽略细节。</p><h2 id="限速队列"><a href="#限速队列" class="headerlink" title="限速队列"></a>限速队列</h2><p>限速队列在延迟队列接口的基础上增加了<code>AddRateLimited</code>, <code>Forget</code>, <code>NumRequeues</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RateLimitingInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">  DelayingInterface</span><br><span class="line"></span><br><span class="line">  AddRateLimited(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这三个方法都是调用<code>RateLimiter</code>的接口方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> RateLimiter <span class="keyword">interface</span> &#123;</span><br><span class="line">  When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration</span><br><span class="line"></span><br><span class="line">  Forget(item <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>When</code>：获取指定元素应该等待的时间。</li><li><code>Forget</code>：释放指定元素。</li><li><code>NumRequeues</code>：返回元素的失败数。</li></ul><p>WorkQueue提供了4种限速算法：</p><ul><li>令牌桶算法：下节单独介绍</li><li>排队指数算法：将相同元素的排队数作为指数，排队数增大，速率限制呈指数级增长。</li><li>计数器算法：限制一段时间内允许通过的元素数量。</li><li>混合模式</li></ul><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>client-go使用<a href="https://en.wikipedia.org/wiki/Token_bucket">令牌桶</a>作为限流算法。</p><h3 id="Limiter数据结构定义"><a href="#Limiter数据结构定义" class="headerlink" title="Limiter数据结构定义"></a>Limiter数据结构定义</h3><p>Go语言标准库提供了令牌桶算法的实现。首先在<code>rate.go</code>中定义了<code>Limiter</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Limiter <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu     sync.Mutex</span><br><span class="line">  limit  Limit</span><br><span class="line">  burst  <span class="type">int</span></span><br><span class="line">  tokens <span class="type">float64</span></span><br><span class="line">  last time.Time</span><br><span class="line">  lastEvent time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Limit</code>仅仅只是一个类型Wrapper：<code>type Limit float64</code>。字段的含义如下：</p><ul><li><code>mu</code>：互斥锁</li><li><code>limit</code>：每秒下发令牌的个数</li><li><code>burst</code>：桶的最大令牌数量</li><li><code>tokens</code>：当前令牌数量</li><li><code>last</code>：最后一次<code>tokens</code>字段更新时间</li><li><code>lastEvent</code>：最近一次限流事件发生的时间</li></ul><p>目前<code>limit</code>的定义为每秒下发令牌的个数，故<code>rate.go</code>定义了<code>Every</code>函数将事件之间的最小时间间隔转换为<code>Limit</code>。当<code>limit = Inf</code>时，<code>burst</code>可以被忽略，允许任何事件通过，因为下发令牌的个数是无限的。同时，<code>limit</code>也可以为0，代表不允许任何事件通过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Every</span><span class="params">(interval time.Duration)</span></span> Limit &#123;</span><br><span class="line">  <span class="keyword">if</span> interval &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Inf</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> / Limit(interval.Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rate.go</code>定义了一些基本的getter和setter方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> lim.Limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span> &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> lim.burst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Limiter&#123;</span><br><span class="line">    limit: r,</span><br><span class="line">    burst: b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>为了更加好的抽象，<code>rate.go</code>定义了一系列的辅助函数。根据令牌桶的概念我们可以知道，随着时间的变化，令牌桶中的令牌数量会增加。故为了实现时间间隔和令牌桶的令牌数量相互的转化，<code>rate.go</code>定义了<code>tokensFromDuration</code>和<code>durationFromTokens</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个时间段会产生多少个令牌</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limit Limit)</span></span> tokensFromDuration(d time.Duration) <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> limit &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d.Seconds() * <span class="type">float64</span>(limit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前令牌桶中的令牌代表了多少时间段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(limit Limit)</span></span> durationFromTokens(tokens <span class="type">float64</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> limit &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> InfDuration</span><br><span class="line">  &#125;</span><br><span class="line">  seconds := tokens / <span class="type">float64</span>(limit)</span><br><span class="line">  <span class="keyword">return</span> time.Duration(<span class="type">float64</span>(time.Second) * seconds)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着时间的变化，需要对令牌桶中的令牌也就是<code>token</code>进行更新，故定义了<code>advance</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> advance(now time.Time) (newNow time.Time, newLast time.Time, newTokens <span class="type">float64</span>) &#123;</span><br><span class="line">  last := lim.last</span><br><span class="line">  <span class="keyword">if</span> now.Before(last) &#123;</span><br><span class="line">    last = now</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  elapsed := now.Sub(last)</span><br><span class="line">  delta := lim.limit.tokensFromDuration(elapsed)</span><br><span class="line">  tokens := lim.tokens + delta</span><br><span class="line">  <span class="keyword">if</span> burst := <span class="type">float64</span>(lim.burst); tokens &gt; burst &#123;</span><br><span class="line">    tokens = burst</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> now, last, tokens</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Limiter还包含一些setter方法，介绍了辅助函数后，对于这些setter方法就比较容易理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit) &#123;</span><br><span class="line">  lim.SetLimitAt(time.Now(), newLimit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit) &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  now, _, tokens := lim.advance(now)</span><br><span class="line"></span><br><span class="line">  lim.last = now</span><br><span class="line">  lim.tokens = tokens</span><br><span class="line">  lim.limit = newLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>) &#123;</span><br><span class="line">  lim.SetBurstAt(time.Now(), newBurst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetBurstAt sets a new burst size for the limiter.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>) &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  now, _, tokens := lim.advance(now)</span><br><span class="line"></span><br><span class="line">  lim.last = now</span><br><span class="line">  lim.tokens = tokens</span><br><span class="line">  lim.burst = newBurst</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Limiter主要有三个方法：<code>Allow</code>, <code>Reserve</code>和<code>Wait</code>。这三个方法在被调用时，都会消耗掉一个令牌。这三个方法分别被<code>AllowN</code>，<code>ReserveN</code>以及<code>WaitN</code>抽象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.AllowN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.ReserveN(time.Now(), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.WaitN(ctx, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>rate.go</code>定义了<code>Reservation</code>数据结构，包含了已经被限流器所允许的事件的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reservation <span class="keyword">struct</span> &#123;</span><br><span class="line">  ok        <span class="type">bool</span></span><br><span class="line">  lim       *Limiter</span><br><span class="line">  tokens    <span class="type">int</span></span><br><span class="line">  timeToAct time.Time</span><br><span class="line">  limit Limit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段的含义如下：</p><ul><li><code>ok</code>：表示事件能否发生</li><li><code>lim</code>: 属于哪个Limiter</li><li><code>tokens</code>：表示该事件需要消耗的令牌数量</li><li><code>timeToAct</code>：执行的时间</li><li><code>limit</code>：在<code>Reserve</code>操作的时候定义</li></ul><p>我们首先看函数<code>AllowN</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> lim.reserveN(now, n, <span class="number">0</span>).ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看函数<code>ReserveN</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation &#123;</span><br><span class="line">  r := lim.reserveN(now, n, InfDuration)</span><br><span class="line">  <span class="keyword">return</span> &amp;r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>AllowN</code>和<code>ReserveN</code>都是通过<code>reserveN</code>进行抽象的。首先<code>reserveN</code>处理特殊情况，即<code>limit = Inf</code>（允许任何事件通过）和<code>limit = 0</code>（不允许任何事件通过），虽然不允许任何事件通过，但是本身令牌桶初始化時有<code>burst</code>个令牌数，故还是可以允许通过<code>burst</code>个令牌。</p><p>再处理完特殊情况后，首先通过<code>advance</code>计算出现在时刻的令牌桶中的令牌数量的个数，减去该事件所消耗的令牌个数。当令牌数小于0证明该事件需要等待，故通过<code>durationFromTokens</code>计算需要等待的时间。</p><p>其次，判断事件能否发生。事件能发生需要满足两个条件，一是事件发生消耗的令牌数量不能超过令牌桶最大的令牌数量，二是等待时间不能超过参数<code>maxFutureReserve</code>的值。</p><p>后面的操作就是更新字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> reserveN(now time.Time, n <span class="type">int</span>, maxFutureReserve time.Duration) Reservation &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> lim.limit = Inf &#123;</span><br><span class="line">    <span class="keyword">return</span> Reservation&#123;</span><br><span class="line">      ok:        <span class="literal">true</span>,</span><br><span class="line">      lim:       lim,</span><br><span class="line">      tokens:    n,</span><br><span class="line">      timeToAct: now,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> lim.limit == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">    <span class="keyword">if</span> lim.burst &gt;= n &#123;</span><br><span class="line">      ok = <span class="literal">true</span></span><br><span class="line">      lim.burst -= n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Reservation&#123;</span><br><span class="line">      ok:        <span class="literal">true</span>,</span><br><span class="line">      lim:       lim,</span><br><span class="line">      tokens:    lim.burst,</span><br><span class="line">      timeToAct: now,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  now, last, tokens := lim.advance(now)</span><br><span class="line"></span><br><span class="line">  tokens -= <span class="type">float64</span>(n)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> waitDuration time.Duration</span><br><span class="line">  <span class="keyword">if</span> tokens &lt; <span class="number">0</span> &#123;</span><br><span class="line">    waitDuration = lim.limit.durationFromTokens(-tokens)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ok := n &lt;= lim.burst &amp;&amp; waitDuration &lt;= maxFutureReserve</span><br><span class="line"></span><br><span class="line">  r := Reservation&#123;</span><br><span class="line">    ok:    ok,</span><br><span class="line">    lim:   lim,</span><br><span class="line">    limit: lim.limit,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    r.tokens = n</span><br><span class="line">    r.timeToAct = now.Add(waitDuration)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    lim.last = now</span><br><span class="line">    lim.tokens = tokens</span><br><span class="line">    lim.lastEvent = r.timeToAct</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lim.last = last</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>reserveN</code>作为一个核心的函数，无非就是查询令牌桶中的令牌数量足不足以支持一个消耗<code>n</code>个令牌的任务，为了维持这个任务的状态必须定义一个数据结构来维持。</p><p>在讲<code>WaitN</code>函数之前，我们先看看<code>DelayFrom</code>函数，这个函数很简单，对于已经ok的任务，得到其延迟发生的时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> DelayFrom(now time.Time) time.Duration &#123;</span><br><span class="line">  <span class="keyword">if</span> !r.ok &#123;</span><br><span class="line">    <span class="keyword">return</span> InfDuration</span><br><span class="line">  &#125;</span><br><span class="line">  delay := r.timeToAct.Sub(now)</span><br><span class="line">  <span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delay</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以去看<code>WaitN</code>函数，很显然对于一个任务来说，其可以通过调用<code>WaitN</code>来实现限流。</p><ul><li>当所需的令牌数目大于令牌桶所能包含的最大令牌，直接返回error。</li><li>如果在调用时，任务已经结束了，直接返回error。</li><li>计算<code>waitLimit</code>其值为任务结束的时间和现在的时间的差值，然后使用<code>reserveN</code>得到任务的状态。</li><li>然后使用<code>DelayFrom</code>计算需要延迟的时间，如果有必要延迟的话，通过一个定时器来延时。如果定时器完成了，就继续。如果定时器结束之前，<code>Context</code>被取消了，返回错误。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">  lim.mu.Lock()</span><br><span class="line">  burst := lim.burst</span><br><span class="line">  limit := lim.limit</span><br><span class="line">  lim.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> n &gt; burst &amp;&amp; limit != Inf &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;rate: Wait(n=%d) exceeds limiter&#x27;s burst %d&quot;</span>, n, burst)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    <span class="keyword">return</span> ctx.Err()</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  now := time.Now()</span><br><span class="line">  waitLimit := InfDuration</span><br><span class="line">  <span class="keyword">if</span> deadline, ok := ctx.Deadline(); ok &#123;</span><br><span class="line">    waitLimit = deadline.Sub(now)</span><br><span class="line">  &#125;</span><br><span class="line">  r := lim.reserveN(now, n, waitLimit)</span><br><span class="line">  <span class="keyword">if</span> !r.ok &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;rate: Wait(n=%d) would exceed context deadline&quot;</span>, n)</span><br><span class="line">  &#125;</span><br><span class="line">  delay := r.DelayFrom(now)</span><br><span class="line">  <span class="keyword">if</span> delay == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  t := time.NewTimer(delay)</span><br><span class="line">  <span class="keyword">defer</span> t.Stop()</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    r.Cancel()</span><br><span class="line">    <span class="keyword">return</span> ctx.Err()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>r.Cancel()</code>的使用，既然我们已经给了令牌给一个任务而这个任务并没有实际的执行，我们应该还给令牌桶相应的数目。由于此时已经介绍了大部分的函数，此处忽略其细节。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>令牌桶的实现与时间有很大的关系，看似需要每隔1s就需要更新令牌桶中的令牌数目，实则上是完全没有必要的。因为可以从未来借。当每一次调用主要方法时，都会通过现在的时间减去上一次令牌桶数目更新的时间来更新令牌桶中的令牌数目，令牌桶中的令牌数目是负的也根本无所谓，很棒的设计。</p><h3 id="Client-go封装"><a href="#Client-go封装" class="headerlink" title="Client-go封装"></a>Client-go封装</h3><p>Client-go在<code>util/workqueue/default_rate_limiters.go</code>中定义了<code>BucketRateLimiter</code>用于封装标准库中的<code>Limiter</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BucketRateLimiter <span class="keyword">struct</span> &#123;</span><br><span class="line">  *rate.Limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span></span> When(item <span class="keyword">interface</span>&#123;&#125;) time.Duration &#123;</span><br><span class="line">  <span class="keyword">return</span> r.Limiter.Reserve().Delay()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span></span> NumRequeues(item <span class="keyword">interface</span>&#123;&#125;) <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *BucketRateLimiter)</span></span> Forget(item <span class="keyword">interface</span>&#123;&#125;) &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rewrite(罚抄)</title>
      <link href="/2022/11/08/Rewrite-%E7%BD%9A%E6%8A%84/"/>
      <url>/2022/11/08/Rewrite-%E7%BD%9A%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这是我第二次玩完Rewrite这部作品了。每一次游玩的时候我都十分喜欢其中的日常。这篇感想主要还是想记录一下自己对于人物塑造以及田中式孤独的一些看法还有文章的主旨。</p><h3 id="角色塑造"><a href="#角色塑造" class="headerlink" title="角色塑造"></a>角色塑造</h3><p>角色塑造的话我只想讨论小鸟和千早，至于朱音线说实在的，我认为这是田中很有意思的一个想法，探讨的东西有很多，就忽略了。静流的话不是很喜欢，露西娅就别提了。</p><h4 id="小鸟"><a href="#小鸟" class="headerlink" title="小鸟"></a>小鸟</h4><p>Rewrite塑造的最好的女性角色就是小鸟，田中从共通线开始就在塑造着小鸟，她没有朋友，总是在森林。游戏的一开始就是小鸟的母亲让男主寻找小鸟，实际上这本身就是小鸟渴望着理解，想缓解一下自身的寂寞。</p><p>小鸟曾经被男主告白过，在小鸟的心里她对男主的看法是极为复杂的。她认为男主是自己创造的魔物，但是瑚太朗却按照自己内心的想法而活。在小鸟线中，小鸟对瑚太朗的原话：“原本的瑚太朗君说不定已经不在了”。在整个世界线中，男主遇见小鸟的时候，年龄差距是很大的。男主那个时候算不上温柔，而男主被小鸟救了后，却性格大变。从小鸟的角度来看，她已经觉得瑚太朗是被她改造过的。而本身小鸟也处于把自己过世的父母变成了魔物的悔恨中。</p><p>小鸟被赋予了权利，同时也承担了责任，她不得不背上守护“键”的重担。然而瑚太朗什么也做不了，就如同月球只能围绕着月球旋转一样。这种无力的孤独感是我个人认为在小鸟线中塑造的极其精彩的氛围。面对盖亚和守护者的两大势力，小鸟和瑚太朗几乎什么也做不了。</p><p>这条线最有张力的就是小鸟的父母为了保护两人拿起了枪战斗，似乎在这一刻他们从魔物变成了人。小鸟一直在逃避着这个事实，不愿意接受父母的死亡。因为她总是孤身一人。同时，她也逃避这自己承担的责任，因为在超自研的日常中她感受到了温暖，感受到了人与人之间的联系。</p><p>让我欣慰的就是在这条线上小鸟终于完成了自己的心愿，能够和瑚太朗逛一逛收获祭。</p><h4 id="千早"><a href="#千早" class="headerlink" title="千早"></a>千早</h4><p>在千早线中，我很喜欢瑚太朗的想法，他并不属于任何一个阵营，他只为了千早而战。这是我很喜欢的一条线，我并不认为小小的幸福就不能追求，相反由于个体的弱小，往往我们只能守护住着小小的幸福。</p><p>千早和瑚太朗两个人在超自研活动室的时候，仍然怀念着过去的日常。怀念着大家都在的超自研。瑚太朗是由衷地希望盖亚和守护者的冲突能够结束，而他能够和千早一起在收获祭里面享受节日的乐趣。</p><p>我觉得这就足矣，无论是加入盖亚还是守护者都无法得到所谓的答案，只会被势力所利用为了势力自身的利益。</p><h3 id="盖亚与守护者"><a href="#盖亚与守护者" class="headerlink" title="盖亚与守护者"></a>盖亚与守护者</h3><p>实际上，这两个阵营的塑造在我看来远没有那么简单。本质上，盖亚和守护者都是在逃避问题，盖亚希望通过“键”的救济来一了百了，认为这是星球的意志，阻挡也没有必要。而守护者认为要维护人的权利，不能剥夺其他人的生存权，所以要杀死“键”阻止救济。盖亚是典型的消极主义，而守护者本质也是在回避，因为星球的救济是必然的。显然，两个阵营从来没有思考过能否合作解决问题，能否通过技术的手段让人类面对星球的救济后仍然能够生存下来，即思考人类未来的可能性。</p><p>游戏中通过你想要改变世界还是自我这两个选项来区分到底是去盖亚阵营还是守护者阵营。实际上在朱音线中，田中通过朱音的话是给出了自己的解释的。面对不满，信奉盖亚的人觉得光凭自己的力量无法改变而守护者选择通过强化自身。这是对待世界的两种完成不同的方式。</p><p>显然，大多人可能会对守护者抱有好感，实际上，比起盖亚来说，我更讨厌守护者这个阵营。守护者这个阵营总是抱有对强者的崇拜，对因为他们是通过对自己的改变的，会天然地对弱势的人歧视。而盖亚却能够接纳在这个世界上无法生存的人，让他们或多或少能够在这个社会上立足，然而盖亚也利用他们这种绝望的心情来接受星球所谓的救济。说白了，两个组织都是一路货色罢了。</p><p>这就如同在现实生活中的世界一样，我们也被这些组织玩弄着。</p><h3 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h3><p>在所有女主的个人线里面（除了露西娅），瑚太朗都无不怀念他在超自研的日常生活。瑚太朗也是为了前进。为了和他人取得联系，才会去努力地创建超自研。我每次看到瑚太朗怀念日常的心理描写，我从来不觉得无病呻吟。正如同在Cross Channel中说的一样，回忆是一个很重要的东西。</p><h3 id="开拓的精神"><a href="#开拓的精神" class="headerlink" title="开拓的精神"></a>开拓的精神</h3><p>田中借Moon和Terra描述了一个极其重要的道理，人们应舍弃理念的斗争，通过公开技术的方式，哪怕要舍弃小小的幸福，也应该要开拓。实际上这就是Rewrite这部作品立意极高的地方。我们人类因为理念在内斗，表面上希望能够合作实际都是为了利益而勾心斗角罢了。</p><p>田中倒是思考了人类未来的前进方法，抛弃理念的斗争，共享开放才是唯一的出路。然而在现在这个时代，我只觉得越发不可能。本应开放的互联网却如同高墙一般阻碍着你我，星球怎么可能充满美好的回忆呢？</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Rewrite是一部很棒的作品，至少充满了温暖。田中至少努力地去探索了人类应该如何前进的答案，虽然可能理由还是不够充分，想的还是简单了。但总归温柔且浪漫地给了我们一个答案。</p><h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><h3 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h3><blockquote><p>有一天，察觉到自己一无所有。</p><p>发现本以为堆满着幸福的口袋，其实空无一物。</p><p>因为我没为在口袋里塞些什么而努力，所以是理所当然的。</p><p>而我，却连这种事都想不明白。</p><p>因为我的人生至今散漫并且没有意义。</p><p>然而某天，我觉查到自己白白浪费了许多时间。</p><p>我跟谁都能说得上话。无论是怎么样的人。</p><p>可是我没有好朋友。一个都没有。</p><p>这究竟意味这什么，我从未思考过。</p><p>我的人生，一直平淡乏味。</p><p>曾经的青梅竹马神户小鸟，才是唯一可毫无顾忌聊天的朋友。</p><p>没错。</p><p>……朋友，曾经是。</p><p>(……重新来一次)</p><p>(而且，要做得更好)</p><p>深切的愿望。</p><p>但是，这十分困难。</p><p>所有人都为了它而辛苦。</p><p>没人能够无所事事却变得幸福。</p><p>只能一步一步的靠自己的力量想幸福迈进。</p><p>幸福究竟是什么呢？</p><p>跟青春相似的东西吗？那青春又是何物？</p><p>“是耀眼的东西吧。”小鸟这样说。</p><p>“……天知道，根本没有仔细想过”吉野丢下这句话。</p><p>很久之前，有人说过那是“人生走钢丝”。</p><p>三个人的意见，我认为都是正确的。</p><p>耀眼、未知、并且令人恐惧的东西。</p><p>这问题很难，因为没有限定的答案。</p><p>但我决定要踏上寻找它的旅途。</p><p>只是，时间无情地流逝。</p><p>夏去秋至，时间如水。</p><p>转眼间，已经高中二年级了。</p><p>焦急了。</p><p>如今我手中依然空无一物。</p><p>而我依然找不到任何应该做的事。</p><p>仅仅没有目标的徘徊着。</p></blockquote><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote><p>她没有可以一起玩的朋友，</p><p>一直都是一个人。</p><p>在镇子里撒欢夜游什么的，</p><p>和小鸟无缘。</p><p>她一直只在森林里玩。</p><p>…那可能是，有点寂寞的事情吧。</p></blockquote><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote><p>瑚太朗：果然人与人之间，还是有所谓波长的合与不合的。</p><p>小鸟：似乎能明白你说的。</p><p>瑚太朗：交朋友的话，容易接触，不属于任何群体的家伙就很不错。</p></blockquote><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote><p>随随便便交换邮件地址实在是太轻率了，在一个个阶段交好继而又马上断交的友人关系，有什么意义么？</p><p>但抱有这种想法的话，连获得真正友人的可能性也一并舍弃了。</p><p>并不是无所事事任时间流逝，而是怀着坚强的意志活着。</p><p>藉此，人生收获良多。</p><p>如果没有那种决意呢？</p><p>那么人际关系就很重要了。</p><p>与各种各样的人相遇、交谈、学习、欢笑，进一步…</p></blockquote><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><blockquote><p>瑚太朗：凤为什么会在这个时期过来这边呢？</p><p>千早：哈、哈？那个…</p><p>千早：这个时期，刚好非常适合。</p><p>瑚太朗：哈？</p><p>千早：夏天太热冬天太冷。</p><p>瑚太朗：嘛，对于搬家作业来说可能确实是不错的时期…</p><p>因为那种马马虎虎的理由转学，这算什么嘛。</p><p>瑚太朗：父母他们呢，说来，他们就没反对转校么？</p><p>住得远的话，一般坐电车上学就可以了吧。</p><p>千早：…没反对。</p><p>瑚太朗：诶～</p><p>又是个自由的家族。</p><p>千早：为什么要问那些事呢？</p><p>瑚太朗：哎呀，不是很普通么？问搬家的理由啊、双亲的工作啊什么的？</p><p>千早：…很普通么？</p><p>瑚太朗：大概吧。</p><p>千早：那…</p><p>千早：搬家的理由是，对搬家来说这时候正好。</p><p>瑚太朗：…真自由。</p><p>千早：很自由的。</p><p>瑚太朗：那，双亲工作呢。</p><p>千早：双亲的话，没有工作。</p><p>瑚太朗：哈？</p><p>千早：因为没有双亲。</p><p>瑚太朗：………</p><p>听到不好的事了。</p><p>千早：…就那个意义来说，我确实是“自由的”呢。</p><p>瑚太朗：啊啊…</p><p>“自由”。就肯定意义而言，是没有自由的人都会羡慕的词语。</p><p>但千早所说的“自由”，是任谁都不会羡慕的“自由”。</p><p>名为孤独的自由。</p><p>瑚太朗：那样啊…</p><p>千早：干、干嘛气氛搞得那么低落。</p><p>瑚太朗：没，总觉得自己问了不该问的。</p><p>千早：问的这些都很普通吧，所以很普通的。</p><p>瑚太朗：听到的内容却不普通。</p><p>千早：…对我来说很普通</p><p>瑚太朗：是么？</p><p>普通到底是什么呢，对谁来说是普通的呢？</p><p>也许对我、对大多数人来说普通的事物，也会有觉得不普通的人存在。</p><p>…那不是非常少根筋么？</p></blockquote><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><blockquote><p>朱音：你到底是外界干涉者呢，还是自我改革者呢。</p><p>瑚太朗：外界？自我？</p><p>朱音：想想前人们说过的话吧。</p><p>朱音：是具有改变世界方向的资质呢，还是具有强化自我方面的性质呢。</p><p>瑚太朗：不是很明白你在说什么？</p><p>朱音：现在不去在意也是可以的，总有一天会明白的，一定、恐怕、或许</p><p>朱音：如果什么都不具备的话，那对你来说也应该是求之不得的事吧。</p></blockquote><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><blockquote><p>吉野：既然拥有…这种程度的力量…你小子却…!</p><p>瑚太朗：力量是什么？</p><p>瑚太朗：我从这种东西里头，看不到哪怕一丁点的价值…！</p><p>瑚太朗：比起那种东西，我更想认真地活着。</p><p>瑚太朗：用力量来定义活法这到底是想怎样啊。</p><p>瑚太朗：特别的家伙将其力量全开的话…为什么后来就变成孤高地活着了啊！</p><p>瑚太朗：那种事情，非常让人困扰啊！</p><p>瑚太朗：别随随便便决定他人的活法啊～！</p></blockquote><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><blockquote><p>总感觉自己也慢慢改变了…</p><p>不知为什么，但就是这么认为。</p><p>想到了之前会长出的那张调查问卷。</p><p>那里反映了我真实的想法。</p><p>并非是对改变感到了恐惧，而是在如今并未定下明确目标的时候，对接踵而来的变化感到了些许不安。</p></blockquote><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><blockquote><p>绿的话，应该只给人好的印象。</p><p>应该是干净、美丽、了不起的、好的东西。</p><p>直到现在，我都隐隐约约那么觉得。</p><p>但绿其实不是那样的东西。</p><p>不知哪来的某人把本该完成的修整工作怠慢了的话，就会变成这样。</p></blockquote><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><blockquote><p>我对人工绿化表示怀疑。</p><p>从这些并未真正绿色的东西中，我感受到欺骗的意味。</p><p>但现在，我打心底觉得…..</p><p>虚假的绿化，对人类来说也是必要的。</p><p>不干净的绿，人类是无法忍受的。</p><p>然后最起码在风祭，那些干净的绿还是有的。</p><p>森林里没有虫子。不允许有。</p><p>肯定是谁，用药、或者别的什么，朝里面注入了什么东西吧。</p><p>瑚太朗：假如是在森林里生活，应该不太可能过干净的生活吧。</p><p>小鸟：那是因为，生命就是如此呐。</p><p>小鸟：所谓生命，就是又脏、又臭、令人毛骨悚然的东西哦。</p><p>小鸟：但是呐，人类这种东西一旦过过好日子，就再也不想回到贫困的生活了。</p><p>小鸟：生命也是如此。一旦整洁过一次，就再也不想变回成原始的乱七八糟的生命了。总觉得就是那样…</p><p>瑚太朗：总是在考虑那些事吗？</p><p>小鸟：“习惯小小的幸福就ok了”的意思哦。</p><p>瑚太朗：我是打算适应这样的生活的。因为自己没什么大的奢望。</p></blockquote><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><blockquote><p>街道中弥漫着如往常一样的热闹气氛。</p><p>伴随着收获祭的临近，应该会变得更加热闹吧。</p><p>瑚太朗：总觉得</p><p>小鸟：嗯？</p><p>瑚太朗：我们，都变了呢。</p><p>小鸟：什么意思？</p><p>瑚太朗：最近，姑且试着尽自己所能地努力了下…</p><p>瑚太朗：与那努力相应，干得还算不错，也碰上些让我称心如意的事…</p><p>瑚太朗：但是，为什么呢。总觉得在某个地方，好像有东西被破坏了一样。</p><p>小鸟：…</p><p>瑚太朗：有时候还会觉得不安呢。</p><p>小鸟：我觉得，大家或多或少，都会有那种想法的哦。</p><p>小鸟：瑚太朗君呢，因为生病，再加上各种各样辛酸的经历…所以才会有那种想法吧。</p><p>瑚太朗：嗯，或许是那样呐。</p><p>瑚太朗：虽然我完全不记得自己曾经进过医院…</p><p>小鸟：但是时间的流逝是不会停止的。</p><p>小鸟：所以才会无意识地，想要取回以前的时间，不是吗？</p><p>瑚太朗：像这样隐瞒一些事，也许并不好吧，我这家伙。</p><p>小鸟：那就错了哦。谁都会隐瞒一些事的哟。</p><p>小鸟：就算是我，也会有很多的秘密哦？</p><p>瑚太朗：哈哈。反正，都只是些让人发笑的秘密吧。</p><p>瑚太朗：在体重上做几公斤手脚之类的。</p><p>小鸟：那也不错呢。</p><p>瑚太朗：如果你说的秘密都是那些东西的话，倒也蛮可爱的哦。</p><p>小鸟：想成为一个可爱的女人呢。</p><p>瑚太朗：但是我…</p><p>我的记忆却模糊不清。</p><p>一旦回忆过去，就会变成这样。</p><p>瑚太朗：呐，我啊…到底是患了什么病呢…</p><p>小鸟：什么病呢。一种名字很难读的病。</p><p>小鸟：但现在已经治好了，放心吧。</p><p>瑚太朗：放心…吗…</p><p>小鸟：放心放心～</p><p>小鸟：所以乐观点活下去吧。同时获得你想要的东西。</p><p>小鸟：这也是正当的权力呐。</p><p>总觉得小鸟的话中流露出了一丝寂寞。</p></blockquote><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><blockquote><p>随着时间的渐渐流逝，人也变得越来越多。</p><p>这次是看上去像大学生的一伙人。</p><p>老奶奶也开始话唠了。</p><p>傍晚，看起来像社会人的西服革履的人也开始造访了。</p><p>来这里的人，以在这里有过回忆的人们的总数而言，恐怕只是很小的一部分吧。</p><p>…但即便如此</p><p>瑚太朗：…也还是来了这么多人呐。</p><p>不明白为什么，只是单纯的很高兴。</p><p>人们聚在一起，真的是很高兴。</p><p>如此想着。</p><p>大家都各随己愿地任凭时间流逝。</p><p>把点心塞满嘴巴的人。</p><p>大概是小时候买不起玩具之类的东西吧，现在则一个劲地摆弄着的人。</p><p>用和以前不同花纹的面牌，一决胜负的人。</p><p>大家都一样，不停地谈着过去和现在的自己。</p><p>…</p><p>以前的小孩子已经完全变成了大人，然而在这里又一瞬间变回了小孩。</p><p>这里就是那种地方啊。</p><p>肯定，如果没有这样的机会的话，一般是不会过来的吧。</p><p>…可是，“这样的机会”，已经是最后一次了。</p><p>老奶奶只是，慈祥地看着那个场面。</p></blockquote><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><blockquote><p>超自然现象是实际存在的，大概。</p><p>由于知性的兴奋，我感到脖子附近的汗毛都立了起来。</p></blockquote><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><blockquote><p>然后，我脑中被突然闪回的记忆占据了。</p><p>强烈的记忆之浊流，化作暴力，冲击着我。</p><p>视觉情报独占了视网膜。</p><p>某个集会场所。</p><p>和双亲的争吵。</p><p>好几个大人。</p><p>江坂宗源。</p></blockquote><h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><blockquote><p>？：求你了…</p><p>？：无论如何，都求求你了…</p><p>？：请帮帮我吧…</p><p>？：求你了…</p><p>？：我会向你发誓的…</p><p>？：所以…请你…</p><p>？：救救他…！</p><p>？：我会…说出誓言的…</p><p>？：只要天空不坠落下来，我会一直服务于你…</p><p>？：所以…救救他。</p></blockquote><h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><blockquote><p>是原超自研的活动室啊。</p><p>…那些快乐的日子，在感觉中就好像是遥远过去的事情了呢。</p><p>但是那已经一去不复返了。</p><p>一直这么耿耿于怀也没啥用。</p><p>所以要展望未来。</p><p>不回首。不叹息。</p><p>“那时已经过得很愉快了”，要这样积极地去想。</p><p>这样的话，总有一天可以将失去的遗憾变成美好的回忆。</p><p>但是，话说回来，我当初为什么想着要建立超自研啊？</p><p>到底是为了谁而创办的社团活动啊？</p><p>那是为了将其当作回忆来保存，不可或缺的信息。</p><p>但是它缺失了。</p><p>完全没可能会忘记的东西，不知为何却斑驳地从我的记忆领域中剥落了。</p></blockquote><h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><blockquote><p>总觉得自己想哭。</p><p>肯定不是因为害怕。</p><p>而是其他的理由。</p><p>我一直，都觉得我觉察到了那家伙的本质。</p><p>时不时的会变得粗暴，但那实际上是一种令人欣赏的率直。</p><p>所以…我才想要和他做朋友。</p><p>结果就是这样了。</p><p>我没有被自己真正喜欢的人所喜欢。一直都是这样。</p><p>瑚太朗：应该道谢的…是我才对…</p><p>班主任：诶？</p><p>瑚太朗：向吉野…向那家伙…</p><p>瑚太朗：那家伙和小鸟还有我，看起来离得很远，但是确实联系在一起的…</p><p>瑚太朗：在我心中，三个人是一个铁三角…也就是说，三人一直这样就好了…我是这么希望的。</p><p>瑚太朗：虽然我嘴上说为了被孤立的小鸟。</p><p>瑚太朗：但是呐，其实是为了我自己。</p><p>瑚太朗：打着小鸟的旗号，来缓解自己的欲望。</p><p>瑚太朗：到头来，我就是把小鸟…看成是到路边的石头一样…</p><p>瑚太朗：即便是现在，我心中重要的部分也是在被麻痹着…</p><p>瑚太朗：到底为什么会发生，这样的事呢…人的心，会这样的…</p><p>瑚太朗：我的心，会这样腐烂下去的呢…</p></blockquote><h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><blockquote><p>瑚太朗：因为我…最初…就觉得…那家伙和我还有小鸟…是能够很好地相处的啊。</p><p>瑚太朗：一个人的话是孤独，两个人在一起的话是妥协，但是三个人的话…</p><p>瑚太朗：有3个人的话，就可以相互称作是“大家”了啊。</p><p>瑚太朗：这个，肯定就能被成为是人际圈子了。</p><p>瑚太朗：我希望能够成为，“大家”之一。</p><p>瑚太朗：因为，那对于想在什么地方找到自己归属的人来说…是一种救赎啊。</p><p>瑚太朗：所以人才想要归属于什么地方，想要成为别人的家人，想要成为团体中的一员。</p><p>瑚太朗：每个人都是为了成为某个组织的成员，而生活着的。</p><p>不知不觉中我哭了起来。</p><p>在同班同学的面前，不觉得羞耻地、不顾及面子地、毫无要领地哭着。</p><p>…真不像样啊。</p><p>瑚太朗：我们之间，距离很远。</p><p>瑚太朗：就像吉野说的那样，从上面看的话挨得很近，但是从侧面看高度却不同。</p><p>瑚太朗：之所以相互离对方很近，感觉上很远就是这个原因了。</p><p>瑚太朗：因为人们，都站在不同的高度上。</p><p>瑚太朗：我前段时间受了打击…虽然不清楚具体是怎么回事，但是我好像失去了和小鸟之间的回忆了。</p><p>瑚太朗：现在也是这样…明明那些珍贵的事情就在我心里，却感觉不到实感。</p><p>瑚太朗：太渣了啊，我…</p></blockquote><h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><blockquote><p>“键”不是以对话为目的而制造的存在。</p><p>不是为了跟人类进行思想沟通而出现的东西。</p></blockquote><h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><blockquote><p>对那样可怜的小鸟，我应该说些什么话好呢。</p><p>想不出什么好的说话方式。</p><p>小鸟试图一个人承担一切。</p><p>我却没有能力去支持她。</p><p>虽然我急切希望能够帮忙，但是力量却不足。</p><p>也没有时间让我去进步的吧。</p><p>事态已经急迫到就算是着急也没用的程度了。</p><p>（我到底是什么呢？）</p><p>难道仅仅是飘在周围咕噜咕噜地转着的存在吗。</p><p>就好像月球。</p><p>在地球周围转动的卫星。</p><p>啊啊，真的就像月亮那样呢。</p><p>我想回身抱住她。</p><p>但是我却做不到。</p><p>就像现在的我和小鸟之间的，永远无法相互进一步接近的关系那样。</p><p>月球也是永远用同一面在面对着地球转动的。</p><p>我能够面对小鸟的，是不是也只有这背后的一面呢。</p><p>不能够直接传达感情，不能尽力做想做的事情的情况一个接一个的出现。</p><p>第一次听到的小鸟哭泣声，从耳边划过。</p><p>小鸟：已经，不管怎么努力都做不到了啊……</p><p>小鸟：已经晚了啊…!</p></blockquote><h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><blockquote><p>我感到浑身似乎汗毛竖立。</p><p>身体在颤抖。</p><p>愤怒、欢喜、悲叹。</p><p>哪种感情都有，但又存在着与哪种感情都不同的，巨大的感情的波涛。</p><p>我的感情一直被小鸟避开，被避而不谈。</p><p>我告白的时候也是。</p><p>就是是温柔的气氛充盈我俩之间的时候也是。</p><p>小鸟刻意避免获得任何重要的东西。</p><p>她在害怕。</p><p>不知道哪天，所谓的“使命”就会把她人生的全部东西都吞噬掉，小鸟一直在害怕着这个。</p><p>所以一直让自己保持着什么“不爱上任何人和事”的状态。</p><p>她从这里逃开了。</p><p>不去和任何人有所深交。</p><p>但是她怎么能否定得了呢？</p><p>对于我来说，小鸟是毫无疑问的值得去“爱”的存在。</p><p>我认为想要变得冷漠，但是却失败了的小鸟的人生，是需要我的爱怜的。</p></blockquote><h3 id="21"><a href="#21" class="headerlink" title="21"></a>21</h3><blockquote><p>小鸟：跟父亲他们不同，瑚太朗君也会说话，也能凭自己意志做出判断。</p><p>小鸟：但是…我无法肯定…这到底是不是因为我自己的愿望而产生的效果…</p><p>小鸟：说不定是我无意识地操纵呢。</p><p>小鸟：原本的瑚太朗君说不定已经不在了…</p><p>瑚太朗：不，没有这事。虽然很模糊，但是我童年时代之类的记忆还是有的。</p><p>小鸟：因为都是用的一个大脑，记忆的有无是不能作为证据的哟…</p><p>小鸟：但是我不想去考虑这个…</p><p>小鸟抱住了我。她的眸子里已经失去了平常的光泽。</p><p>小鸟：如果瑚太朗君仅仅是我愿望的现实表现的话…</p><p>小鸟：大概…我就，没办法再努力了。</p><p>小鸟：但是…这件事我不想去证明…就这样…</p><p>小鸟：我想就这样…结束掉…</p><p>瑚太朗：不要啊，不要放弃啊！</p><p>小鸟：但是啊…</p><p>瑚太朗：拜托了。</p><p>我紧紧抱住小鸟，让她不再说话。</p></blockquote><h3 id="22"><a href="#22" class="headerlink" title="22"></a>22</h3><blockquote><p>小鸟：为什么，你的性格会变得跟过去完全相反了啊！！</p><p>瑚太朗：…那个…</p><p>小鸟：瑚太朗君，过去没有这么开朗！</p><p>小鸟：过去你很阴暗！对人完全不亲切！很冷淡！</p><p>小鸟：…一点都不温柔。</p><p>小鸟：我…好多次都被无视了…</p><p>小鸟：你没有来帮助我…</p><p>小鸟：你现在的…那个性格本身…就是我的愿望的证据…</p><p>小鸟：你是魔物！你是我制造出来的…依照我的心意造出来的魔物！</p><p>小鸟：不是真正的瑚太朗君…</p><p>小鸟：我，和自己的欲望，恋爱了…</p><p>枪口激烈地颤抖者。</p><p>瑚太朗：呐小鸟。</p><p>瑚太朗：“键”对你来说，是个重担吧？</p><p>瑚太朗：没能让圭介叔叔他们复活，还让我受了伤，连你自己的人生也被迫献给了她。</p><p>瑚太朗：你只是在用这家伙的事当借口，一直放纵着自己啊！</p><p>小鸟：不对…</p><p>瑚太朗：杀了它的话契约就会被打破，力量说不定也会失去。</p><p>瑚太朗：但是，现在有了那些盯上“键”的人杀了她的机会…</p><p>瑚太朗：你应该是对这件事深思熟虑无数次了吧？</p><p>瑚太朗：你一直在两者的狭间中痛苦、摇摆着。</p><p>小鸟：才不是…</p><p>瑚太朗：我不会容忍你的软弱。</p><p>瑚太朗：如果说你动摇了的话，我会去保护“键”。</p><p>瑚太朗：直到最后的最后…</p><p>瑚太朗：在残酷的选择尽头，会有着能令人接受的结局。</p><p>瑚太朗：让我们，一起走到那里去吧。</p></blockquote><h3 id="23"><a href="#23" class="headerlink" title="23"></a>23</h3><blockquote><p>瑚太朗：那，还有一个问题</p><p>朱音：什么？</p><p>瑚太朗：退出盖亚，一起来平息斗争。这个做不到吗？</p><p>朱音：你是笨蛋吗？</p><p>瑚太朗：大概是吧。</p></blockquote><h3 id="24"><a href="#24" class="headerlink" title="24"></a>24</h3><blockquote><p>瑚太朗：但是，就算是会长其实也很讨厌和静流还有露西娅为敌吧。</p><p>朱音：那是没有办法的事呐。</p><p>朱音：没办法呢。</p><p>朱音：再怎么感慨也没有办法。</p><p>瑚太朗：你也讨厌这样的事情吧。</p></blockquote><h3 id="25"><a href="#25" class="headerlink" title="25"></a>25</h3><blockquote><p>瑚太朗：…我觉得啊</p><p>千早：什么？</p><p>瑚太朗：原本人类就和森林之类的绿色没法相容也说不定。</p></blockquote><h3 id="26"><a href="#26" class="headerlink" title="26"></a>26</h3><blockquote><p>咲夜：但是，能贯彻软弱的话那也是一种强大哟。</p><p>咲夜：不过呢…看来现在的你并没有将其贯彻下去的想法。</p><p>瑚太朗：……</p><p>瑚太朗：我…是为什么要战斗来着…</p><p>千早：难道不是为了让超自研复活吗？</p><p>瑚太朗：嗯…</p><p>但是，我的想法确实是那样没有错。</p><p>想要取回…</p><p>那些快乐的日常。</p><p>仅仅如此。</p></blockquote><h3 id="27"><a href="#27" class="headerlink" title="27"></a>27</h3><blockquote><p>秘书：既然知道了，还在留恋日常吗，阁下？</p><p>瑚太朗：当然了。</p><p>瑚太朗：无论怎样，都不会抛弃的。</p><p>瑚太朗：和你不同，我们是想要快乐地享受校园生活的。</p><p>秘书：…</p><p>听了那些，朱音的秘书便转过身去。</p><p>瑚太朗：那么说来还没有问过你的名字呢。</p><p>瑚太朗：明明都是部员。</p><p>秘书：我姓宫岛。我的名字的话怎样都无所谓了。</p><p>瑚太朗：那，官岛同学。</p><p>官岛同学慢慢地取出一串钥匙，递给我。</p><p>官岛：以后，就随便你了。</p><p>瑚太朗：当然了，我们一直都是freeman啊。</p><p>官岛走了。</p><p>那一刻，感觉她笑了。</p><p>虽然不知道是善意的笑还是侮蔑的笑。</p></blockquote><h3 id="28"><a href="#28" class="headerlink" title="28"></a>28</h3><blockquote><p>无聊的社团活动。</p><p>不过，虽然是无聊的事情，但是真的很有趣啊。</p><p>一边看着博客和活动记录，一边和千早两个人聊着天。</p><p>两个人都知道的事。</p><p>只有我知道的事。</p><p>一一回忆起来。</p><p>并不能说是关系要好。</p><p>也有对峙，有各执己见。</p><p>现在想来的话，也许那是作为敌人的互相牵制。</p><p>…也许并没有那么好的回忆。</p><p>只是，为什么。</p><p>这样聊着不久之前发生的那些事情，竟然是如此的快乐。</p><p>瑚太朗：呐。</p><p>千早：…怎么了？</p><p>总是把已经发生过的事情一一美化，是人类的坏习惯。</p><p>瑚太朗：总觉得…</p><p>千早：所以说，怎么了？</p><p>但是，我要背负着那些，继续前行。</p><p>瑚太朗：…啊，不行吗？</p><p>瑚太朗：会长，因为是三年级，马上就要毕业了吧。</p><p>千早：所～以～说～</p><p>总有一天要结束。</p><p>有限的平和的时间。</p><p>瑚太朗：如果明年也能继续而话。</p><p>我把那个称为日常。</p><p>所谓的“现在”就是要在这个瞬间度过的。</p><p>已经过去的事情就会镀上金，像假的东西一样。</p><p>瑚太朗：啊啊，会长之类的上了大学也继续这么称呼吧。</p><p>瑚太朗：还要做事件调查之类的事呢。</p><p>瑚太朗：静流和露西娅也在。</p><p>瑚太朗：吉野也会来。</p><p>瑚太朗：是啊，咲夜也来的话也不错。</p><p>瑚太朗：…大概，不会无聊了吧。</p><p>但是，就算是镀上的金，只要不剥掉的话就会闪耀的吧。</p></blockquote><h3 id="29"><a href="#29" class="headerlink" title="29"></a>29</h3><blockquote><p>魔物究竟是什么东西呢？</p><p>对我来说，对盖亚来说，都只认为那是可以被有效利用的怪物吧。</p><p>千早却把他称为家人。</p><p>大概，人是不能，死而复生的吧…即便可以，也不会把魔物叫做家人吧。</p></blockquote><h3 id="30"><a href="#30" class="headerlink" title="30"></a>30</h3><blockquote><p>千早：明年要能如期举办就好了呢。</p><p>瑚太朗：是呀。</p><p>在那时，盖亚啊守护者啊什么的冲突应该也都全部结束了。</p><p>只要过上平常的日子就好了。</p><p>同时，时不时地享受这样的活动。</p><p>…节日，我想本来就是这种东西。</p></blockquote><h3 id="31"><a href="#31" class="headerlink" title="31"></a>31</h3><blockquote><p>咲夜是为回避毁灭而战的能力者。</p><p>咲夜：…强化…!!</p><p>这样啊。</p><p>和我一样，通过改写身体能力而战的能力者。</p><p>那就是咲夜了。</p></blockquote><h3 id="32"><a href="#32" class="headerlink" title="32"></a>32</h3><blockquote><p>我大概明白了。</p><p>盖亚，或是守护者…如果问到他们为什么知道毁灭的事情，根本原因是“先前有过一次了”。</p><p>咲夜是“上一次”时留下来的能力者…</p><p>然后现在，展现在这里的是咲夜变成魔物的最终姿态。</p></blockquote><h3 id="33"><a href="#33" class="headerlink" title="33"></a>33</h3><blockquote><p>咲夜：我的能力是将已有的某种东西改写…</p><p>咲夜：但是，却无法改写出原本不存在的东西。</p><p>咲夜：…就像现在瑚太朗君能做到的这样。</p></blockquote><h3 id="34"><a href="#34" class="headerlink" title="34"></a>34</h3><blockquote><p>欧若拉的剑。一直，为了劈开前进的道路而产生的，我的生命之剑。</p><p>花瓣之剑。一直，为了守护而存在着的，咲夜的生命之剑。</p></blockquote><h3 id="35"><a href="#35" class="headerlink" title="35"></a>35</h3><blockquote><p>家庭啊，生活啊。</p><p>正是有大家的支撑，才得以点亮光明。</p><p>虽然只是再普通不过的日常…</p><p>然而不知为何，我感到这份日常，格外的珍贵。</p></blockquote><h3 id="36"><a href="#36" class="headerlink" title="36"></a>36</h3><blockquote><p>想一想要是就这样生活下去，在超自研的日子…已经一去不返了。</p><p>成员们分道扬镳，各自划分为盖亚和守护者两派，为组织而战…</p><p>聚集起那么多人，喧闹的社团活动，在活动室里喋喋不休，种种的种种…</p></blockquote><h3 id="37"><a href="#37" class="headerlink" title="37"></a>37</h3><blockquote><p>瑚太朗：江坂先生是了什么，才加入守护者的呢？</p><p>江坂：什么原因，吗。我不觉得铁变成剑和齿轮需要什么理由。</p><p>瑚太朗：…</p><p>江坂：因为该这样做所以才这样做，仅此而已。你对于自己要变成什么，为什么要改变有想法了吗？</p><p>瑚太朗：没有…</p><p>只是想作为一些参考而已。</p><p>我依然是站在被保护的立场上，结果我只不过是处在犹豫期的延长期上罢了。</p><p>自己要怎样改变，怎样做…就算现在来作出决定，我的觉悟还尚未足够。</p><p>想要听听前辈的意见。</p><p>江坂：成为你该成为的事物吧。是要变成坚实强劲的钢剑，还是变成生锈易折，被弃之不理的小钉子呢，这是谁也无法决定的。</p><p>江坂：如果拒绝收敛锋芒，而盼望着能经常显露实力的话，那就只会着上锈斑而已。…你想要变成怎样呢？</p><p>瑚太朗：…</p><p>江坂：首先，你就不该跟其他人对比从而贬低了自己。</p><p>瑚太朗：只是，对于自己要变成怎样，我还没找到答案。</p></blockquote><h3 id="38"><a href="#38" class="headerlink" title="38"></a>38</h3><blockquote><p>朱音：但是很意外啊。明明，看起来像是对这个空间最执着眷恋着的人。</p><p>瑚太朗：考虑了很多很多呢…</p><p>退学不上这种事情，说实在的确实很难过。</p><p>但是就算留在学校，超自研也变不回原样了吧。</p><p>肯定又变成了白费力气地空转着的状态。</p><p>尽管如此强忍到毕业，到了大学或者是职场之后应该是可以快乐地生活下去的。</p><p>但是…那样的自己几乎变成了我难以想象的人了。</p></blockquote><h3 id="39"><a href="#39" class="headerlink" title="39"></a>39</h3><blockquote><p>那么说着的朱音，看起来比平常更加寂寞。</p><p>朱音：告诉我一件事。对你而言，学校能称得上是最好的场所吗？</p><p>这是个个人的问题。</p><p>瑚太朗：最好…倒是谈不上，但是…</p><p>瑚太朗：想要让它变成最好而努力的结果就是现在这样。</p><p>瑚太朗：我，一直都是在白费力气做着无用功吧…</p><p>瑚太朗：看起来很不像样吧。</p></blockquote><h3 id="40"><a href="#40" class="headerlink" title="40"></a>40</h3><blockquote><p>朱音：所谓的盖亚主义呢，就是从相对的角度上把握地球环境的思想。</p><p>朱音：用一句话来说明的话，就是比起人类来说更重视星球存续的考量。</p><p>朱音：…所以说，对像你这样的人来说，这儿是个很痛苦的地方也说不定呢。</p><p>朱音：所以说如果要陪在我的身边的话…请闭上眼，塞住耳朵吧。</p><p>朱音：但是如果，到了无论如何都忍不了的时候…是呢，到那时候…随你喜欢做什么去做就好了。</p><p>瑚太朗：随我喜欢是说…</p><p>朱音：就算是背叛了，也没关系的意思哟。</p></blockquote><h3 id="41"><a href="#41" class="headerlink" title="41"></a>41</h3><blockquote><p>在朱音因为工作离开的这段时间，我陷入了沉思。</p><p>成为盖亚的伙伴也就意味着，会和守护者敌对。</p><p>也就是说，即便是杀人或者是被杀的时候也是会有的。</p><p>如果可以的话，我想做正确的事情。</p><p>不想做会让痛苦的行为。</p><p>但是对我而言，那是最好的选择吗？</p></blockquote><h3 id="42"><a href="#42" class="headerlink" title="42"></a>42</h3><blockquote><p>朱音：对世界感到不满，但是光凭自己的力量却改变不了。那种黑暗的冲动，化作狰狞的野兽的姿态而表露出来…那就是魔物。</p><p>朱音：那样强大的抑郁，有时甚至会招致毁灭的冲动。</p><p>朱音：魔物使的各位之中，也有人深藏这格外强烈的情感。</p><p>瑚太朗：也有与此相反的人吧。</p><p>朱音：在直面问题时，当自己没有足以与之抗衡的能力的情况下，依然通过改变自己来克服困境，这种人也有存在。</p><p>朱音：对他们来说，只有自己是可信的。通过自身的强化来克服困难。那就是…</p><p>瑚太朗：超人。</p></blockquote><h3 id="43"><a href="#43" class="headerlink" title="43"></a>43</h3><blockquote><p>过去构成我的各种东西都在这里。</p><p>但是现在已经，连我的一部分都不是了。</p><p>一切都成为了褪色的过去。</p></blockquote><h3 id="44"><a href="#44" class="headerlink" title="44"></a>44</h3><blockquote><p>津久野：盖亚主义并不大喜欢对生存的强烈执念。</p><p>瑚太朗：比起个人来说，星球整体才更重要…好像是这样说的吧。</p><p>津久野：对于在生活中失败了一次的人来说，那种想法会更加轻松吧。</p><p>津久野：你也是失败了的…然而，却还没失去活力。</p><p>瑚太朗：我？</p><p>津久野：对我们来说，是在羡慕的同时却又心存妒忌的存在。</p><p>津久野：朱音小姐说过要保护你。</p><p>津久野：但事实上，说不定是对你抱有什么期待呢…</p></blockquote><h3 id="45"><a href="#45" class="headerlink" title="45"></a>45</h3><blockquote><p>虽然也有忘记了的事物，但只有那一点是清楚的。</p><p>朱音存在于我的心里。</p><p>从很久以前到现在都一直存在着。</p></blockquote><h3 id="46"><a href="#46" class="headerlink" title="46"></a>46</h3><blockquote><p>瑚太朗：最底线的，该守护的，作为人的领域还保留着吧…难道没有了吗？</p><p>朱音：…</p><p>语塞了。</p><p>如果同意的话只要点头就好了。</p><p>无言，就等同于认同了盖亚主义如病理一般的黑暗。</p></blockquote><h3 id="47"><a href="#47" class="headerlink" title="47"></a>47</h3><blockquote><p>西九条：人类是傲慢的，自以为是的，残酷的。</p><p>西九条：那确实是罪过呢。</p><p>西九条：可是，天王寺君。</p><p>西九条：…尽管如此，人类也是应该生存下去的。</p><p>瑚太朗：…</p><p>西九条：无论如何罪孽深重，甚至需要牺牲其他东西。</p><p>西九条：虽然肮脏，人类也是应该生存下去的。</p><p>瑚太朗：…</p><p>瑚太朗：可是，老师，如果像今天这样继续下去的话，世界在三十年内会变成什么样子？</p><p>西九条：什么都不会变哦。尽管如此人也是应该被生下来，直到最后为止。</p><p>西九条：人类是不会允许人类被牺牲掉的。</p><p>瑚太朗：那就奇怪了。人正在虐待人吧？</p><p>西九条：…我承认不可能立马让所有人都幸福。</p><p>西九条：可是即使那样，我们也必须继续前进。</p><p>西九条：毫无根据就将人们的生活消灭的权利，谁都没有啊。</p><p>瑚太朗：有的，比如这个地球就有。</p><p>瑚太朗：如果地球有灵魂的话，不会赞同人类吧。</p><p>西九条：可是，我们应该可以为了拯救这颗星球而付出努力。</p><p>瑚太朗：毫无现实的言论，这只是精神论，理想论。</p><p>西九条：…即使现在看上去希望渺茫，可是如果最后一直到最后也不放弃的话…迟早都会成功的。</p><p>瑚太朗：不，绝对不可能。</p><p>西九条：一定可以的。因为那才是人类的坚强之处啊。</p><p>西九条：作为教师的我，一直想把那种想法传达给大家。</p><p>西九条：那就是人类的美丽和生存下来的美好。</p><p>西九条：对你也是一样的，天王寺君。</p><p>瑚太朗：…人类可并不美丽哦，老师。</p><p>瑚太朗：人类尽可能地吃，尽可能地破坏，尽可能地来差别化。</p><p>瑚太朗：直到最后也不放弃之类的，总之要做就能做到之类的，只不过是把强者的论调无限美化了而已。</p><p>瑚太朗：“虽然不知道人类是否罪孽深重，但我仍然坚信着人类的可能性”，像这样？</p><p>瑚太朗：“那么，会流出一滴泪水吗。我们也必须跨越这个悲剧”，这样么？</p><p>瑚太朗：那不是很搞笑吗，那是在欺瞒大家啊老师。</p><p>西九条：…</p><p>瑚太朗：无罪？不是的吧。全人类都有相等的罪过哦。</p><p>瑚太朗：不存在任何一个无罪的人类，在文明下生存着的人们，大家都是同罪的。</p><p>瑚太朗：如果想让星球的生命延续下去，我们就要立马舍弃这种便利的生活。</p><p>西九条：…</p><p>瑚太朗：“虽然人类也是愚蠢的，但是我还是相信着人类的美好～”，像这样说着，不是又在流传余毒吗？</p><p>瑚太朗：那个，你们所说的？那些所谓人类的美丽之处，在变得为时已晚以前会改变吗？</p><p>西九条老师低下了眼睛。</p><p>西九条：这样啊。天王寺君的结论原来是这个啊。</p><p>重新抬起的脸上，已经连一丝悲伤也见不到了。反而带着一股尖锐的一丝。</p><p>西九条：你所说的也有一番道理。</p><p>西九条：也许人类并不美丽。</p><p>西九条：…可是必须的活下去。</p><p>西九条：自杀绝不是人应该选择的行为。</p><p>西九条：更不能允许的是，在自杀中卷入其他人。</p><p>西九条：那时在侵害别人的生存权利。</p><p>瑚太朗：你们的思考中，只有眼前的利益啊，一点也没有对未来的展望吗？</p><p>西九条：因为我们首先是生存于今天的啊。</p></blockquote><h3 id="48"><a href="#48" class="headerlink" title="48"></a>48</h3><blockquote><p>洲崎：人类从残酷的生存竞争中胜出，从原始的形态脱胎，获得了知性而站在食物链顶端。</p><p>洲崎：简简单单就被消灭，不就让知性声名扫地了吗？</p></blockquote><h3 id="49"><a href="#49" class="headerlink" title="49"></a>49</h3><blockquote><p>对立，争论，互相抓话柄…</p><p>明明有了知识这样的就应该会被消除的东西，却从未消失。</p><p>为什么会那样呢。</p><p>回答是，因为是人类，只能这样说。</p></blockquote><h3 id="50"><a href="#50" class="headerlink" title="50"></a>50</h3><blockquote><p>人，是需要对话的生物。</p><p>是必须得理智地互相理解的存在。</p><p>但这个少女是不同的。</p><p>在无人居住的这个世界里，即使以人的姿态示人，也无法成为人那样的存在。</p><p>人，实在和其他各式各样的人的接触中成长起来的。</p></blockquote><h3 id="51"><a href="#51" class="headerlink" title="51"></a>51</h3><blockquote><p>瑚太朗：我曾想要找到自己的容身之处。那是因为，我明白自己是个笨拙的人呐。</p><p>瑚太朗：一直很不安。总觉得大家，有一天会消失掉…</p><p>瑚太朗：害怕自己会变成一个人。</p><p>瑚太朗：超自研，也是基于那种动机才诞生的产物。</p><p>瑚太朗：太逊了…那样的我…</p><p>瑚太朗：只为了获取人气而拼命什么的…</p><p>瑚太朗：找到自己喜欢的家伙，被那个家伙喜欢，不安什么的就全都消散了。</p><p>瑚太朗：然后溶入世界之中…但为什么连世界本身也溶化了呢。</p><p>瑚太朗：仅怀着这样的小心思的我，是不是很不幸呢？</p><p>瑚太朗：但是呐，真正找到了容身之处的我，却从未后悔。</p><p>瑚太朗：因为人生，只要充实，就足以无悔。</p><p>瑚太朗：只要是为了自己喜欢的人，其他一切怎样都好。即使世界…</p><p>瑚太朗：即使世界毁灭也…</p><p>瑚太朗：是不是搞错什么了啊？</p><p>瑚太朗：大家都是相似的存在吧？那为什么只有我被拽到这里来了？</p><p>瑚太朗：为什么只有我…在这种…地方…</p></blockquote><h3 id="52"><a href="#52" class="headerlink" title="52"></a>52</h3><blockquote><p>如果这个宇宙里真有所谓的神存在的话，那家伙一定是在无法想象的苦痛中活着的吧。</p><p>知性塑造着自身的孤独。</p><p>无法将目光从这绝望和物理层面的无情中移走。</p><p>所谓人类，那是多么幸福的一种存在啊。</p><p>无法认知万物，这意味着多大程度上的救赎啊。</p><p>人类只要有爱，便会获得救赎。</p><p>但神，却无法仅凭爱获得救赎。</p></blockquote><h3 id="53"><a href="#53" class="headerlink" title="53"></a>53</h3><blockquote><p>没有爱只有知性的生命，就无法继续扩展吗？</p></blockquote><h3 id="54"><a href="#54" class="headerlink" title="54"></a>54</h3><blockquote><p>我们曾经生活过的世界，是更为多姿多彩温暖满溢的世界吧。</p><p>被称为无知、可能性、希望的事物，都是可以使人心温暖的东西吧。</p><p>人无法胜任神的位置。</p><p>神太过孤独了。</p><p>把一切都解析殆尽的话，就会变得再也无法心潮澎湃了。</p></blockquote><h3 id="55"><a href="#55" class="headerlink" title="55"></a>55</h3><blockquote><p>篝一直探求的东西…那无非是可能性。</p><p>生命生存下去所需要的可能性。</p></blockquote><h3 id="56"><a href="#56" class="headerlink" title="56"></a>56</h3><blockquote><p>篝，即使现在，也还是孤独的。</p><p>因为本质就是孤独。</p><p>…我还是太轻率了。</p></blockquote><h3 id="57"><a href="#57" class="headerlink" title="57"></a>57</h3><blockquote><p>瑚太朗：正是你的不接受，才成就了我的孤独呐。</p><p>瑚太朗：明白了吗？没有那份孤独的话，我就会在满足人际关系中止步，就会慢慢被埋没。</p><p>瑚太朗：在那里止步的话，一切都完了。</p><p>瑚太朗：寻找可能性的旅途，无论何时都是孤独的。</p><p>瑚太朗：活在曾经视为珍贵的小小关系中的话，的确能获得微博的幸福。但那样的话，就无法踏上更为漫长的旅途了哦，吉野怪。</p><p>瑚太朗：适应一成不变的生活而就此停下步伐的话，就永远无法成为开拓者了。人类永远要面临这道选择题。</p></blockquote><h3 id="58"><a href="#58" class="headerlink" title="58"></a>58</h3><blockquote><p>想要改变自己的想法。</p><p>痛恨世界的心情。</p><p>这两种心情相互交织冲突，在心灵深处蠢动着。</p></blockquote><h3 id="59"><a href="#59" class="headerlink" title="59"></a>59</h3><blockquote><p>小鸟（幼）：…就在这种得过且过中，时间会变得越来越少的哟。</p><p>小鸟（幼）：逃避只能使宝贵的人生不断流失。</p><p>小鸟（幼）：我可不会逃避的！</p></blockquote><h3 id="60"><a href="#60" class="headerlink" title="60"></a>60</h3><blockquote><p>看到那家伙对本来只作为义务而照顾的狗投注感情，我突然变得焦虑了。</p><p>…我自己，要漫无目的地在原地呆多久呢。</p></blockquote><h3 id="61"><a href="#61" class="headerlink" title="61"></a>61</h3><blockquote><p>我有想要改变自身吗？</p><p>虽然那么说也没错…</p><p>但是感觉上不太一样。</p><p>我一直都是安于现状的。</p><p>为什么，我会发现自己作为狩猎者的力量呢？</p></blockquote><h3 id="62"><a href="#62" class="headerlink" title="62"></a>62</h3><blockquote><p>…我讨厌那些家伙。</p><p>现在我明白了。我讨厌守护者组织。</p><p>他们是歧视主义者，是践踏他人的人。</p></blockquote><h3 id="63"><a href="#63" class="headerlink" title="63"></a>63</h3><blockquote><p>路易斯：之所以志愿来这里，就是为了给自己痛苦啊。</p><p>路易斯：但是，这种生活方式我已经放弃了。</p><p>路易斯：这种停滞的生活方式我已经放弃了。</p></blockquote><h3 id="64"><a href="#64" class="headerlink" title="64"></a>64</h3><blockquote><p>我已经，不会再有“变不成哪儿的什么人”的不安了。</p><p>我只是做了这样的选择而已。</p><p>自己活着的理由，不由自己去找寻是不行的。</p></blockquote><h3 id="65"><a href="#65" class="headerlink" title="65"></a>65</h3><blockquote><p>但是我已经不会再因为孤独受伤了。</p><p>我讨厌傲慢的家伙，绝对不会勉强自己跟他们相处。</p></blockquote><h3 id="66"><a href="#66" class="headerlink" title="66"></a>66</h3><blockquote><p>篝：为什么就是不能如愿？</p><p>瑚太朗：因为那就是所谓的世界啊。</p><p>瑚太朗：大家都因此而痛苦着。</p><p>瑚太朗：我也是其中之一。</p></blockquote><h3 id="67"><a href="#67" class="headerlink" title="67"></a>67</h3><blockquote><p>篝：篝不明白。</p><p>篝：为什么人类有着如此丰富的感受性，却会像现在这样停滞着？</p><p>篝：如此的聪明才智，明明不可能留不下美好的记忆。</p><p>瑚太朗：…人类无论如何都会争斗。</p></blockquote><h3 id="68"><a href="#68" class="headerlink" title="68"></a>68</h3><blockquote><p>篝：你们人类，非常重视现状。</p><p>篝：并不会为了得到明天的希望，而堵上现在的幸福。</p><p>篝：只要现状没问题，明天怎么样都不要紧。</p></blockquote><h3 id="69"><a href="#69" class="headerlink" title="69"></a>69</h3><blockquote><p>瑚太朗：大家，都有着必须守护的小小的幸福。</p><p>瑚太朗：为了小小的幸福，而对明天视而不见，或许真的很可怜呐。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游戏笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telegram代收QQ和微信消息</title>
      <link href="/2022/11/07/Telegram%E4%BB%A3%E6%94%B6QQ%E5%92%8C%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF/"/>
      <url>/2022/11/07/Telegram%E4%BB%A3%E6%94%B6QQ%E5%92%8C%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在ArchLinux i3上想用QQ和微信别人交流，是一件极其困难的事情，腾讯开发的linux for qq总是经常的出现段错误，而且界面过于丑陋。同时，腾讯为UOS开发的WeChat仅仅通过Electron封装了网页端，聊天记录都不能保存。故尝试采用Telegram代收QQ和微信消息。首先本文感谢以下的开源项目：</p><ul><li><a href="https://github.com/ehForwarderBot/efb-qq-slave">efb-qq-slave</a></li><li><a href="https://github.com/ehForwarderBot/efb-qq-plugin-go-cqhttp">efb-qq-plugin-go-cqhttp</a></li><li><a href="https://github.com/Mrs4s/go-cqhttp">go-cqhttp</a></li><li><a href="https://github.com/ehForwarderBot/efb-wechat-slave">efb-wechat-slave</a></li><li><a href="https://github.com/ehForwarderBot/efb-telegram-master">efb-telegram-master</a></li><li><a href="https://github.com/ehForwarderBot/ehForwarderBot">enForwarderBot</a></li></ul><p>在阅读本教程以前，你应该首先阅读<code>efb-qq-slave</code>作者写的教程<a href="https://milkice.me/2018/09/17/efb-how-to-send-and-receive-messages-from-qq-on-telegram/">安装并使用EFB：在Telegram收发QQ消息</a>。熟悉一些基本的概念。</p><h2 id="2-前提条件"><a href="#2-前提条件" class="headerlink" title="2. 前提条件"></a>2. 前提条件</h2><p>在开始部署之前，需要完成以下的准备工作：</p><ul><li>墙外的一台VPS或者墙内的一台VPS加上科学上网工具</li><li>一台电脑，Windows系统采用Windows Terminal和PowerShell7进行SSH连接</li></ul><h2 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3. 环境搭建"></a>3. 环境搭建</h2><p>由于我的服务器环境为Ubuntu 20.04 LTS，本文按照该操作系统进行描述。如果你采用的是其他发行版的Linux服务器，其过程并无本质区别。由于依赖或LTS版本的问题，你可能会遇到很多坑，如果你熟悉Docker，建议采取Docker部署服务，同时也为你的服务器中的其他服务提供了隔离。</p><h3 id="3-1-enForwarderBot"><a href="#3-1-enForwarderBot" class="headerlink" title="3.1 enForwarderBot"></a>3.1 enForwarderBot</h3><p>我自己写了一个shell脚本进行安装，故此处展示函数，有需要请读者自取。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">install_efb</span></span>() &#123;</span><br><span class="line">  <span class="comment"># To install the corresponding dependency</span></span><br><span class="line">  <span class="built_in">sudo</span> apt-get install libopus0 ffmpeg libmagic1 git libssl-dev</span><br><span class="line"></span><br><span class="line">  <span class="comment"># To install the efb</span></span><br><span class="line">  pip3 install -U https://github.com/ehForwarderBot/ehForwarderBot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-efb-telegram-master"><a href="#3-2-efb-telegram-master" class="headerlink" title="3.2 efb-telegram-master"></a>3.2 efb-telegram-master</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">install_etm</span></span>() &#123;</span><br><span class="line">  <span class="comment"># To install the efb-telegram-master</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehforwarderbot/efb-telegram-master</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-efb-qq-slave"><a href="#3-3-efb-qq-slave" class="headerlink" title="3.3 efb-qq-slave"></a>3.3 efb-qq-slave</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">install_eqs</span></span>() &#123;</span><br><span class="line">  <span class="comment"># To install efb-qq-slave</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehForwarderBot/efb-qq-slave</span><br><span class="line">  <span class="comment"># To install efb-qq-plugin-go-cqhttp</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehForwarderBot/efb-qq-plugin-go-cqhttp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-efb-wechat-slave"><a href="#3-4-efb-wechat-slave" class="headerlink" title="3.4 efb-wechat-slave"></a>3.4 efb-wechat-slave</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">install_ews</span></span>() &#123;</span><br><span class="line">  <span class="comment"># To install efb-wechat-slave</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehForwarderBot/efb-wechat-slave</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-中间件安装"><a href="#3-5-中间件安装" class="headerlink" title="3.5 中间件安装"></a>3.5 中间件安装</h3><p>此处有少数可选的中间件，用于加强功能。你可以选择安装也可以直接忽略。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">install_middlewares</span></span>() &#123;</span><br><span class="line">  <span class="comment"># To install efb-link_preview-middleware</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehForwarderBot/efb-link_preview-middleware</span><br><span class="line"></span><br><span class="line">  <span class="comment"># To install efb-voice_recog-middleware</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehForwarderBot/efb-voice_recog-middleware</span><br><span class="line"></span><br><span class="line">  <span class="comment"># To install efb-search_msg-middleware</span></span><br><span class="line">  pip3 install -U git+https://github.com/ehForwarderBot/efb-search_msg-middleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h2><p>EFB的工作机制是一个唯一的主端和多个从端进行通信。由于需要同时代收QQ和微信，故需要两个Telegram机器人，一个机器人用于接收QQ消息，一个机器人用于接收微信消息。</p><h3 id="4-1-配置两个Telegram机器人"><a href="#4-1-配置两个Telegram机器人" class="headerlink" title="4.1 配置两个Telegram机器人"></a>4.1 配置两个Telegram机器人</h3><p>此处直接参考efb-qq-slave作者的博客的教程，你需要重复该操作两次。一个是为了接收QQ消息，一个是为了接收微信消息。</p><p>要创建一个新的Bot，要先向<code>@BotFather</code>发起会话。发送指令<code>/newbot</code>以启动向导。期间，你需要指定这个 Bot的名称与用户名（用户名必须以bot结尾）。完毕之后<code>@BotFather</code>会提供给你一个密钥（Token），妥善保存这个密钥。请注意，为保护您的隐私及信息安全，请不要向任何人提供你的Bot用户名及密钥，这可能导致聊天信息泄露等各种风险。</p><p>接下来还要对刚刚启用的 Bot 进行进一步的配置：允许 Bot 读取非指令信息、允许将 Bot 添加进群组、以及提供指令列表。</p><p>发送 <code>/setprivacy</code> 到 <code>@BotFather</code>，选择刚刚创建好的Bot用户名，然后选择 “Disable”.<br>发送 <code>/setjoingroups</code> 到 <code>@BotFather</code>，选择刚刚创建好的Bot用户名，然后选择 “Enable”.<br>发送 <code>/setcommands</code> 到 <code>@BotFather</code>，选择刚刚创建好的Bot用户名，然后发送如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">help - Show commands list.</span><br><span class="line">link - Link a remote chat to a group.</span><br><span class="line">unlink_all - Unlink all remote chats from a group.</span><br><span class="line">info - Display information of the current Telegram chat.</span><br><span class="line">chat - Generate a chat head.</span><br><span class="line">extra - Access additional features from Slave Channels.</span><br><span class="line">update_info - Update info of linked Telegram group.</span><br><span class="line">react - Send a reaction to a message, or show a list of reactors.</span><br><span class="line">rm - Remove a message from its remote chat.</span><br></pre></td></tr></table></figure><p>然后还需要获取你自己的 Telegram ID，ID 应显示为一串数字。获取你自己的 ID 有很多方式，你可以选择任意一种。下面介绍两种可能的方式。</p><ol><li>Plus Messenger，如果你使用了Plus Messenger作为你的Telegram客户端，你可以直接打开你自己的资料页，在「自己」下面会显示你的ID。</li><li>通过Bot查询，很多现存的Bot也提供了ID查询服务，直接向其发送特定的指令即可获得自己的数字ID。在这里介绍一些接触过的。</li></ol><ul><li>@get_id_bot 发送 &#x2F;start</li><li>@XYMbot 发送 &#x2F;whois</li><li>@mokubot 发送 &#x2F;whoami</li><li>@GroupButler_Bot 发送 &#x2F;id</li><li>@jackbot 发送 &#x2F;me</li><li>@userinfobot 发送任意文字</li><li>@orzdigbot 发送 &#x2F;user</li></ul><p>留存你的Telegram ID以便后续使用。</p><h3 id="4-2-配置QQ"><a href="#4-2-配置QQ" class="headerlink" title="4.2 配置QQ"></a>4.2 配置QQ</h3><p>如果需要配置QQ，你必须要首页阅读这两个项目主页的帮助文档：</p><ul><li><a href="https://github.com/ehForwarderBot/efb-qq-slave">efb-qq-slave</a></li><li><a href="https://github.com/ehForwarderBot/efb-qq-plugin-go-cqhttp">efb-qq-plugin-go-cqhttp</a></li></ul><p>然后你可以执行参考以下的脚本，你只需要修改<code>token</code>和<code>id</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">QQ_CONFIG=~/.ehforwarderbot/profiles/qq</span><br><span class="line">TELEGRAM_MASTER=<span class="string">&quot;blueset.telegram&quot;</span></span><br><span class="line">QQ_SLAVE=<span class="string">&quot;milkice.qq&quot;</span></span><br><span class="line"><span class="function"><span class="title">configure_qq</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[  -e <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The profile directory exists, exit&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>/<span class="variable">$&#123;TELEGRAM_MASTER&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>/<span class="variable">$&#123;QQ_SLAVE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;master_channel: <span class="variable">$&#123;TELEGRAM_MASTER&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;slave_channels:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - <span class="variable">$&#123;QQ_SLAVE&#125;</span>&quot;</span></span><br><span class="line">  ) &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>/config.yaml&quot;</span></span><br><span class="line"></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;token: &quot;&lt;your_token&gt;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;admins:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - &lt;your_id&gt;&quot;</span></span><br><span class="line">  ) &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>/<span class="variable">$&#123;TELEGRAM_MASTER&#125;</span>/config.ymal&quot;</span></span><br><span class="line"></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Client: GoCQHttp&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;GoCQHttp:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  type: HTTP&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  access_token:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  api_root: http://127.0.0.1:5700/&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  host: 127.0.0.1&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  port: 8000&quot;</span></span><br><span class="line">  ) &gt;&gt;  <span class="string">&quot;<span class="variable">$&#123;QQ_CONFIG&#125;</span>/<span class="variable">$&#123;QQ_SLAVE&#125;</span>/config.ymal&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时你需要运行QQ机器人，此处请参考仓库里面的教程。</p><h3 id="4-3-配置微信"><a href="#4-3-配置微信" class="headerlink" title="4.3 配置微信"></a>4.3 配置微信</h3><p>同样，你应该首先阅读下面仓库的说明文档：</p><ul><li><a href="https://github.com/ehForwarderBot/efb-wechat-slave">efb-wechat-slave</a></li></ul><p>然后你可以执行参考以下的脚本，你只需要修改<code>token</code>和<code>id</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">WECHAT_WEB_CONFIG=~/.ehforwarderbot/profiles/wechat</span><br><span class="line">TELEGRAM_MASTER=<span class="string">&quot;blueset.telegram&quot;</span></span><br><span class="line">WECHAT_SLAVE=<span class="string">&quot;blueset.wechat&quot;</span></span><br><span class="line"><span class="function"><span class="title">configure_wechat_web</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[  -e <span class="string">&quot;<span class="variable">$&#123;WECHAT_WEB_CONFIG&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;The profile directory exists, exit&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;WECHAT_WEB_CONFIG&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;WECHAT_WEB_CONFIG&#125;</span>/<span class="variable">$&#123;TELEGRAM_MASTER&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;WECHAT_WEB_CONFIG&#125;</span>/<span class="variable">$&#123;WECHAT_SLAVE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;master_channel: <span class="variable">$&#123;TELEGRAM_MASTER&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;slave_channels:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - <span class="variable">$&#123;WECHAT_SLAVE&#125;</span>&quot;</span></span><br><span class="line">  ) &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;WECHAT_WEB_CONFIG&#125;</span>/config.yaml&quot;</span></span><br><span class="line"></span><br><span class="line">  (</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;token: &quot;&lt;your_token&gt;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;admins:&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - &lt;your_id&gt;&quot;</span></span><br><span class="line">  ) &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;WECHAT_WEB_CONFIG&#125;</span>/<span class="variable">$&#123;TELEGRAM_MASTER&#125;</span>/config.ymal&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-运行"><a href="#5-运行" class="headerlink" title="5. 运行"></a>5. 运行</h2><h3 id="5-1-前台运行用于测试"><a href="#5-1-前台运行用于测试" class="headerlink" title="5.1 前台运行用于测试"></a>5.1 前台运行用于测试</h3><p>对于QQ而言：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先运行QQ机器人</span></span><br><span class="line">./go-cqhttp</span><br><span class="line"><span class="comment"># 启动efb-qq-slave</span></span><br><span class="line">ehforwarderbot --profile qq</span><br></pre></td></tr></table></figure><p>对于微信而言：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ehforwarderbot --profile wechat</span><br></pre></td></tr></table></figure><h3 id="5-2-使用服务"><a href="#5-2-使用服务" class="headerlink" title="5.2 使用服务"></a>5.2 使用服务</h3><p>创建后台服务，对于QQ而言，你可以创建两个服务，一个启动机器人，一个启动<code>efb-qq-slave</code></p><p>对于微信而言，你只需要创建一个服务直接启动<code>efb-wechat-slave</code>。至于怎么创建服务，请读者自行查阅相关资料。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Terminal配置美化过程</title>
      <link href="/2022/11/07/Windows-Terminal%E9%85%8D%E7%BD%AE%E7%BE%8E%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/11/07/Windows-Terminal%E9%85%8D%E7%BD%AE%E7%BE%8E%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-预先准备"><a href="#1-预先准备" class="headerlink" title="1. 预先准备"></a>1. 预先准备</h2><h3 id="1-1-美化PowerShell"><a href="#1-1-美化PowerShell" class="headerlink" title="1.1 美化PowerShell"></a>1.1 美化PowerShell</h3><p>在ArchLinux上用的是Oh-My-Zsh。为了符合习惯，使用类似的Posh-Git和Oh-My-Posh，在PowerShell中执行以下的命令进行安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="built_in">Install-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span> <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure><p>打开 PowerShell 的配置文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>添加以下内容，本人选择的主题是<code>Agnoster</code>，为了与Oh-My-Zsh的主题保持一致性。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span></span><br><span class="line"><span class="built_in">Import-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span></span><br><span class="line"><span class="built_in">Set-Theme</span> Agnoster</span><br></pre></td></tr></table></figure><p>特别注意字体，一定要使用支持Powerline的字体，否则会产生乱码。</p><h2 id="1-2-PSReadLine的使用"><a href="#1-2-PSReadLine的使用" class="headerlink" title="1.2 PSReadLine的使用"></a>1.2 PSReadLine的使用</h2><p><code>PSReadLine</code>是一个用于增强PowerShell命令行编辑体验的模块，其安装和使用说明请参考其开源项目主页。由于使用的复杂性，为了简单起见，只加入自动补全功能：</p><p>仍是在PowerShell的配置文件中输入，即可实现在zsh下的Menu补全。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-PSReadlineKeyHandler</span> <span class="literal">-Key</span> Tab <span class="literal">-Function</span> MenuComplete</span><br></pre></td></tr></table></figure><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-Global-Setting-配置"><a href="#2-1-Global-Setting-配置" class="headerlink" title="2.1 Global Setting 配置"></a>2.1 Global Setting 配置</h3><h4 id="2-1-1-对所有的Profile进行设置"><a href="#2-1-1-对所有的Profile进行设置" class="headerlink" title="2.1.1 对所有的Profile进行设置"></a>2.1.1 对所有的Profile进行设置</h4><p>不搞花里胡哨的背景图片。所有Profile均采用同样的风格。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;defaults&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MesloLG NF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dracula&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-退出-Windows-Terminal"><a href="#2-1-2-退出-Windows-Terminal" class="headerlink" title="2.1.2 退出 Windows Terminal"></a>2.1.2 退出 Windows Terminal</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;closeWindow&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+q&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Color-Schemes-配置"><a href="#2-2-Color-Schemes-配置" class="headerlink" title="2.2 Color Schemes 配置"></a>2.2 Color Schemes 配置</h3><p>这个主题配置主题颜色的JSON文件来源为开源项 iTerm2-Color-Schemes。因为本人在VsCode采用的主题也是Dracula，为了保持一致性，Windows Terminal的配色主题也是采用Dracula。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;schemes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dracula&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;black&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;red&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff5555&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;green&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#50fa7b&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;yellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f1fa8c&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;blue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#bd93f9&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;purple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff79c6&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;cyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#8be9fd&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;white&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#bbbbbb&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightBlack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#555555&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightRed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff5555&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightGreen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#50fa7b&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightYellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f1fa8c&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightBlue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#bd93f9&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightPurple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff79c6&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightCyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#8be9fd&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;brightWhite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#1e1f29&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f8f8f2&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>为了使所有的Profile能够使用这个配色主题，在Profile中的defaults添加如下信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;defaults&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dracula&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-Key-bindings"><a href="#2-3-Key-bindings" class="headerlink" title="2.3 Key bindings"></a>2.3 Key bindings</h3><p>由于Linux系统使用ArchLinux i3，为了符合ArchLinux i3的习惯。此处的Modifier只会采用Alt，而且设置习惯将会根据i3的快捷键设置。</p><h4 id="2-3-1-Tab-管理命令配置"><a href="#2-3-1-Tab-管理命令配置" class="headerlink" title="2.3.1 Tab 管理命令配置"></a>2.3.1 Tab 管理命令配置</h4><p>用于创建新的tab，以及默认tab的打开：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+enter&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+1&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+2&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+3&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+4&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">4</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+5&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">5</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+6&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">6</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+7&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">7</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+8&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+9&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>用于创建一个当前tab的副本并打开:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;duplicateTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+d&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>用于关闭当前的tab：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;closeTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+q&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>用于切换tab：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+1&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+2&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+3&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+4&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">4</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+5&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">5</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+6&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">6</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+7&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">7</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+8&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+9&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-Pane-管理命令配置"><a href="#2-3-2-Pane-管理命令配置" class="headerlink" title="2.3.2 Pane 管理命令配置"></a>2.3.2 Pane 管理命令配置</h4><p>关闭当前聚焦的pane。如果没有Pane，就会直接关闭掉当前的Tab。如果只有一个Tab打开，将会关闭窗口：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;closePane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+w&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>改变当前聚焦的pane的尺寸：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;down&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+down&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+left&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;right&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+right&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;up&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+up&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>利用当前的profile划分pane：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;horizontal&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+h&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vertical&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+v&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>利用其他的profile进行分割。由于<code>alt+index</code>以及<code>alt+shift+index</code>均用于了Tab的管理，此处不得不采用Modifier <code>ctrl</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+1&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+2&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+3&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+4&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">4</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+5&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">5</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+6&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">6</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+7&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">7</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+8&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+9&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-字体大小重置"><a href="#2-3-3-字体大小重置" class="headerlink" title="2.3.3 字体大小重置"></a>2.3.3 字体大小重置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resetFontSize&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+r&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-配置文件全部"><a href="#3-配置文件全部" class="headerlink" title="3. 配置文件全部"></a>3. 配置文件全部</h2><p>此处给出所有的配置文件，供参考。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//! Do not edit this</span></span><br><span class="line">    <span class="attr">&quot;$schema&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! To set the default profile to PowerShell7</span></span><br><span class="line">    <span class="attr">&quot;defaultProfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! To define the profiles</span></span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">//! Settings to apply to all profiles</span></span><br><span class="line">        <span class="attr">&quot;defaults&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MesloLGS NF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span><span class="punctuation">:</span> <span class="number">14</span><span class="punctuation">,</span> <span class="comment">// 老年人了</span></span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dracula&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span><span class="punctuation">:</span> <span class="number">0.8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//! Profile objects</span></span><br><span class="line">        <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="comment">//! PowerShell 7</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tabTitle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PowerShell 7&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PowerShell&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows.Terminal.PowershellCore&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">//! Windows PowerShell 5.1</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows PowerShell&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;powershell.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">//! Don&#x27;t need at this time</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Azure Cloud Shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows.Terminal.Azure&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">//! CMD</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">                <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;命令提示符&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tabTitle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! To define the Dracula theme</span></span><br><span class="line">    <span class="attr">&quot;schemes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dracula&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;black&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;red&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff5555&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;green&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#50fa7b&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;yellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f1fa8c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;blue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#bd93f9&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;purple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff79c6&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#8be9fd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;white&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#bbbbbb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightBlack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#555555&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightRed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff5555&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightGreen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#50fa7b&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightYellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f1fa8c&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightBlue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#bd93f9&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightPurple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ff79c6&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightCyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#8be9fd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightWhite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#ffffff&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#1e1f29&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#f8f8f2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;keybindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;copy&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;singleLine&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+c&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;paste&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+v&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To open the search box</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;find&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+f&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To exit the Windows Terminal</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;closeWindow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+q&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To open the default tab</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+enter&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To duplicate the current tab and open it</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;duplicateTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+d&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//* To open the tab by index</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+3&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+4&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+5&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+6&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+7&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+8&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+9&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//* End</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//* To switch to a tab by index</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+3&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+4&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+5&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+6&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+7&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+8&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switchToTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+9&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//* End</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To close the tab</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;closeTab&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+q&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To close focused pane</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;closePane&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+w&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//* To resize a pane</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;down&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+down&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+left&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;right&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+right&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resizePane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;up&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+shift+up&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//* End</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//* To split a pane within current profile</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;horizontal&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+h&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vertical&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+v&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//* End</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//* To split a pane with another profile</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+3&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+4&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+5&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+6&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">6</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+7&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+8&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;splitPane&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;split&quot;</span><span class="punctuation">:</span> <span class="string">&quot;auto&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">8</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+alt+9&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">//* End</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//! To reset font size</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resetFontSize&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="string">&quot;alt+r&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学四年——从化学到通信再到计算机</title>
      <link href="/2021/08/28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E2%80%94%E2%80%94%E4%BB%8E%E5%8C%96%E5%AD%A6%E5%88%B0%E9%80%9A%E4%BF%A1%E5%86%8D%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
      <url>/2021/08/28/%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E2%80%94%E2%80%94%E4%BB%8E%E5%8C%96%E5%AD%A6%E5%88%B0%E9%80%9A%E4%BF%A1%E5%86%8D%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>为何想写这个东西呢？或许仅仅只想做一个总结，又或是想給别人传达一些东西。仅此而已。</p><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2><h3 id="不愿复读"><a href="#不愿复读" class="headerlink" title="不愿复读"></a>不愿复读</h3><p>在2017年，由于高考的失利，我仅仅只以1分的极大优势被重庆交通大学的应用化学专业录取。实在是不想复读了，并不是因为觉得复读辛苦而退缩。只是觉得再用一年去学那些重复的知识，没有任何的意义，只会重蹈自己高三一年的无聊。</p><p>那个时候在知乎，讨论化学为四大天坑的话题还是比较少的，但是也有许多对于这个专业前景的讨论了。在阅读了许多相关的前人的经验后，无论是处于世俗还是兴趣，我都决心努力换专业。</p><h3 id="初遇良师"><a href="#初遇良师" class="headerlink" title="初遇良师"></a>初遇良师</h3><p>由于在进校前就确定了转专业的目标，对于学习还是比较认真的。无论是同济出版的那本绿皮高数，还是无机化学上册，书后面的课后习题全部都做了，甚至还买了专门的题来刷。那时我并没有摆脱高中的思维。</p><p>但是，我遇到了我的学业导师。最让我印象深刻的是他给我们科普混沌理论的时候（蝴蝶效应就是混沌的一种经典现象），他说到我们从来没有思考我们正在学习的线性微分方程如果变为了非线性微分方程会怎么样。实际上，粗略地去理解就可以把蝴蝶效应当作非线性微分方程，初始条件发生变化，方程的解也会产生剧烈的变化。</p><p>我被震撼了，这时候我才明白自己做题所学的知识是如此的肤浅，根本无法去理解一个事物的本质所在。我在那时候对于微分和积分的理解甚是浅薄，我那个时候只会计算。</p><p>我一下就喜欢上了这个老师，通过和他的交流，我看了曼昆的经济学原理，看了博弈入门，这是我大学很重要的一步，我感受到了学无用之物的快乐，也就是单纯地学习知识的乐趣。</p><h3 id="哲学的兴趣"><a href="#哲学的兴趣" class="headerlink" title="哲学的兴趣"></a>哲学的兴趣</h3><p>偶然一次的图书馆之行，让我看见了卢梭的论人类不平等的起源和基础。一本小小的书第一次让我感觉到了思想的力量，或许在本书的论证中，卢梭并不是很严谨且富有逻辑。但是他带我走进了哲学的世界。</p><h3 id="转专业后的迷茫"><a href="#转专业后的迷茫" class="headerlink" title="转专业后的迷茫"></a>转专业后的迷茫</h3><p>大一下一开始就开始转专业了，因为刷题了，绩点自然就很高。当时为了寻找转什么专业，刷了很多的帖子，绝大多数都是转计算机的。说实话，那个时候我的想法很幼稚，觉得软件容易被淘汰，还是去学硬件，于是转到了大类专业电子信息类（通信工程、电子信息工程）。</p><p>转了专业后，由于那个时候的政策问题并没有立刻到电子信息类专业去学习，反而仍在应用化学专业学习。显然，下学期都不读这个专业了，学习的兴趣还是减少了许多，冲着评奖学金的心态，就刷题呗。因为在大学，成绩好不一定能代表你学到了真正的知识。</p><p>大一下上了我人生的第一门编程的课VB，我学的并不算特别好，是因为我仅仅只是局限于了这门语言，虽说我也学到了事件驱动，回调函数这些概念，但是却并没有深入，因为我转了专业也仅仅是转了而已，并不知道这个新专业要学什么，要做什么。</p><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h2><h3 id="疲于学业"><a href="#疲于学业" class="headerlink" title="疲于学业"></a>疲于学业</h3><p>转入新的专业后，学业压力十分大，因为要补大一的课还要上大二的课，加上实验课表从星期一到星期六几乎都是满的。大一的电路分析基础和C语言以及大二的数字电路、概率论和复变函数，说实在的，很是疲倦。因为是转专业的缘故，我选择了和计算机专业的一起学习C语言，也就是跨专业选课。</p><p>课多了，其实学不到很多知识。只能够应付考试，特别是大二学的电磁场与电磁波，我学得很差，但是我考的很好（真是讽刺）。</p><p>虽说疲于学业，但是我得到了许多成长，我不再认为成绩是衡量一个人的标准，所以我宁愿选择计算机专业的C语言，也不愿意跟着电子信息类学C语言，因为我可以学到我认为真正的知识。</p><h3 id="新的认知"><a href="#新的认知" class="headerlink" title="新的认知"></a>新的认知</h3><p>大二下，我需要补大一的线性代数和模拟电子技术。由于与大二课的冲突，这两门课我几乎都没有去听过，特别是模电，只有最后三周去上了课。那个时候学的线代教材也是同济的那一版，因为我几乎自学，所以选的教材是线性代数及其应用。我很幸庆我选择了这个教材，让我从空间的意义上理解了线代，矩阵意味着一个线性变换的操作。秩代表的是列向量空间的维度，而不是同济那本书极其僵硬的解释。</p><p>然后学习了信号与系统这门课，在我的理解里面，这门课就是函数空间。无论是傅立叶变换还是拉普拉斯变换以及Z变换，都是通过确立了函数空间的基向量来确定其坐标，从而实现了函数的变换。讽刺的是，由于线性代数的上课方式几乎以计算为主，学生对于其深层次的理解很差，导致了这门课大家觉得很难。</p><p>至此，我明白了一个道理。大学要靠自学，我们的教材很多都比不上国外的教材，并不是说传递的知识，而是在学习的过程中培养的思维。</p><h3 id="编程的入门"><a href="#编程的入门" class="headerlink" title="编程的入门"></a>编程的入门</h3><p>随着C语言、算法与数据结构以及单片机的学习，编程也算入门了。自己也能够解决迷宫问题了，能够用汇编语言写一个交通灯的应用了，虽然现在的源码自己无论如何也看不懂了，却让我体会到了编程的快乐，因为自己是在创造。</p><h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h2><h3 id="数模竞赛"><a href="#数模竞赛" class="headerlink" title="数模竞赛"></a>数模竞赛</h3><p>大三由于学业压力减少了，加上陆陆续续了解了学校的保研政策，决定去参加数学建模竞赛，以便在保研的时候可以加分。说实话，经历了学校的初赛以及培训，觉得学校培训的意义不是很大。而且，参加这个比赛令我相当的浮躁，觉得无法学到真正的知识，但是为了那个分，不得不做出妥协。</p><p>终于结束了这次数学建模的比赛，内心之中无不有许多的感想，当然很辛苦，但是我并不想把这种辛苦称为努力。这不能算真正的努力。首先，无论参加什么竞赛，一定要衡量好时间成本和兴趣。否则，这会是一个折磨。兴趣很重要，而且竞赛一定要是自己专业方向有关的，不能急功近利。其次，我要努力做自己！要努力踏实地培养自己的技术而不是这样自以为的努力，至少我这样认为，这样辛苦三天半，实际做出来的东西是相当少的，数学建模变成了语文建模，就在那里煎熬，我讨厌这样的自己，我希望自己是踏实的。大家都想获奖，但我真的没有实力，所以我觉得，获奖必须要自己有实力，希望自己有原则，不要因为这个迷失了自己。这几天真的相当难受，受折磨。不过还是很感谢数模，让我懂得了很多道理，虽说学业方面没有增长，但是人只有吃亏了才会成长！</p><p>这是我在数学建模完后写的感想。然而，或许是因为我们比其他人优秀的原因，最终得了一个全国二等奖，使得我保研的竞赛加分得满了，让我有了做自己喜欢的东西的资本。</p><h3 id="自我认知"><a href="#自我认知" class="headerlink" title="自我认知"></a>自我认知</h3><p>大三的课有很多都是专业方面的了，我很不喜欢通信专业的选修课，因为我们学校是交通大学，所以开了一门轨道信号控制。我觉得这门课选了肯定就是水的，于是我咨询了教务处，希望可以跨专业选择计科必修的操作系统原理。</p><p>我个人认为这是我很重要的一步，我并不拘泥于学校给我制定的培养方案，而是去学了自己觉得值得学习的科目。我也觉得，每个人都应该努力地去做到这一点，去认识自己，明白自己所想要的。</p><h3 id="第一次全栈开发"><a href="#第一次全栈开发" class="headerlink" title="第一次全栈开发"></a>第一次全栈开发</h3><p>选了一门选修课，却实现了自己的第一次全栈开发。Angular+MongoDB+NestJs的技术栈，最终把项目部署到了服务器上，整个过程用了半年，却让我能力得到了极大的提升，学会了看英文原版的书籍，认识到了RxJs的响应式编程的强大。其实最好的还是学习了Angular这个前端框架，虽说有很多不足，但是其许多后端思想对我影响还是比较大的。</p><h3 id="Linux的入门"><a href="#Linux的入门" class="headerlink" title="Linux的入门"></a>Linux的入门</h3><p>在网上刷帖的时候，看着别人说Linux，心里也觉得好奇，所以暑假的时候就在自己的电脑上装双系统，第一个发行版就是Ubuntu。装双系统会遇到很多的坑，也不记得自己到底重装了多少次，最终装上的时候，兴奋了一段时间，几乎还是用的Windows，因为Ubuntu的桌面总是报系统错误。</p><p>有一次，我看见教我全栈的老师的Linux桌面居然如此的炫酷，而且几乎没有系统错误，于是我问他，这个Linux是什么发行版的，他回到我Manjaro i3。当然，装双系统已经难不倒我了，但是当我装好的时候，看见系统桌面什么都没有，连应用都不知道打开。到后面慢慢摸索，去i3wm的官网学习。</p><p>我觉得自己十分的幸运，i3wm的逻辑让我觉得十分欣喜。第一次认识到原来桌面可以如此地有效率，减少鼠标和键盘之间的切换。</p><h3 id="无用之物"><a href="#无用之物" class="headerlink" title="无用之物"></a>无用之物</h3><p>大三上的时候，觉得自己应该还是会继续读通信工程的研究生，所以认识到自己的数学学得不好。无论是单元微积分还是多元微积分，我感觉自己的理解都不是很深刻，所以抽空学了MIT的数学系教材Introduction To Analysis以及Serge Lang的Calculus of Several Variables。同时也看了许多哲学作品。</p><p>无用之物的学习总是令人最快乐的，不需要考试，不需要去刷题。单纯地去学习知识，是很简单的乐趣。</p><h3 id="暗流涌动"><a href="#暗流涌动" class="headerlink" title="暗流涌动"></a>暗流涌动</h3><p>保研的争斗是很激烈的。实际上原先根本不知道别人发了论文，直到算综合加分的时候，才发现别人发了论文又有软著。对于发论文这个事情，我认为对于绝大多数的本科生没有必要发论文，有这个折腾的时间，不如去学一点真正的知识。（当然，这不适用于发高水平论文的本科生）。实际上，很多人写的论文是很水的。每当我去别人的博客和技术论坛看见其他人对于写作的认真和态度的时候，我总是告诫自己写东西这是要做到不浪费别人的时间，让看到的人或多或少能够有一些收获，没有收获，也能够得到一丝乐趣。</p><p>依稀记得还有同学为了争国奖在辅导员办公室吵架，我承认国奖有丰富的物质奖励，可是除了钱还有一些更重要的东西。</p><h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h2><h3 id="换专业的抉择"><a href="#换专业的抉择" class="headerlink" title="换专业的抉择"></a>换专业的抉择</h3><p>计算机还是通信呢，在提前给导师联系的时候，一直在思考自己前进的方向。如果继续选择通信，可以去很好的学校，对于我本科是双非的来说，总有点名校的情结。我记得那个时候十分的纠结，直到我在知乎上看见了孔良先生写的做自己喜欢的事。我毅然决定追随自己的兴趣，选择了计算机。</p><p>我对于通信这个专业的看法很复杂，实际上这个专业涉猎了很多的方向，无论是嵌入式还是网络以及传统的物理层，都可以进行深入。但是可能是因为学校培养方案的原因加上这个专业本身的杂糅，我们学习的东西相当的多，不是很精。我身边有成绩很好的朋友也觉得自己虽然成绩很好，但是没有学到很多实用的东西。</p><p>然而，我却觉得这样却给了我们很多的方向。比如说可以去计算机，也可以去做信号处理，FPGA。所以对于通信专业来说，最重要的是不要被学校的培养方案所绑架了，也就是不能被学校所安排了。至少，这么多的方向给了我们不同于其他专业试错的可能性。但是如果没有自己的想法，出来以后不好找待遇比较好的工作。</p><h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h3><p>没错，大四这一年由于已经保研了，学业是最为轻松的时候。我选择了函数式编程来学习。虽说，这门语言在工业界的应用很少，但是其思路我觉得是值得每一个程序员去学习的。或许仍然没用，但是无用之物的学习永远是最为快乐的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，这篇文章写的很散，像流水帐一样。写这篇文章的想法还是希望能够给无论是化学专业还是通信专业又或是其他专业的学生提供一点我的经历，让各位能有所思考。我还是觉得，大学不仅仅是学习知识的地方，更是我们去认识自己的地方。在初中和高中，我们的目标都很简单，考高中和考大学。然而，大学本身就是多元化的。每个人有每个人的想法，有自己的追求。</p><p>在大学，要多去尝试不同的学科，说实在的，因为我们在进大学前本就是一张白纸，对于自己所选的专业认识是很浅薄的。所以要去试错，找到自己感兴趣的东西（当然，也可能找不到）。因为，我们在中学的教育不是很强调我们的个性，我们很难去思考考上大学后，我们应该做什么，应该成为什么样的人。</p><p>每个人都有自己对于生活的态度和答案。最重要的是去寻找自己的答案。然而，我们的大学变得像技校一样，因为效率的原因，必须给学生传递知识以使得学生能够适应社会，满足社会的需求。然而，大学一定是发问的地方，是我们认识自己很重要的一个阶段，是培养独立之灵魂、自由之思想的地方。</p><p>从化学到通信再到计算机，算是一个很大的跨越了。虽说过程很辛苦，但是我觉得很幸运，因为我觉得这是我认识了自己的原因。不再以单一的思维看待事物，变得更加宽容。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zotero安装及使用教程</title>
      <link href="/2021/04/22/Zotero%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2021/04/22/Zotero%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>参考<a href="https://www.zotero.org/support/installation">官网教程</a>。</p><p>在ArchLinux直接通过包管理器安装Zotero：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S zotero</span><br></pre></td></tr></table></figure><p>同时，安装完软件后，需要在浏览器安装插件<a href="https://github.com/zotero/zotero-connectors">Zotero Connector</a>。</p><h2 id="2-基本概念定义"><a href="#2-基本概念定义" class="headerlink" title="2. 基本概念定义"></a>2. 基本概念定义</h2><p>此部分主要阐述Zotero最重要的三个概念。</p><h3 id="2-1-Item"><a href="#2-1-Item" class="headerlink" title="2.1 Item"></a>2.1 Item</h3><p>在Zotero中存在着许多概念，这些概念在本质上都是基于Item概念的基础上定义的。官方文档给出的Item的定义如下所示：</p><blockquote><p>Every item contains different metadata, depending on what type it is. Items can be everything from books, articles, and reports to web pages, artwork, films, letters, manuscripts, sound recordings bills, cases, or statutes, among many others.</p></blockquote><p>从官方文档的定义可以看出，Item就是一个结构体变量，包含了不同的元数据，如下图所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/24/Kcs74rOiVJEl9ux.png" alt="Zotero的Item组成结构示意图"></p><h3 id="2-2-Collection"><a href="#2-2-Collection" class="headerlink" title="2.2 Collection"></a>2.2 Collection</h3><p>音乐播放器的播放列表通常可以创建多个音乐列表，每个音乐列表可以包含不同的音乐。Collection的作用正如同播放列表一样，用于组织Item，如下图所示。</p><p><img src="https://i.loli.net/2021/04/24/EhzfvaB5KnsNjAg.png" alt="Collection结构示意图"></p><h3 id="2-3-Tag"><a href="#2-3-Tag" class="headerlink" title="2.3 Tag"></a>2.3 Tag</h3><p>Tag的含义很好理解，就是标签，另一种组织Item的方式。</p><h2 id="3-添加Item"><a href="#3-添加Item" class="headerlink" title="3. 添加Item"></a>3. 添加Item</h2><p>本部分阐述添加Item的方法。</p><h3 id="3-1-通过浏览器"><a href="#3-1-通过浏览器" class="headerlink" title="3.1 通过浏览器"></a>3.1 通过浏览器</h3><p>首先需要在浏览器安装插件Zotero Connector。</p><p>假设找到了一篇文献<a href="https://i.loli.net/2021/04/22/mVPRFHW8vpodecK.png">Microservices: Yesterday, Today, and Tomorrow</a>。打开网页后，使用插件直接添加Item，如下图所示。</p><p><img src="https://i.loli.net/2021/04/22/mVPRFHW8vpodecK.png" alt="通过浏览器添加Item示意图"></p><p>同时Zotero还支持添加通用的网页和PDF文件作为Item，此处不赘述，还有一种情况就是当Zotero遇到某些网页含有多个Item的信息后，会弹出复选框进行选择，如下图所示。</p><p><img src="https://i.loli.net/2021/04/24/HEr2kLyN7QY1iUm.png" alt="包含多个Item示意图"></p><h3 id="3-2-通过标识符"><a href="#3-2-通过标识符" class="headerlink" title="3.2 通过标识符"></a>3.2 通过标识符</h3><p>Zotero同时支持通过标识符直接添加Item。可以添加以下的标识符：</p><ul><li><a href="https://en.wikipedia.org/wiki/International_Standard_Book_Number">ISBN</a></li><li><a href="https://en.wikipedia.org/wiki/Digital_object_identifier">DOI</a></li><li><a href="https://en.wikipedia.org/wiki/PubMed">PubMed ID</a></li><li><a href="https://en.wikipedia.org/wiki/ArXiv">arXiv ID</a></li></ul><p><a href="https://i.loli.net/2021/04/24/RY6WGgAEfxLMwmH.png">通过标识符添加Item</a></p><h2 id="4-添加文件"><a href="#4-添加文件" class="headerlink" title="4. 添加文件"></a>4. 添加文件</h2><p>文件可以作为一个单独的Item，也可以作为已经存在的Item的子Item。例如当存储一个PDF文件至Zotero时，Zotero会尝试获取该PDF文件的元数据并自动创建其父Item。如果无法识别其元数据，该PDF文件将会作为一个单独的Item存在。</p><p>Zotero的文件可以作为两种方式管理：</p><ul><li>实际文件：存储在<a href="https://www.zotero.org/support/zotero_data">Zotero data directory</a>。</li><li>链接文件：存储文件在磁盘中的位置。</li></ul><h3 id="4-1-通过浏览器添加"><a href="#4-1-通过浏览器添加" class="headerlink" title="4.1 通过浏览器添加"></a>4.1 通过浏览器添加</h3><p>当Zotero通过浏览器添加Item时，Zotero Connector会自动识别与该Item相关的网页快照和PDF文件，保存的网页快照和PDF文件将会作为实际文件保存到Zotero data directory中。</p><h3 id="4-2-通过Zotero软件添加"><a href="#4-2-通过Zotero软件添加" class="headerlink" title="4.2 通过Zotero软件添加"></a>4.2 通过Zotero软件添加</h3><p>直接拖拽到相应的Item中即可，默认将会直接复制原文件至Zotero data directory中，如果需要使用链接文件，在拖拽的使用，按住如下按键：</p><ul><li>Windows&#x2F;Linux：Ctrl+Shift</li><li>macOS: Cmd+Option</li></ul><p>也可以直接通过按钮添加文件，如下图所示：</p><p><img src="https://i.loli.net/2021/04/24/LOdG83VIYiNrZT6.png" alt="通过按钮添加文件"></p><h2 id="5-RSS订阅"><a href="#5-RSS订阅" class="headerlink" title="5. RSS订阅"></a>5. RSS订阅</h2><p>Zotero也可以添加RSS订阅：</p><ul><li>URL</li><li>OPML</li></ul><h2 id="6-管理Item"><a href="#6-管理Item" class="headerlink" title="6. 管理Item"></a>6. 管理Item</h2><p>直接通过按钮添加Collection，如下图所示。至于如何添加&#x2F;移除Item到Collection、重命名Collection以及删除Collection的操作此处不赘述。</p><p>通过按钮添加Collection<br>通过按钮添加Collection</p><p>在Zotero中有几个特殊的Collection：</p><ul><li><code>My Publications</code>：顾名思义。</li><li><code>Duplicate Items</code>：多余的Item，如何对其操作请参考官方文档。</li><li><code>Unfiled Items</code>：包含没在任何一个Collection的Items。（无家可归的幽魂）</li><li><code>Trash</code>：顾名思义。</li></ul><p>Tag的操作也比较简单，此处不赘述，可参考官网文档。</p><h2 id="7-同步与备份"><a href="#7-同步与备份" class="headerlink" title="7. 同步与备份"></a>7. 同步与备份</h2><h3 id="7-1-同步"><a href="#7-1-同步" class="headerlink" title="7.1 同步"></a>7.1 同步</h3><p>Zotero的同步分为了两个类型：</p><ul><li>数据同步：可以直接使用Zotero提供的同步服务，免费且方便，创建一个Zotero的账户即可。</li><li>文件同步</li></ul><p>文件同步相对来说要复杂一下，首先是实际文件的同步。Zotero提供了对实际文件同步的功能，这一部分采取的是订阅制，免费用户可用的同步空间是300M。</p><p>当然也可以使用替代方案，通过WebDAV实现同步。目前国内比较好用的WebDAV也就只有坚果云了，目前使用坚果云实现同步的教程较多，此处不赘述。</p><p>除了对实际文件的同步以外，也可以进行对链接文件的同步，其本质的思路是在不同的主机上保存不同的文件链接。</p><h3 id="7-2-备份"><a href="#7-2-备份" class="headerlink" title="7.2 备份"></a>7.2 备份</h3><p>在Zotero data directory中最重要的文件是<code>zotero.sqlite</code>，同时也包含了目录<code>storage</code>，该目录主要是附件内容。</p><p>备份只需要对Zotero data directory进行备份即可，至于其他的备份方法，参考官方文档。</p><h2 id="8-可供参考资料"><a href="#8-可供参考资料" class="headerlink" title="8. 可供参考资料"></a>8. 可供参考资料</h2><p>本教程几乎没有对细节的问题进行阐述，例如如何使用坚果云及其他国外支持WebDAV的网盘实现实际文件的同步、标签的具体使用、参考文献的导出和第三方插件的使用等问题。本教程着重点在于给读者对该软件有一个大方向的认识。因此在本教程的最后列出官网以及其他教程的参考资料供读者解决某些实际问题。（没有必要重复造轮子）</p><ul><li><a href="https://www.zotero.org/support/">Zotero官网参考资料</a></li><li><a href="https://help.jianguoyun.com/?p=4190">坚果云使用 Zotero 配置过程详解</a></li><li><a href="https://www.zotero.org/support/">Windows Word使用Zotero插入参考文献</a></li><li><a href="https://www.douban.com/group/topic/79928493/">Zotero教程入门六篇</a></li><li><a href="https://zhuanlan.zhihu.com/p/26765443">知识管理软件Zotero的使用</a></li></ul><h2 id="9-个人使用感受"><a href="#9-个人使用感受" class="headerlink" title="9. 个人使用感受"></a>9. 个人使用感受</h2><p>实际上，Zotero也有许多的插件，个人认为没有必要安装。例如使用MarkDown做笔记这个功能，为何不使用专门的MarkDown编辑器写然后添加文件到Item上呢？</p><p>Keep it simple and doing one thing well.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人性的枷锁》读书笔记</title>
      <link href="/2021/03/15/%E3%80%8A%E4%BA%BA%E6%80%A7%E7%9A%84%E6%9E%B7%E9%94%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/15/%E3%80%8A%E4%BA%BA%E6%80%A7%E7%9A%84%E6%9E%B7%E9%94%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>他不知不觉养成了一个世上最令人愉悦的习惯：阅读。他并没有意识到已经找到了一个可以逃避世上所有烦忧之事的庇护所，不过他也不知道自己所创造的这个虚无的世界让日常生活的现实世界成了痛苦失望的源头。</p></blockquote><blockquote><p>他并不知道，在人生的旅途中，需要跨越多少艰难险阻才能获得自己想要的理想生活。年轻是快乐的，那只是幻想，只是那些青春已逝者的幻想。但年轻人知道他们是多么的可悲，因为他们被灌输了满脑子虚假的思想；每次只要他们一接触现实，就会伤得鼻青脸肿。他们像是阴谋的牺牲品，因为他们看的那些书，那些精心筛选的思想，长辈对他们的淳淳教诲——那些他们通过健忘的玫瑰色烟雾回顾的过往——所有的一切只是给他们准备了一种虚假的生活。他们必须亲自去发现，他们读过的书，听过的教诲统统都是谎言、谎言、谎言。在人生的十字架上，每一次新的发现只不过是在他们的身体上钉入一枚钉子。奇怪的是，所有经历痛苦幻灭的人，在自身克服不了的力量的驱使下，反而会在不知不觉中又去增加了这种幻想。</p></blockquote><blockquote><p>他喜欢米格尔，却烦恼地意识到，米格尔虽然付出了很大努力，却纯属徒劳：他具有成为一名优秀作家所需的全部素质，却独独缺乏天赋。菲利普看着他自己的作品。如何才能看出来，这幅画是出色不凡，还是在浪费时间？显而易见，一心追求成功，对你毫无帮助，对自己有信心更是毫无意义。</p></blockquote><blockquote><p>他厌恶格里菲斯的道歉，他没那个耐心管他是否受到了良心的责备。他若是愿意，就可以做出卑鄙的事情，事后又来后悔，那才叫卑劣。</p></blockquote><blockquote><p>这里没有好也没有坏。这就是现实。这就是生活。</p></blockquote><blockquote><p>菲利普糊涂了。他问自己，生活的法则到底是什么。如果他的那条法则毫无用处，为什么人们要这样做，而不是那样做呢？他们根据自己的情感行事，但他们的感情有好有坏。成功或失败似乎只是运气使然。生活好像是一团解不开的乱麻。人们四处奔走，被他们所不知道的力量驱使着，却不知道人生有何目的。他们似乎只是为了忙而忙。</p></blockquote><blockquote><p>在巴黎，他就了解到，这世上既没有丑，也没有美，只有真实，对美的追寻只是感情用事。</p></blockquote><blockquote><p>她这种女人根本意识不到，有的男人并不像她那样，满脑子只有色情思想。</p></blockquote><blockquote><p>为了不让先前所学忘个精光，一开始菲利普仍试图继续钻研那些医学典籍，但后来他发现这并无用处。一天工作以后已是筋疲力尽，很难再集中精力苦读，而且他回归医院的日子遥遥无期，继续攻读似乎也是无济于事。</p></blockquote><blockquote><p>有时，你与某人终日相对，亲密无间，甚至无法想象没有他的日子该如何挨过，后来因故分离，却发现一切如旧，有他无他似乎并没有什么区别，生活的车轮不断往前，再后来，甚至连思念也淡薄无迹了。</p></blockquote><blockquote><p>菲利普绝望地拷问自己，生命究竟有什么意义？</p></blockquote><blockquote><p>竭尽所有却无法换来预想的结果，青春时的璀璨希冀总以惨痛的幻灭收场，生命的天平终将倾向盛满磨难、病痛和不幸的那一端。所以，活着究竟有何意义？</p></blockquote><blockquote><p>答案很明显。生命并无意义可言。</p></blockquote><blockquote><p>生而为人，历经磨难，驾鹤西归。生命没有意义，人活着也没有什么终极目的。一个人无论是降生与否、生存与否，都无关紧要。生亦不足道，死亦不足惜。</p></blockquote><blockquote><p>菲利普想到了芸芸众生，生活对他们来说不过是劳作糊口，既无美好之言，亦无丑陋可憎，他们对生活赠予的一切欣然接受，就像接受四季变迁一般自然。他盛怒激愤，因为一切皆无用处。他无法甘心接受生活是无意义的，但是他目睹及思索的一切都只是令他更加确信这一点。</p></blockquote><blockquote><p>他为过去两年困苦交加的生活而悔恨不已，他苦苦挣扎，只求能生存下去，也因此感受不到生活的痛苦。“只有付出劳动才能换取食物”，这句话不是人类的诅咒，而是人类向生活低头时的慰藉之言。</p></blockquote><blockquote><p>在圣卢克医学院的最后一年，菲利普十分刻苦地学习。他对生活感到心满意足。他发现，一不为情所困，二有钱满足自己的需要，真是太惬意了。</p></blockquote><blockquote><p>从早到晚为一日三餐操心真是这世上最不体面的事。我鄙视那些轻贱金钱的人。他们要么是伪君子，要么就是傻瓜。金钱就跟第六感一样，没有了它，其他五种感觉也就没法完全利用起来了。没有足够的收入，生活中一半的可能性也就消失了。你得小心翼翼，赚多少花多少。你会听到人们说，贫穷是画家最大的动力。他们会这么说，都是因为他们从未尝过受穷的滋味。他们压根儿就不知道，没有钱，人会变得多么微不足道。你会受到无穷无尽的羞辱，折断你的羽翼，如同癌细胞一样，啃噬你的灵魂。人们追求的不是财富，而是足够维持尊严的钱财，可以不受阻碍地工作，可以慷慨坦率，独立自主。不管是作家，还是画家，我都衷心地同情那些只依靠艺术来维持生计的艺术家。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>活着的意义是什么呢？毛姆又对这一人生哲学问题进行了发问。</p><p>这部小说讲述了菲利普从幼年到中年的故事。青年的叛逆让菲利普逃离了伦敦，前往了德国，最后又去了巴黎学习艺术。小说在巴黎阶段是一个高潮部分。普莱斯的死亡让菲利普重新审视了自己可谓是巴黎篇中最具有现实意义的部分。不能够忽略金钱的作用，金钱维持着一个人的尊严。</p><p>后面，菲利普到伦敦学医的故事，对菲利普影响最大的女人米尔德里德。这个女人在前面无非就是在利用菲利普，而说来讽刺的是菲利普居然陷入了情网之中，无法自拔。更讽刺的是，这个女人经历了种种磨难，真心觉得菲利普是一个善良之人时，菲利普的爱意早就已经淡去了。</p><p>令我感触的是，菲利普因为投资失败亏了一大笔钱，学业也无法支持的时候，只能期望伯父去世的遗产，打着辛苦的工作，领着微薄的薪水，才会明白钱的重要性。我们获得巨大的财富可能性是很低的，然而必要的钱是必需的。</p><p>贯穿故事主线的就是对人生的意义的发问。克朗肖赠予菲利普的毛毯无非就是我们书写的人生，就根本没有意义，而我们仍然是在书写的，就如同余华的《活着》所阐述的观点一样：活着就是活着。在巴黎，克朗肖和菲利普的对话也让我思考了不少。姑且不论克朗肖的宿命观，他认为每个人都是其自身的中心，而社会通过武力方式将个人凝聚在一起。无论是社会还是个人，都争取自我保全，个人因为力量薄弱不得不接受社会。社会制定法律，同样是自我保全。不过是一场交易。实际上，这一部分讨论了社会与个人的关系。</p><p>读这种对人生哲学发问的书籍，很难写出内心所想，那就以书封面的话来结尾吧：</p><blockquote><p>人生，究竟是一场华丽的冒险，<br>还是用千篇一律的枷锁套上百无聊赖的皮囊？<br>我们终其一生都在寻找生命的意义，<br>可最后发现，人生本来就是一场没有意义的旅途<br>那些禁锢命运的一道道枷锁，<br>只不过是我们沉浸在过往与未来的幻想罢了。<br>无论我们做出怎么样的努力和选择，<br>经历怎么样的繁华或苍凉、荣耀或痛苦，<br>生活最终都会回归于平凡,<br>而平凡才是生活的真谛。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悠久之翼</title>
      <link href="/2021/03/07/%E6%82%A0%E4%B9%85%E4%B9%8B%E7%BF%BC/"/>
      <url>/2021/03/07/%E6%82%A0%E4%B9%85%E4%B9%8B%E7%BF%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>只玩了游戏没有看过动漫，所以只对游戏本身进行评价。</p><p>玩过游戏的人都知道，这部GalGame分为了上篇The First Tale和下篇The Latter Tale，其整体的结构是相互关联的，我觉这部GalGame对于剧情的处理相当优秀，许多地方都是伏笔。例如我在打上篇的时候很是奇怪明明景和京介的故事发生在夏天，到了下篇千寻和莲治故事却发生在冬天。当然原因在后面也得到了解释。</p><p>然而，在通关这部GalGame后，我总觉得这部GalGame在某些部分缺少了张力，或者说我并不是很认同这部作品传递出来的某些价值观。</p><p>在上篇的故事中，故事还是比较温馨的：</p><p>广野纮和宫子的爱情故事体现出的是选择并承担责任的意义。纮在爱情上是选择景还是宫子，在事业上是选择学业还是画家？这个故事中，优子传递出的价值观：</p><blockquote><p>重要的东西决不只有一个。你想要的东西，失去任何一个都会后悔。为了不失去重要的东西该作些什么，从那开始，就需要你自己在考虑了。</p></blockquote><blockquote><p>取回什么东西的时候，必然也要同时失去些什么，不是吗？</p></blockquote><p>是的。无论做什么决定，都必然要伤害另一人，哪怕会因此失去重要的其他事情，也应做好觉悟。</p><p>景和京介的故事是一个相互救赎的故事，但说实话，这个故事本可以更有深度的，却流于表面。景因为纮的事情受到了伤害，舍弃了篮球。京介热爱着自己的梦想。优子对他们提出的质问如下：</p><blockquote><p>你曾经受过一次伤害，所以，害怕再次受伤。害怕着得不到想要的东西，就算现在有想要追求的东西也畏惧不安。你不承认自己是在停滞不前，不承认自己是在恐惧，不是吗？从头再来，谁都可以轻易的说出来。新藤景小姐，而你却只是在一边原地踏步，一边希望什么时候有谁能够拉着你哪里去。</p></blockquote><blockquote><p>你真的恋爱过吗？人的心，只有梦想的话是装不满的哦。</p></blockquote><p>同时，优子也提出了类似的价值观：</p><blockquote><p>只要活着，就会不停地失去什么，这个已经是决定而不可改变的事实。为了埋葬失去的事物而继续活下去，然后又会再次失去。重要的是去寻找，不停的寻找无比重要的东西。失去重要的东西的话，任何人都会悲伤流泪，新藤景小姐，你清楚的明白那份悲伤。</p></blockquote><p>姑且不论景战胜了自己，从跌倒处站起来。我觉得这个故事对于京介的梦想的抉择描述的太少了，到底京介的梦想只是个执念，还是京介真的自己想要做的事情。以及梦想和爱情之间的关系问题，这个故事都没有触及。每个人都有每个人对幸福的看法，难道心光有梦想就一定装不满吗？一定要有爱情？说实在的，我很不认同这个故事在这一点体现出的价值观。</p><hr><p>在下篇，讲述了三个故事：</p><p>千寻和莲治。我个人感觉这个故事刻画出来的千寻是不真实的，千寻患有的记忆障碍，使她这个个体是不延续的。昨日的她与今日的她的纽带是那本日记。然而奇怪的是，她却存在于此时此刻，并没有缺席于现在，在每天的时光里，她仍然能感受到自己的存在（哲学意义上的）。</p><p>我们人都是由历史构成的，然而千寻却失去了历史的她。我觉得这种痛苦是很难承受的，而莲治却坚持地做着他认为对的事情。难道他意识不到这样做会对她造成伤害吗？</p><p>但是，这部GalGame传递出来的价值观正如同优子在上篇传递的一样，无论如何都会失去，与其沉溺在其中不断悲伤，还不如去珍惜现在的温柔。我不是很喜欢这种观点，相濡以沫不如相忘于江湖。</p><p>瑞希和修一。这个故事让我觉得愤慨，修一是一个将死之人，因为病情的原因无法继续自己的梦想。决定将自己的小提琴烧掉，同时也烧去自己的存在。当然，最后并没有烧掉。我就在想为什么不能让修一优雅地结束掉自己的存在呢？什么要去否定一个人结束自己的想法呢？</p><p>瑞希喜欢修一，修一觉得自己的生命即将要结束了，只会给两人带来痛苦，因为瑞希还拥有无限的可能性，而修一却不能的。修一这样做的正确性和瑞希坚持的正确性都有各自的道理，然而为什么不能深化一下这方面的矛盾呢？</p><p>最后的故事是夕和优子，我不想谈论这个故事以及优子的人物形象。我只想讲一讲优子的兄长。这个人因为在优子身上看到了过去自己的妹妹影子，对优子做了不可饶恕之事，然而优子选择了隐忍，这是我最无法接受的事情，这样的事确实在现实生活也存在，但是为何优子无法鼓起勇气呢，是因为她也无处可去？为何不能向养父母透露事情的真相呢？</p><p>还有就是为什么优子最后就这样出了车祸呢？这种方式过于地刻意了。</p><hr><p>正如同游戏名一样《悠久之翼》，最后借瑞希之口说出了这个游戏名的含义。坚强与脆弱、生存和死亡等都是一对翅膀，一只翅膀是无法飞翔的。一个人也是无法飞翔的，所以需要他人。</p><p>说实在的，我接受不了这个观点。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chaos;Child</title>
      <link href="/2021/03/06/Chaos-Child/"/>
      <url>/2021/03/06/Chaos-Child/</url>
      
        <content type="html"><![CDATA[<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>打完这部作品，难免想问一问自己：自己是否也在妄想中逃避了自己呢。</p><p>这是一部立意极其深刻的作品。作品一直围绕着一个主题：是宁愿沉溺在妄想中而不自知，还是宁愿接受残酷的现实而得以成长呢。男主最终选择了后者。</p><p>我特别喜欢男主这个角色，在前期男主认为自己是“情强”，懂得如何收集有用信息。男主看不起那种“情弱”的人。实际上这部作品对于“情弱”的讽刺是相当深刻的，对许多面对网络上的信息不加以仔细分辨的人进行了深刻的批判。实际上，现在的网络环境也是如此。大家都不愿意以尊重的态度进行交流。</p><p>但是，在后期男主发现正是因为自己的愿望导致了一系列事件的发生，陪伴在自己身边的女子世莉架也是由于自己的愿望产生的，对于男主说的那句话，我特别受触动：</p><blockquote><p>“…我，是情弱”<br>“就连自小就一直伴我身旁的【青梅竹马】的事…都一概不知”</p></blockquote><p>其实，男主为什么想成为“情强”呢？我个人的解读是男主希望得到认可。男主自称是现充，但却与不熟悉的人讲话有很大的困难。男主内心是弱小的，因为他想得到认同，想证明自己和那些宅是不同的。也正因为如此，男主强烈的愿望让女主做出了绝不应该做出的事情。男主也正是因为经历了这一系列的痛苦才得以成长，从妄想迈向了真实。</p><p>我觉得作者也对“情强”进行了讽刺，男主探索事件的时候，很是好奇激动，可谓是充满了热情，但是当事件降临到男主的身边的时候，男主觉得痛苦、胆怯。我们这些所谓的“情强”是不是也是自视清高，自以为自己掌握了情报，不以人的态度去尊重别人呢？我觉得这是我必须进行反思的地方。</p><p>相对来说，个人线的节奏变慢，让我觉得十分难以适应（相对于共通线而言）。</p><p>最终，男主选择了真实。这是这部作品最光辉的时刻。这不经意让我想起《白色相簿2》我最喜欢的一句话：</p><blockquote><p>是像现在这样，拼命在痛苦中挣扎呢…还是去经历比现在更加痛苦的事，然后变得比现在，稍微幸福一些呢…</p></blockquote><p>是的，沉浸在自己的世界里，沉浸在不现实的妄想之中，是不现实的。而唯独抱着痛苦的觉悟走向真实才能够得到救赎。但是，我有时候也难免沉浸在幻想之中，希望能够拥有二次元的甜美的爱情。我只是觉得，正因为我们是人，所以难免会有时候沉浸在美妙的幻想支中。</p><p><strong>但也正因为我们是人，也能够拥有如同男主一般的勇气斩断妄想迈向残酷的现实。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 游戏笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GalGame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我的青春恋爱物语果然有问题》读书笔记</title>
      <link href="/2021/03/06/%E3%80%8A%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD%E6%9E%9C%E7%84%B6%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/03/06/%E3%80%8A%E6%88%91%E7%9A%84%E9%9D%92%E6%98%A5%E6%81%8B%E7%88%B1%E7%89%A9%E8%AF%AD%E6%9E%9C%E7%84%B6%E6%9C%89%E9%97%AE%E9%A2%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一卷"><a href="#第一卷" class="headerlink" title="第一卷"></a>第一卷</h2><h3 id="①-总而言之比企谷八幡是个废柴"><a href="#①-总而言之比企谷八幡是个废柴" class="headerlink" title="① 总而言之比企谷八幡是个废柴"></a>① 总而言之比企谷八幡是个废柴</h3><blockquote><p>“不是这样的吧…比如什么你变了或者改改吧，不喜欢他人随便地跟我提【自我】。而且本来被别人说两句就能改变的根本就不是【自我】吧？所谓真正的自我…”</p></blockquote><h3 id="②-不管何时雪之下雪乃都会贯彻始终"><a href="#②-不管何时雪之下雪乃都会贯彻始终" class="headerlink" title="② 不管何时雪之下雪乃都会贯彻始终"></a>② 不管何时雪之下雪乃都会贯彻始终</h3><blockquote><p>“她也一定存在着一些毛病。温柔而又总是正确。但是这世界却并不温柔也绝不正确。所以活得相当累吧”</p></blockquote><blockquote><p>“我说你啊，有朋友么？”<br>我一问出口，雪之下就立刻将视线转向别处。<br>“…嗯，那么首先怎么样的关系能定义为朋友呢？”<br>“啊，够了。这台词是没朋友的人的台词”</p></blockquote><blockquote><p>“你想说的我也不是不明白。一个人也能愉快地享受时间，不如说反对一个人生活的价值观才让人觉得恶心”<br>“…”<br>雪之下一瞬间望了我一眼，然后立刻转回前方并闭上双眼。看上去似乎是在思考什么。<br>“明明就是喜欢自己一个人待着却要接受周围怜悯的视线很让人恼火呢，我非常明白的”</p></blockquote><blockquote><p>“但是，我认为那也是没有办法的事。因为没有人是完美的。软弱，内心丑陋，很容易嫉妒排挤他人。令人觉得不可思议的是越优秀的人活得越痛苦，在这个世界上。这不是很奇怪吗？所以我要改变，改变每个人，改变这个世界”<br>雪之下的眼神明显是认真的，干冰一样冷酷得仿佛要让人灼伤。</p></blockquote><blockquote><p>通过隐藏真相，配合他人，隐瞒欺骗，来一边敷衍自己和他人，一边高明地处事，这应该并不难。因为世界上有很多人正是这样做的。<br>就像擅长学习的人在考试中得到高分也说是偶然或称自己只是押中了题一样。也好像美少女被不漂亮的女生抱有偏见时会说自己的皮下脂肪最近变得怎么样怎么样来主张自己丑的一面一样。<br>但是雪之下不那样做。<br>自己绝对不会说谎。<br>唯独那态度我不是不做评价。<br>因为那和我是一样的。<br>话一说完雪之下便再次将视线落在文库本上。<br>看到她那样子，我不自觉地陷入了奇怪的感情中。<br>——我和她一定有什么地方很相似。我这样感觉到。<br>——感到现在就连这沉默也让人觉得莫名地心情舒畅。<br>——感觉到心跳稍微有些加速。心脏跳动的节奏像是要超过秒针转动的速度，想要向更前方移动，感觉我是想说这个。</p></blockquote><h3 id="③-由比滨结衣总是东张西望的"><a href="#③-由比滨结衣总是东张西望的" class="headerlink" title="③ 由比滨结衣总是东张西望的"></a>③ 由比滨结衣总是东张西望的</h3><blockquote><p>听到她这么说，雪之下呼地发出短暂的叹息。<br>“…原来如此。我知道该怎么解决了”<br>“怎么做？”<br>听到我这么问，雪之下平静地回答道。<br>“唯有通过努力”<br>“那算是解决方法吗？”<br>只有努力了，无法加入其他要素，换言之意思就是已经没有行得通的方法了。说白了就和毫无策略没差。不如干脆告诉她没有希望所以罢手吧要来的轻松多了。没有什么能比白白努力更加让人空虚了。不如为她指条明路让她把时间和精力用到其他事情上才更有效率。</p></blockquote><blockquote><p>“由比滨同学。你刚才说你没有料理才能吧”<br>“诶。啊。嗯”<br>“你的那个想法要改正。连最低限度的努力都没有做的人没有资格羡慕有才能的人。无法成功的人是因为无法想象成功者不懈的努力才成功不了的”</p></blockquote><blockquote><p>由比滨腼腆的笑声要消失的时候传来了咣当的放下茶杯的声音。虽然那只是沉稳的非常小的声音，但却像是晶莹剔透的冰一般的音色。不由分说将视线转向发出声音的人。看到了放出皎洁而犀利的气氛的雪之下。<br>“…能不能放弃你那想配合周围人的想法。令人非常不愉快的。忽视你自己的笨拙，一败涂地以及愚蠢去追究他人的间接原因，不觉得可耻吗？”</p></blockquote><blockquote><p>“…真的就这样就好了吗”<br>雪之下望着门的方向轻声说道。<br>“我的话只要还有提高的空间就应该不断挑战自身的极限。最终也是为了由比滨同学好不是吗？”<br>“嘛，的确是真理。努力是不会背叛自己的。虽然梦想一直在背叛”<br>“有什么区别”<br>“即使努力也不一定能实现梦想。不但说实现不了的还比较多。但是曾经努力过的事实却足以安慰自己”<br>“这不只是自我满足么”<br>“反正又不是背叛自己”</p></blockquote><h3 id="④-尽管这样班级也如往常一样"><a href="#④-尽管这样班级也如往常一样" class="headerlink" title="④ 尽管这样班级也如往常一样"></a>④ 尽管这样班级也如往常一样</h3><blockquote><p>“也是呢。嗯，其实我也不知道在说些什么…但是，看着小企和小雪我就会开始想。明明周围没有任何人，却一样很快乐，明明是毫不在意对方地吐露心声，却又似乎照应着彼此…”</p></blockquote><blockquote><p>“什么嘛，不是能好好说出来嘛”<br>那个瞬间她露出的微笑让我完全忘记了思考。<br>并非自嘲或是谩骂亦或悲伤，纯粹无暇的微笑。</p></blockquote><h3 id="⑤-也就是说材木座亦辉不太正常"><a href="#⑤-也就是说材木座亦辉不太正常" class="headerlink" title="⑤ 也就是说材木座亦辉不太正常"></a>⑤ 也就是说材木座亦辉不太正常</h3><blockquote><p>想要写下什么，为了能让人读而写。并且以此打动人心为乐。所以会不断写下去。即使不被他人认同，他也会这么写下去。这种状态就叫做作家病。</p></blockquote><blockquote><p>说完材木座于是转过身去，堂堂地走出了教室。<br>他关上的门让我感到很耀眼。<br>尽管扭曲幼稚失败，但是只要坚持下去就是正义。如果只是被人否定就要改变的话，那种东西既不是梦想也不是自我。所以，材木座不需要改变自己。</p></blockquote><h3 id="⑥-但是户塚彩加很走运"><a href="#⑥-但是户塚彩加很走运" class="headerlink" title="⑥ 但是户塚彩加很走运"></a>⑥ 但是户塚彩加很走运</h3><blockquote><p>但是，材木座的心情也不是不能理解。事实上，看上去很单纯的人说不定也有非常感性的一面，不由地产生了一丝背叛他人的罪恶感。</p></blockquote><blockquote><p>这种时候，该说些什么话才能恢复到原来的关系呢，很不巧我几乎没有这种经验完全不知道。<br>但是，我也还是有点悲伤。说不定，我和这家伙有些相似的部分，总有一天会笑着接受彼此也说不定，我有时会这么想。<br>但是，果然这种事是不可能的。<br>看谁的脸色，讨谁的欢心，保持联络，迎合话题，不得不做那么多才能维系的友情，那种东西根本就不是友情。如果那么繁琐的东西才能被称为青春的话，我根本就不需要。<br>靠这种无聊的交流而装作很快乐的行为根本就是自我满足。那根本就是欺骗。是应该唾弃的邪恶。</p></blockquote><h3 id="⑦-偶尔恋爱喜剧之神也会做些好事"><a href="#⑦-偶尔恋爱喜剧之神也会做些好事" class="headerlink" title="⑦ 偶尔恋爱喜剧之神也会做些好事"></a>⑦ 偶尔恋爱喜剧之神也会做些好事</h3><blockquote><p>由比滨也有在班级的立场。这家伙跟我不同有正常的人际关系。<br>而且还想和三浦保持良好关系的心情也是真的。<br>我确实是孤独，所以并不是嫉妒其他人们关系很好。这样的不幸也不是我所期待的…并不是说谎哦。是真的哦。<br>我们并不是一个好朋友圈子，也不是朋友，是因为某种原因而聚集起来的一帮人而已。换句话说就一个被聚集起来的集团而已。<br>我只是单单的想证明一件事而已。孤独的人并不是可怜的家伙，并不是因为孤独所以这家伙就是糟糕的家伙。<br>这些只是我一个人独断的想法这种事情我是知道的。还有，独来独往超好的。<br>但是，现在的我不会去否定过去的我，一个人过的时间是罪恶的，一个人待着是不好的。我绝对不会说。<br>所以，我为了证明自己的正义而战斗。</p></blockquote><h3 id="⑧-于是比企谷八幡在思考"><a href="#⑧-于是比企谷八幡在思考" class="headerlink" title="⑧ 于是比企谷八幡在思考"></a>⑧ 于是比企谷八幡在思考</h3><blockquote><p>青春。<br>写成汉字仅仅就2个字，这个词语却能深深打动人心。勾起已踏入社会的人们些许甘甜苦涩的乡愁，是年轻少女们永久的憧憬，并且是让我这样的人抱有强烈的嫉妒与深深的憎恶。<br>我的高中生活并没有像之前描述的那种充斥着美丽的幻想情节，而是泛着暗土色的，一片灰暗的世界。自从开学典礼遭遇车祸就开始混沌不堪。这之后也就是学校与自家之间的往返，休息日去图书馆，过着和现今的高中生格格不入的平淡生活。恋爱喜剧什么的完全没有任何交点。<br>但是，我却没有对此感到一丝遗憾，不如说这是我的骄傲。我很享受。<br>频繁前往图书馆让我能把大长篇的科幻小说读完，在夜里对偶尔从广播传来的主持人声音着迷，在由文本支配的庞大电子海中发现能温暖人心的文章，这一切都要归功于我每天如此渡过才能发现，才能相遇。<br>我为这一个个相遇发现而感谢感动得落泪，却绝对没有悲伤的眼泪。<br>我不会否认，如此渡过的这些时光才是该被称为高中一年级的青春年华。我非常坚信。并且这份信念从今往后也不会改变吧。<br>但是，这并不代表我就否认了其他的所有人，现在正讴歌着青春的人们的时光。<br>正处在青春正中央的他们，就连失败也能变成美好的回忆。争斗也好口角也好都是烦恼青春的一道滋味。<br>只要通过他们所拥有的青春过滤器，就连世界都能净化。<br>如果是这样，即使我这样的青春时代，也许就被染上了恋爱喜剧的色彩。或许并没有任何差错。<br>那么，我这里也将会在何时散发出光芒呢？就算有死鱼眼一样腐烂的眼神。仅仅怀抱着这样的期待就能感到心中有什么油然而生。<br>对，在侍奉部里渡过的日子里，我学到了一点。</p></blockquote><blockquote><p>通往特别楼的走廊上一个人都没有，只有运动社团的呼喊声回荡着。<br>今天雪之下也在活动室里看书吧。这样就不会受到任何人的影响认真写作文了。<br>反正那个社团是谁什么都不做的社团。<br>只是偶然得会有奇怪的人出现，那是真的非常罕见的。毕竟学生们的烦恼大多都会找身边的人商量，或者就这么自己忍耐着，一般都是这么解决的吧。<br>这应该是正确的做法，是大家都期望的做法。但是，偶尔也有无法这么做的人，比如我还有雪之下还有由比滨还有材木座。<br>友情啊爱情啊梦想啊之类的，对多数的人来说肯定是美好的事。扭扭捏捏地烦恼着的样子也彷佛在闪闪发光。<br>也就是说，他们就这么称之为青春。</p></blockquote><h2 id="第二卷"><a href="#第二卷" class="headerlink" title="第二卷"></a>第二卷</h2><h3 id="①-于是，由比滨结衣去学习了"><a href="#①-于是，由比滨结衣去学习了" class="headerlink" title="① 于是，由比滨结衣去学习了"></a>① 于是，由比滨结衣去学习了</h3><blockquote><p>哎呀，这是世之常情。有着决心去往同中学的家伙们不在的地方，拼命地学习。考上了县里有名的学校的人。抛开过去，打定主意不再碰见同年级学生的家伙。因为有这样的恶人，由比滨的担心不无道理。<br>同属一类人，长久地保持联络，才能够保持亲密。这样子根据实际情况最后才可以将关系维持下去。<br>所以切断这些的话，人无论何时都能变为独自一人。<br>就因为这样，只能靠着电话或邮件来维系，有时会不能继续维持下去。人们将这些称之为友情吧。一定是这么叫的。所以，大家把一切托付在手机上，将朋友的人数与电话簿上登记的数量等价换算，</p></blockquote><blockquote><p>我觉得手机这东西是一种能够加速人的孤独化的设备。即使有电话打来也能选择放置或者拒接，也可以不回邮件就这么无视了。能够选择性取舍人际关系，也能依照心情选择是否与人交流。</p></blockquote><h3 id="②-绝对，比企谷小町长大后会和哥哥结婚"><a href="#②-绝对，比企谷小町长大后会和哥哥结婚" class="headerlink" title="② 绝对，比企谷小町长大后会和哥哥结婚"></a>② 绝对，比企谷小町长大后会和哥哥结婚</h3><p>无</p><h3 id="③-任何时候叶山隼人都在控场"><a href="#③-任何时候叶山隼人都在控场" class="headerlink" title="③ 任何时候叶山隼人都在控场"></a>③ 任何时候叶山隼人都在控场</h3><blockquote><p>原本，通过语言进行的人际交流只有三成。剩下来的七成就要通过眼睛的活动和细微的动作来收集。眼睛像嘴一样能说话，这种说法就是根据这种无言的交流的重要性中得出的。就是说，反过来考虑，就算是不对话的孤独者也能做到七成的左右交流这么一回事。</p></blockquote><h3 id="④-经历过许多后川崎沙希很乖戾"><a href="#④-经历过许多后川崎沙希很乖戾" class="headerlink" title="④ 经历过许多后川崎沙希很乖戾"></a>④ 经历过许多后川崎沙希很乖戾</h3><blockquote><p>不过，这究竟是不是强大呢。我总觉得，这是对【谁都不理解我吧】这种呐喊的话语不被理解的悲叹和死心，并且抱有渴望被人理解的愿望。</p></blockquote><blockquote><p>比如说，雪之下雪乃。她并未被人理解也没有死心和悲叹。因为她确信即使如此还继续贯彻自我便是强大。</p></blockquote><h3 id="⑤-再次，比企谷八幡返回原本的道路"><a href="#⑤-再次，比企谷八幡返回原本的道路" class="headerlink" title="⑤ 再次，比企谷八幡返回原本的道路"></a>⑤ 再次，比企谷八幡返回原本的道路</h3><blockquote><p>如果说真实是残酷的，谎言绝对是温柔的吧。<br>所以，温柔是谎言。</p></blockquote><blockquote><p>我，讨厌人群。<br>还有，温柔的女孩子也讨厌。<br>犹如夜中当空之月，可望而不可即。<br>那份距离感无法把握。<br>打一句招呼便会在意，互发邮件便会心中小鹿乱撞。在打电话来的日子一看见来信履历表情会不由得舒缓下来。<br>但是，我知道。这叫做温柔。对我温柔的人也会对其他人温柔，这件事好像不知不觉淡忘了。<br>并不是迟钝。不如说是敏感。岂止如此甚至是过敏。所以产生了过敏反应。<br>那个模式已经体会过一次了。久经沙场的孤独者是不会第二次中招的。不管是输掉猜拳做为惩罚游戏的告白，还是由女生代笔却来自男人的伪造情书，我都免疫了。因为是百战磨练过的强者。有关于败北的事我是最强的<br>总是期待着，总是出差错，从何时开始就不再抱有希望。<br>所以，我永远，讨厌温柔的女孩子。</p></blockquote><h2 id="第三卷"><a href="#第三卷" class="headerlink" title="第三卷"></a>第三卷</h2><h3 id="①-于是，平塚静再次点燃战端的导火索"><a href="#①-于是，平塚静再次点燃战端的导火索" class="headerlink" title="① 于是，平塚静再次点燃战端的导火索"></a>① 于是，平塚静再次点燃战端的导火索</h3><blockquote><p>值得欣赏的不过是主人公是孤高的剑士这一点。<br>孤高所以至高。所谓真正的英雄就是一个人。<br>因为孤高所以强大。没有持有羁绊也就是说没有必须守护的东西。必须守护的东西换言之就是弱点。希腊的英雄阿基里斯、或者是最强的僧兵武藏坊牟庆，就是因为有弱点才会失败。肯定只要他们没有弱点，就会作为胜利者在历史上刻下自己的名字的。<br>因此没有弱点、没有必须守护的东西、和别人没有联系的人才是最强的。</p></blockquote><h3 id="②-我和户塚彩加的青春恋爱喜剧果然坑爹"><a href="#②-我和户塚彩加的青春恋爱喜剧果然坑爹" class="headerlink" title="② 我和户塚彩加的青春恋爱喜剧果然坑爹"></a>② 我和户塚彩加的青春恋爱喜剧果然坑爹</h3><p>无</p><h3 id="③-果然雪之下雪乃喜欢猫"><a href="#③-果然雪之下雪乃喜欢猫" class="headerlink" title="③ 果然雪之下雪乃喜欢猫"></a>③ 果然雪之下雪乃喜欢猫</h3><p>无</p><h3 id="④-见缝插针的，比企谷小町出谋划策"><a href="#④-见缝插针的，比企谷小町出谋划策" class="headerlink" title="④ 见缝插针的，比企谷小町出谋划策"></a>④ 见缝插针的，比企谷小町出谋划策</h3><blockquote><p>我既没有想要询问雪之下的事情，雪之下也没有什么想要告诉我的。大概，应该问的和应该说的事情都是有的吧。<br>只不过，互相之间不过与深入，采取一直以来我们之间的距离感，所以才会像电车之中坐在邻座的人一样度过无机质的时间。</p></blockquote><h3 id="⑤-即使如此材木座义辉也于荒野上，独自恸哭"><a href="#⑤-即使如此材木座义辉也于荒野上，独自恸哭" class="headerlink" title="⑤ 即使如此材木座义辉也于荒野上，独自恸哭"></a>⑤ 即使如此材木座义辉也于荒野上，独自恸哭</h3><blockquote><p>正确的做法就等于了不起，我认为那才是怠慢。<br>按照教科书完成既定的课程，达到计划的劳动定额…<br>这不只是效法至今的传统和正攻法而已吗。凭借着过去的财产，依靠着权威，这难道不只是在强化着目前还毫无作为的自己而已吗。<br>把自己的一切全部委身给自己的正确性，这种做法哪里算得上正确。</p></blockquote><blockquote><p>一边不断吸鼻子的啜泣着，肩膀一边哆哆嗦嗦的颤抖。材木座正恸哭着。<br>那副泣不成声，瞪着湿润的眼瞳的身姿不管怎么看都像个惨败者。<br>面对这副令人心痛样子的材木座，秦野和相模用满是厌恶的眼神注视着。不，也许不是材木座，他们是在那里看到了曾经令人痛心的自己也不一定。<br>——肯定，他们也是因为喜欢，才怀抱梦想的。<br>然而，一个人背负着梦想前行，这过于沉重了。<br>在一点点长大成人，逐渐看清现实的未来的过程中，会一点点变得无法一味追寻梦的物语。无论是收入最高二十万元也好，知名大学悲惨的就业率也好，每年的自杀人数也好，不断的增加的税收也好，就算交了也不知道能不能收回的养老金也好。<br>伴随着长大不断学会的全是这样的事情。对于一半已经是大人的高中生来说，这样的事情应该是能够理解的吧。<br>虽然大家都开玩笑地说着工作了就输了什么的，却是绝对不会搞错这种事的。<br>人们对于在这个世界上一味的追寻着梦的生活是多么痛苦多么懊悔，只是想一想就唉声叹气了。<br>只有喜欢是不行的。<br>所以他们补强着自己，不断储备知识。眺望着只是做着梦的人们，一边用自己的与众不同鼓励着自己，<br>——正是因为不想放弃，所以这种行为无论如何都无法否定。</p></blockquote><blockquote><p>将要成为游戏写手或是想要称为轻小说作家这种事情说出口后，普通人听后只会当作是毫无根据的妄想。就是这么荒唐无稽的梦想。<br>认真地想要应援的人和认真地想要阻止的人都不存在，就算是一脸认真地诉说着梦想也不会有人当真。<br>所以不知何时就放弃了，变成了会嘲笑做梦的自己以及做梦的其他人的人。一边嘲笑着，一边欺骗着自己。<br>即使如此，为什么这家伙会像这样，一边嚎啕大哭、涕泗横流着，一边声音颤抖的诉说着自己的梦想呢。<br>“我现在，明明白白的确信了。就算我成不了作家也好，当不了游戏写手也好，即使如此我也要继续写下去。并不是想当我才喜欢的！…是因为喜欢我才想当啊！”<br>实话说我很羡慕。<br>毫无怀疑的，不带任何悲观的，仅仅是靠着因为喜欢这一句话就决定了自己想要前进方向的愚直。<br>都到了愚蠢的程度的，令人炫目的过分的直率。<br>因为喜欢，这样直率的说出口由于过于带有力量而令人眩目。因为这种既不掺杂玩笑也没有丝毫逞强的从心底里涌出的纯洁和无垢我已经舍弃掉了。</p></blockquote><h3 id="⑥-总算他和她的开始结束了"><a href="#⑥-总算他和她的开始结束了" class="headerlink" title="⑥ 总算他和她的开始结束了"></a>⑥ 总算他和她的开始结束了</h3><p>无</p><h2 id="第四卷"><a href="#第四卷" class="headerlink" title="第四卷"></a>第四卷</h2><blockquote><p>夏目漱石的《心》绝对是孤独的小说。<br>这个作品的本质铁定不是三角关系的纠葛这种玩意。而是更切实的不相信他人的故事，描写个体与世界的隔绝的故事，在其间没有一丝救赎的真理的故事。<br>哪怕立了 flag 也不能达到 happy ending。得到了知音也不会成为亲友。爱与友情不会治愈孤独。<br>无所适从的孤独感。漱石将它写作“寂寞”，生于现代的我们已经熟悉了那份“寂寞”。将其作为极其当然的事物所接受。也许，将其称为个人的固有属性也行。<br>本来，人类就是寂寞地活着的生物，只能品尝着被寂寞所排斥，得不到任何人理解的滋味而苟且偷生，这就是漱石通篇展示的。<br>比如，“我”。比如“先生”，比如“K”，再比如“太太”。<br>所有人都是孤独的。立起 flag，赢得爱情，仍然不能治愈这渴望。<br>即使在同一场所，共有同一时间，也无法心灵相通。<br>明治以来百年有余。这故事经过了这么久的时间仍然经久不衰，想必缘于这人类的本质吧。<br>我想在最后以“先生”的这段话收尾。<br>世上没有像一个模子刻出来样的恶人哦。平时大家都是善人，至少大家都是普通人。但是，一到紧要关头，就会突然变成恶人，所以很可怕。因此不能大意。<br>人不可轻信。根据是夏目漱石。</p></blockquote><h3 id="①-如此这般的，比企谷八幡过着暑假"><a href="#①-如此这般的，比企谷八幡过着暑假" class="headerlink" title="① 如此这般的，比企谷八幡过着暑假"></a>① 如此这般的，比企谷八幡过着暑假</h3><p>无</p><h3 id="②-无论如何都无法从平塚静手中逃离"><a href="#②-无论如何都无法从平塚静手中逃离" class="headerlink" title="② 无论如何都无法从平塚静手中逃离"></a>② 无论如何都无法从平塚静手中逃离</h3><p>无</p><h3 id="③-叶山隼人并非对谁都如此"><a href="#③-叶山隼人并非对谁都如此" class="headerlink" title="③ 叶山隼人并非对谁都如此"></a>③ 叶山隼人并非对谁都如此</h3><blockquote><p>雪之下吐出小小的叹息声。<br>看来那家伙也注意到了这份异质感。<br>嘛，这又不是什么坏事。人生总是有一次两次要与孤独为伴的时候。不对，倒不如说必须这样才行。从始至终都和别人在一起，不论从何时直到永远身旁都有他人什么的才更加异常更加恶心不是吗？只有在孤独之中才能学到、才能感受到的东西是一定存在的。<br>既然存在拥有朋友才能学到的东西，没有朋友才能学到的东西肯定也是有的。这两方面应该是表里一体拥有同等价值的。</p></blockquote><h3 id="④-突然，海老名姬菜就开始了布教"><a href="#④-突然，海老名姬菜就开始了布教" class="headerlink" title="④ 突然，海老名姬菜就开始了布教"></a>④ 突然，海老名姬菜就开始了布教</h3><blockquote><p>“喜欢咖喱吗？”<br>叶山向留美搭话道。<br>看到此景，雪之下发出了小小的、几乎要听漏的小小的叹息声。<br>我也是同感。<br>这是一步恶手。<br>想要和孤零零的搭话，一定要在背地里，而且一定要秘密的进行。为了不暴露在人前，甚至需要有做最大限度考虑的必要性。</p></blockquote><blockquote><p>像特意做出来一样的恶人是不存在的。谁都是这么认为的，而其中也包括自己。没有人会怀疑自己不是善良的。<br>然而，当自己的利益受到侵犯的时候，人就会一下子露出尖牙。<br>当不应丑恶的自己沾染罪恶的时候，人们会寻求借口。而为了保持反转前后的自己的一致性，人就会使世界反转。</p></blockquote><h3 id="⑤-独自一人，雪之下雪乃仰望夜空"><a href="#⑤-独自一人，雪之下雪乃仰望夜空" class="headerlink" title="⑤ 独自一人，雪之下雪乃仰望夜空"></a>⑤ 独自一人，雪之下雪乃仰望夜空</h3><blockquote><p>无论是谁都被过去所囚困。无论怎样打算向前迈进，当不经意的抬头仰望时，昔日的所作所为都会像这星光一样倾泻下来。它们既无法抹消也无法一笑置之，只能永远地，在心的一角存留下去，然后在不经意的某个瞬间苏醒。</p></blockquote><h3 id="⑥-一不小心，比企谷八幡没带泳装"><a href="#⑥-一不小心，比企谷八幡没带泳装" class="headerlink" title="⑥ 一不小心，比企谷八幡没带泳装"></a>⑥ 一不小心，比企谷八幡没带泳装</h3><blockquote><p>所谓的“改变自己，世界就会随之改变”这种事，是不可能的。<br>不论是已经成型的对自己的评价，还是既存的人际关系，都不可能轻易地朝积极的方向变化。<br>人对人的评价既不是加分也不是减分。<br>只不过是固定观念和既存印象而已。<br>人看不到现实的本来面目。只能看到想看的、想拥有的现实。</p></blockquote><h3 id="⑦-最终，鹤见留美选择了自己的道路"><a href="#⑦-最终，鹤见留美选择了自己的道路" class="headerlink" title="⑦ 最终，鹤见留美选择了自己的道路"></a>⑦ 最终，鹤见留美选择了自己的道路</h3><blockquote><p>谁也没办法违背【气氛】，因此就算理解到了别人当下的痛苦也是无能为力的。<br>氛围和气氛是无法违抗的。人只能被迫采取违背本意的行动。因为【大家】都这么说，因为【大家】都这么做，不这么做的话，就无法融入【大家】之中。<br>不过，并不存在名叫什么【大家】的家伙。既没法与他说话也没法揍他一顿。他也不会生气，不会笑，不过是集团的魔力制造出的幻想而已，是在不经意之间诞生出的魔物，是为了隐藏个人小小的恶意所创造出的亡灵。是将不是同伴的人吞食殆尽，只有成为同伴才能摆脱诅咒的妖魔鬼怪。<br>曾几何时，他也好，她也好，都是这家伙的被害者。<br>所以我才憎恶着。<br>这个强求着所谓【大家】的世界。<br>必须建立在牺牲某人之上才能成立的低劣的和平。<br>以温柔和正义粉饰，明明是恶毒之物却登大雅之堂，随着时间的流逝越发凶恶，除欺瞒外别无其二的空虚的概念。<br>过去和世界都是无法改变的。发生过的事情和所谓的【大家】都是无法改变的。但是，并不是说自己只能隶属于他们。<br>将过去舍弃，将世界摧毁葬送是可以做到的。</p></blockquote><h3 id="⑧-于是，载着雪之下雪乃的车子开走了"><a href="#⑧-于是，载着雪之下雪乃的车子开走了" class="headerlink" title="⑧ 于是，载着雪之下雪乃的车子开走了"></a>⑧ 于是，载着雪之下雪乃的车子开走了</h3><p>无</p><h2 id="第五卷"><a href="#第五卷" class="headerlink" title="第五卷"></a>第五卷</h2><h3 id="①-突然，比企谷家的平稳分崩离析"><a href="#①-突然，比企谷家的平稳分崩离析" class="headerlink" title="① 突然，比企谷家的平稳分崩离析"></a>① 突然，比企谷家的平稳分崩离析</h3><blockquote><p>不过，我是真的不懂。<br>雪之下的事情。我不懂。<br>当然表层的情况还是知道的。名字呀长相呀成绩好呀不让人接近啦喜欢猫和潘先生啦毒舌且缺心眼啦。<br>但，就这样了。<br>不能仅靠这点程度就自诩了解他人。和周围的人不理解我相同，我也并不理解周围。这点必须铭记。<br>归根结底根据什么才应当称为【了解】呢——</p></blockquote><h3 id="②-不出所料，川崎沙希被遗忘了"><a href="#②-不出所料，川崎沙希被遗忘了" class="headerlink" title="② 不出所料，川崎沙希被遗忘了"></a>② 不出所料，川崎沙希被遗忘了</h3><blockquote><p>有随便选好的家伙。也有定好目标的家伙。<br>不光只有积极向前干脆给出答案。我想即使消极卑屈的消去法的结果，只要是那家伙决定的事就无伤大雅。</p></blockquote><h3 id="③-没想到户塚彩加的选择很质朴"><a href="#③-没想到户塚彩加的选择很质朴" class="headerlink" title="③ 没想到户塚彩加的选择很质朴"></a>③ 没想到户塚彩加的选择很质朴</h3><blockquote><p>嘛，不论是电影还是其他，即使观察的是同一事物也不会抱持同样的感想。<br>最多也就拥有相似的感想。<br>但是，相似就证明了确实有某些偏差。<br>我们总是只看见自己想看的。<br>一万个人眼中就有一万个哈姆雷特。无论是电影的感想，还是对人的印象。<br>所以，自称理解了能教他人什么的都太狂妄了。自以为理解了是罪与恶。<br>虽然如此，我们不得不自欺欺人地活下去。<br>理解了，和被理解了，只得凭借云里雾里的相互认识随时重新定义我们的存在，活着对方的存在，一边鼓噪一边继续生活。<br>万一不这样做自己这一存在就会烟消云散。</p></blockquote><blockquote><p>离我玩迷你四驱车的时候已经过了许多年，但那个年代的激情依旧。即使是现在也会雨后挥舞雨伞剑，在虚构的世界中无数次拯救世界。<br>大概，就算长大成人也会回想起来。<br>即使世代变迁，根子终究不会变。<br>所以，男孩子的时间永不止歇。</p></blockquote><h3 id="④-很遗憾，平塚静的红线的行踪无人知晓"><a href="#④-很遗憾，平塚静的红线的行踪无人知晓" class="headerlink" title="④ 很遗憾，平塚静的红线的行踪无人知晓"></a>④ 很遗憾，平塚静的红线的行踪无人知晓</h3><blockquote><p>快乐，我们在这个瞬间闪耀最辉煌的光芒，他们到底在向谁这么宣告呢。<br>对于一个人安安静静读书，在家玩游戏，懂得安静之乐的人来说，他们的快乐宣言总感觉很空洞。<br>没有根据声音的大小或聚集的人数来测定快乐的尺度吧，我很讨厌混淆了这事的家伙们。由于人群或事件这些对他们来说绝好的宣言时间，他们的活动会热火朝天。我无法忍受看见这种欺瞒，拟态。<br>为什么自己感受到的快乐，自己的正义，不能靠自己证明呢。<br>自己一个人不能挺起胸膛，是没有确信的缘故。在内心某处会有冷静的自己提出质疑【真的快乐吗？】吧。为了完全消除这个疑问他们说高兴，气氛热烈，现在最棒了，超愉快哟。脱口而出。扯开嗓子喊。<br>我不想与这样的家伙为伍。不愿成为道貌岸然的伪善者。</p></blockquote><blockquote><p>“长处…”<br>“之前有说过吧，温柔正确之处啊”<br>确实，平塚先生曾经这样评价雪之下雪乃。因此，应该也说她难以生存。因为世界既不温柔，也不正确。</p></blockquote><h3 id="⑤-忽然比企谷小町开始考虑与哥哥分离之日"><a href="#⑤-忽然比企谷小町开始考虑与哥哥分离之日" class="headerlink" title="⑤ 忽然比企谷小町开始考虑与哥哥分离之日"></a>⑤ 忽然比企谷小町开始考虑与哥哥分离之日</h3><blockquote><p>为何人会陷入怀旧之情中呢。【过去真好】什么的【古老优秀的世代】之类的【昭和气息】等等，总是去肯定已经失去的岁月。<br>眷恋感念过去，往昔。或是叹惋懊悔已改变，被改变的事物。<br>那么，归根结底所谓变化，是应该悲伤的事情吗。<br>成长与进化还有变迁，真是可喜正确而又极美好的东西吗。<br>即使自己不改变，世界，周围还是在不断变化。因为不想被抛弃只得拼命紧随其后不是吗。<br>假使不改变悲伤就不会产生，哪怕什么都不产生，负面要素不会出现就算是一大好处。要是对照收支表没有赤字就说明经营方针绝对没有错误。<br>所以我不否定一成不变。毫无否定过去的我，和现在的我的打算。<br>改变什么的，结果只是为了逃避现状。要是不选择逃避就该不变地在那坚持到底。</p></blockquote><blockquote><p>“不仅是哥哥啊。比方说雪乃桑就是一个人生活吧？雪乃桑怎么样呢…她不要紧吗”<br>这句的言外之意，好像在说甚至雪之下雪乃，也是怀抱一抹寂寞地生活吧。举止完美的她偶尔会展现出脆弱。雪之下的确让人感受了或许该称之为虚幻的事物。但我还不明白其中的意义。<br>还有啊，小町继续说道。<br>“——即使是被留下的一方，也会感到寂寞吧”<br>…。啊啊，没错。<br>为什么会认为只有离开的那一方才孤独呢。明明被留下的人也一定是相同的呢。</p></blockquote><h3 id="⑥-最后由比滨结衣消失在人山人海之中"><a href="#⑥-最后由比滨结衣消失在人山人海之中" class="headerlink" title="⑥ 最后由比滨结衣消失在人山人海之中"></a>⑥ 最后由比滨结衣消失在人山人海之中</h3><blockquote><p>见得太多了。不仅是雪之下，在集团中，杰出的存在被排除在外。不是枪打出头鸟。而是被清楚抛弃。被弃置不顾饱经风霜迟早会腐朽。</p></blockquote><blockquote><p>没有开放的事情。对雪之下来说不想触及的事情就不该去触及。<br>无法做到互相理解，被人不懂装懂就会生气。漠不过问才值得庆幸的场合数不胜数。<br>雨天抱着大包摔一跤的时候，在全班同学面前被老师训斥的时候，会期望道“拜托了别跟我说话”吧。<br>大家也差不多该注意到，温柔亲切地搭话不仅不能拯救，更可能给与伤害。<br>同情心或慈悲化为致命一击，也是有的。<br>“一直不知道，就好吗…”<br>由比滨没有释怀地，垂下头看着双脚。<br>为了配合驻足不前的由比滨，我也停下脚步。<br>“我不认为不知情就不好呐。知道得多了麻烦也会一口气增多”<br>知道就是背负风险的行为。不知道才好的事有许许多多。人真正的心意之类就是最典型吧。<br>不论谁都或多或少自欺欺人地生存着。<br>所以事实会经常伤人。仅仅是破坏某人的平稳的存在。</p></blockquote><h3 id="⑦-那么，比企谷八幡呢"><a href="#⑦-那么，比企谷八幡呢" class="headerlink" title="⑦ 那么，比企谷八幡呢"></a>⑦ 那么，比企谷八幡呢</h3><blockquote><p>人与人一旦关联，便会产生某些反应。<br>反应色有多种多样。即使是一个人的人品，那反应也会随着接触的人的改变而改变。好像五彩斑斓的烟火一般，导出迥然不同的颜色。<br>比如，川崎沙希说——跟她难以接近。<br>由于不让周围人靠近，即使同种类的人也无法要好相处，不干涉对于她们来说就是最好的交流也未可知。<br>或者，川崎大志看见她，评价道——美丽，而且可怕。<br>只论表面的话没有比这更贴切的表达了。在远处旁观到的她正如冰海绝壁一般君临着。<br>还有，材木座义辉与她相对，断定她——因为太过正直而不惜受伤。<br>这话如果只把一部分分割出来可谓正中靶心。然而，我认为，这并非惜与不惜这种意志上的问题，恐怕是不知道其他的方法吧。<br>接着，户塚彩加接近她，称她是——认真正派的人。<br>确实她是这样的人。有时会过度地，忠实于原理原则。最为遵循她心中的正义。<br>其他方面，比企谷小町与她接触，总感觉她很寂寞。<br>独自生活下去的一方，和留下来的另一方都怀有一抹寂寞地生活着。当然，这只是旁观者的感伤，她的本心谁都不懂，恐怕也包括她自己。<br>换个角度，平塚静一直在关注着她，相信她温柔而且往往是正确的。<br>因为世界不温柔也不正确，想必生活得很艰难吧——还这么说过，诚然所有将她包围的环境对她而言都可能化为累赘。能称为唯一的救赎的不就是【朋友】这个存在吗。尽管这样，她却数十倍，错，是数百倍地为【朋友】这一存在所折磨吧。<br>然而，雪之下阳乃与她一起生活，嘲笑她微不足道。<br>不断追赶自己，因此不断败北。没有被选择，可怜又可爱的妹妹，她带着残酷的笑容这么说道。我不知道是被什么选择。朋友吗，家庭吗，亲人吗，或者是命运吗。不论哪一方面，对她抱有可怜这种感情的就只有作为强者的雪之下阳乃吧。我从来没有这么想过。<br>但是，由比滨结衣与她相伴至今，高喊道喜欢她。<br>没有半句修饰，虽然是稚拙而愚直的恸哭，但除此之外我不知道哪里还有这么美丽的表白，然而，连由比滨都感觉到她心中的隔阂。但即使这样，她仍然祈愿道想要更加接近，并且就算借我这种人之手，依然强烈地希望成为其助力。<br>那么，比企谷八幡呢。<br>我并不是一无所见吧。<br>她的行动与她那样做的心理，我有时多多少少能理解。但是，这不能和理解她的感情画上等号。<br>只是因为环境与立场类似，不过是可以由此类推，偶尔取得近似值罢了。<br>人总是只看自己想看的。<br>我觉得自己在她身上找出了某些相似之处。<br>贯彻孤高，贯彻自己的正义，绝不哀叹不为人理解，也放弃了去理解。那种完美的超人性是我没有掌握，而她确实拥有的东西。<br>我…不想了解更多。<br>我见到的雪之下雪乃。<br>总是美丽，诚实，不说谎，动辄直言不讳。无所依靠却依然屹立不倒。<br>那身姿。如同幽冷的青蓝色火焰一样美丽，虚幻到令人悲伤的身姿。<br>对这样的雪之下雪乃，<br>我一定，是憧憬的。</p></blockquote><h3 id="⑧-仅仅一会儿，雪之下雪乃停下脚步"><a href="#⑧-仅仅一会儿，雪之下雪乃停下脚步" class="headerlink" title="⑧ 仅仅一会儿，雪之下雪乃停下脚步"></a>⑧ 仅仅一会儿，雪之下雪乃停下脚步</h3><blockquote><p>然而，我似乎初次讨厌自己了。<br>擅自期待擅自强加理想又擅自以为理解了，然后擅自失望。明明无数次地自戒，终究没有改正。<br>——连雪之下雪乃都会说谎。<br>这分明再正常不过，对于无法容许这事的自己，我很讨厌。</p></blockquote><h2 id="第六卷"><a href="#第六卷" class="headerlink" title="第六卷"></a>第六卷</h2><h3 id="①-暴风雨之中，比企谷八幡不停挣扎"><a href="#①-暴风雨之中，比企谷八幡不停挣扎" class="headerlink" title="① 暴风雨之中，比企谷八幡不停挣扎"></a>① 暴风雨之中，比企谷八幡不停挣扎</h3><blockquote><p>“…没错呢。”<br>她的赞同大概也不是在寻求回应吧。无论事声音还是视线，都没有朝向任何人。<br>决不能强加印象。<br>要追求完美，只可以对神而已。<br>绝对不能向别人追求理想。<br>那是软弱。是理应憎恶的恶。是理应责罚的怠惰。是对自己、对周围的放纵。<br>失望也没关系的只可以对自己而已。受伤也没关系的只有自己而已。能够讨厌的只有无法追逐理想的自己就够了。<br>不能原谅的应该是自己才对。</p></blockquote><h3 id="②-相模南强烈地表现着"><a href="#②-相模南强烈地表现着" class="headerlink" title="② 相模南强烈地表现着"></a>② 相模南强烈地表现着</h3><p>无</p><h3 id="③-海老名姬菜的音乐剧果然腐烂了"><a href="#③-海老名姬菜的音乐剧果然腐烂了" class="headerlink" title="③ 海老名姬菜的音乐剧果然腐烂了"></a>③ 海老名姬菜的音乐剧果然腐烂了</h3><p>无</p><h3 id="④-突然，雪之下雪乃强袭而至"><a href="#④-突然，雪之下雪乃强袭而至" class="headerlink" title="④ 突然，雪之下雪乃强袭而至"></a>④ 突然，雪之下雪乃强袭而至</h3><p>无</p><h3 id="⑤-温温和和的诚廻巡就被愚弄了"><a href="#⑤-温温和和的诚廻巡就被愚弄了" class="headerlink" title="⑤ 温温和和的诚廻巡就被愚弄了"></a>⑤ 温温和和的诚廻巡就被愚弄了</h3><blockquote><p>对我们，至少对我，相信并交付于他人是做不到的。<br>这样的话，如果不顺利只要责备自己就行了，完全不会去责备他人。<br>一怨恨起他人来就会怨恨得没完没了得。<br>这并不是善良也不是责任感，自己做的事就可以死了心，别人做的就怎么也死不了心。<br>那个时候如果那个家伙那么做的话，那个时候如果那个家伙认真干的话——总是想着这些而活是十分愁闷、辛苦，并且苦闷是无法消解的。<br>既然如此，一个人做更好。<br>自己一人后悔的话，只要叹气就够了。</p></blockquote><h3 id="⑥-一反常态的，由比滨结衣愤怒了"><a href="#⑥-一反常态的，由比滨结衣愤怒了" class="headerlink" title="⑥ 一反常态的，由比滨结衣愤怒了"></a>⑥ 一反常态的，由比滨结衣愤怒了</h3><blockquote><p>说时间可以解决一切那不过是骗人的。那不过是被逼到只能将一切都忘却都断送，将问题本身放置直至风化而已。所谓改变自己世界就会改变是谎言，是欺瞒。世界无论何时都只会侵蚀自身，套上枷锁将突出的部分磨碎磨平。这种时候能够想到的只能是放弃而已。</p></blockquote><blockquote><p>正要走出会议室的时候，门前站着雪之下。<br>“这样好吗？”<br>“什么。”<br>我这么反问雪之下也没法回答。<br>“我觉得误解还是解释一下比较好。”<br>“误解是解不开的吧。既然【解】已经得出了那么问题就到此为止了。再解下去也解不了了。”<br>正解也好误解也好，都是最终答案。<br>失败无法重新来过，打上的烙印也无法消除。<br>雪之下眯起了眼睛轻微地怒瞪着我。<br>“…在无所谓得事情上全是借口，重要的事情却丝毫不找理由呢。我觉得这有点卑鄙呢。你这样对方不是也不能找借口了吗。”<br>“借口什么的完全没意义。人对于重要的事情只会擅自自我判断的。”<br>“…也对呢。可能确实如此。借口，是毫无意义的。”<br>好像在咀嚼着话语一样雪之下说道。<br>得出的答案无法收回。覆水难收，破卵难完。君主大人的所有马匹和兵士也没法再回来。<br>不论用怎么样的言辞，恶劣的印象都无法拭去。</p></blockquote><blockquote><p>我有办法再重新问过一次吗？<br>人生永远不能重新来过。<br>错误的答案一定还是错的。<br>为了弥补，惟有导出新的答案。<br>所以，要再问一次。<br>为了得知正确的答案。</p></blockquote><h3 id="⑦-方今总武高校恰在festival的最高潮"><a href="#⑦-方今总武高校恰在festival的最高潮" class="headerlink" title="⑦ 方今总武高校恰在festival的最高潮"></a>⑦ 方今总武高校恰在festival的最高潮</h3><p>无</p><h3 id="⑧-雪之下雪乃注视的人就在前方"><a href="#⑧-雪之下雪乃注视的人就在前方" class="headerlink" title="⑧ 雪之下雪乃注视的人就在前方"></a>⑧ 雪之下雪乃注视的人就在前方</h3><p>无</p><h3 id="⑨-于是，各自的舞台拉开大幕"><a href="#⑨-于是，各自的舞台拉开大幕" class="headerlink" title="⑨ 于是，各自的舞台拉开大幕"></a>⑨ 于是，各自的舞台拉开大幕</h3><p>无</p><h3 id="⑩-终于，他和她都找到了正确的答案"><a href="#⑩-终于，他和她都找到了正确的答案" class="headerlink" title="⑩ 终于，他和她都找到了正确的答案"></a>⑩ 终于，他和她都找到了正确的答案</h3><blockquote><p>双脚自然的，朝向着了安静的方向。<br>走在没有任何人的特别楼的走廊之中，感受到了空气的寒冷。开始进入深秋了呢。<br>通过这条走廊，每天前往部室也已经有了半年。<br>到达了侍奉部的活动室，手扶上门。突然想起自己并没有钥匙。因为平时总会有比我还要早来的人在，所以从来没有在意过钥匙的事情。但是，并没有任何今天她也在的保证。<br>虽然想到直接放弃回去好了，手却无法从门上放开。<br>而且，感觉门格外的轻。<br>索性打开了门。<br>是没有任何特别的，极为普通的教室。<br>然而，会让人感觉如此的异质，是因为独自一人的少女身处此处的缘故吧。<br>在斜阳之中，钢笔安静的疾走着。<br>即便世界终结之后，她也一定会像这个样子的身在此处——让人产生这种错觉一般的，这份光景描绘出如此一幅画面。<br>看到这一幕，我的身体和精神都停止了。<br>——不小心就看呆了。</p></blockquote><blockquote><p>恐怕我和雪之下都只是为了寻找安静的地方才来到这里的，本来活动范围就说不上宽阔，栖息范围还重合才会发生这样的事情。本来，虽然我们住在相邻的街道也基本没有遇到过，只是因为在学校所以才会碰面而已。<br>就算同样都是独自一人，我和雪之下也可以说是完全不同的类型。<br>——没错。<br>——我和她一点也不像。<br>——大概正因如此，像这样交换着话语总是令人如此的新鲜和愉快。<br>——感觉身体内依然燃烧着祭典的余温。重新问过后，新导出的答案会得到更好的结论吧。</p></blockquote><h2 id="第七卷"><a href="#第七卷" class="headerlink" title="第七卷"></a>第七卷</h2><h3 id="①-即便如此比企谷八幡的学校生活也在平稳度过"><a href="#①-即便如此比企谷八幡的学校生活也在平稳度过" class="headerlink" title="① 即便如此比企谷八幡的学校生活也在平稳度过"></a>① 即便如此比企谷八幡的学校生活也在平稳度过</h3><p>无</p><h3 id="②-他们为何前来侍奉部，无人得知"><a href="#②-他们为何前来侍奉部，无人得知" class="headerlink" title="② 他们为何前来侍奉部，无人得知"></a>② 他们为何前来侍奉部，无人得知</h3><p>无</p><h3 id="③-无论如何户部翔都很轻薄"><a href="#③-无论如何户部翔都很轻薄" class="headerlink" title="③ 无论如何户部翔都很轻薄"></a>③ 无论如何户部翔都很轻薄</h3><p>无</p><h3 id="④-追根究底，海老名姬菜腐烂了吗"><a href="#④-追根究底，海老名姬菜腐烂了吗" class="headerlink" title="④ 追根究底，海老名姬菜腐烂了吗"></a>④ 追根究底，海老名姬菜腐烂了吗</h3><blockquote><p>大家好好相处。<br>虽然这是我最讨厌的话语，不过对于希望如此的人来说确是理所当然的。</p></blockquote><h3 id="⑤-如您所见，由比滨结衣正在努力"><a href="#⑤-如您所见，由比滨结衣正在努力" class="headerlink" title="⑤ 如您所见，由比滨结衣正在努力"></a>⑤ 如您所见，由比滨结衣正在努力</h3><blockquote><p>毕竟人不可能天真到靠着这样的事情就能重获新生。就算去印度旅行或是攀登富士山也不会重获新生。假使真的焕然一新，没有到目前为止的积累也是做不到的。就算抱持着改变的想法，无法对周围的评价以及过去的失败进行修正的话也是不可能改变的。<br>人即历史。是从积存的时间中生出的经验造就了人。若是重获新生，必须将那份历史全部焚烧殆尽，全部消灭殆尽才行。然而，这样的事情实际上是不可能的，因此，不能期求什么重获新生，唯有承受着自身内心的愧疚与心中所怀抱的罪恶活下去一途。<br>将人生重新来过是办不到的。</p></blockquote><h3 id="⑥-安静无声，雪之下雪乃行走在夜晚的街道"><a href="#⑥-安静无声，雪之下雪乃行走在夜晚的街道" class="headerlink" title="⑥ 安静无声，雪之下雪乃行走在夜晚的街道"></a>⑥ 安静无声，雪之下雪乃行走在夜晚的街道</h3><p>无</p><h3 id="⑦-出乎意料地，三浦优美子都看在眼里"><a href="#⑦-出乎意料地，三浦优美子都看在眼里" class="headerlink" title="⑦ 出乎意料地，三浦优美子都看在眼里"></a>⑦ 出乎意料地，三浦优美子都看在眼里</h3><p>无</p><h3 id="⑧-即便如此，叶山隼人也无法做出选择"><a href="#⑧-即便如此，叶山隼人也无法做出选择" class="headerlink" title="⑧ 即便如此，叶山隼人也无法做出选择"></a>⑧ 即便如此，叶山隼人也无法做出选择</h3><p>无</p><h3 id="⑨-他和她的告白没能传达给任何人"><a href="#⑨-他和她的告白没能传达给任何人" class="headerlink" title="⑨ 他和她的告白没能传达给任何人"></a>⑨ 他和她的告白没能传达给任何人</h3><p>无</p><h2 id="第八卷"><a href="#第八卷" class="headerlink" title="第八卷"></a>第八卷</h2><h3 id="①-毫无疑问，比企谷小町的逆鳞位于此处"><a href="#①-毫无疑问，比企谷小町的逆鳞位于此处" class="headerlink" title="① 毫无疑问，比企谷小町的逆鳞位于此处"></a>① 毫无疑问，比企谷小町的逆鳞位于此处</h3><blockquote><p>为明知道不得不失去的事物延长生命能有什么意义？<br>总有一天会失去一切。这是真理。<br>然而，即便如此。<br>正因为将不得不失去才彰显美丽的事物也是存在的。<br>正因为总有一天会终结，才存在着意义。停滞也好闭塞也好，就算是安息也好，绝对不是可以视而不见的，心甘接受的事物。<br>对一定会失去，必须要有所意识。<br>朝着终有一天失去了的事物不时默默回首，像对待宝物一样缅怀和爱怜，彷佛静静地举杯独酌般的幸福，一定是存在的。</p></blockquote><blockquote><p>秋意深，四下之人正何为？<br>这是名句。<br>会在意起四下之人正在做些什么，是这个季节特有伤怀和寂寥，或者说是从一抹寂寞之中所产生的事物也不一定。<br>因为寂寞所以想要注意到谁的存在。为了掩盖自己的寂寞，介意起他人的存在。<br>反过来讲，这也许表现了希望自己的存在被他人在意的愿望。<br>他人是映照自己的明镜。归根到底，他人不过是通过名为自己的滤镜所看到的虚像而已，因此存在的只有自己这个存在本身。<br>到头来，人考虑的只有自己。<br>询问四下之人在做些什么的行为，不外乎是将他人与自身进行比较验证，以此思考自己的存在的行为而已。<br>利用他人为自己立证，这种行为缺乏诚实。这种追求的方式是错误的。<br>因此，只有孤独才是正义，孤高才是正解。</p></blockquote><h3 id="②-莫名地，一色彩羽散发着危险的香气"><a href="#②-莫名地，一色彩羽散发着危险的香气" class="headerlink" title="② 莫名地，一色彩羽散发着危险的香气"></a>② 莫名地，一色彩羽散发着危险的香气</h3><p>无</p><h3 id="③-雪之下阳乃深不见底"><a href="#③-雪之下阳乃深不见底" class="headerlink" title="③ 雪之下阳乃深不见底"></a>③ 雪之下阳乃深不见底</h3><p>无</p><h3 id="④-静静地，雪之下雪乃下定决心"><a href="#④-静静地，雪之下雪乃下定决心" class="headerlink" title="④ 静静地，雪之下雪乃下定决心"></a>④ 静静地，雪之下雪乃下定决心</h3><p>无</p><h3 id="⑤-直到最后，叶山隼人也无法理解"><a href="#⑤-直到最后，叶山隼人也无法理解" class="headerlink" title="⑤ 直到最后，叶山隼人也无法理解"></a>⑤ 直到最后，叶山隼人也无法理解</h3><blockquote><p>果然这家伙不明白。<br>这就彷佛在说，一直以来伸出的援手，全部都是处于利己性质的计算才做出的行为一样。<br>假若，就算比企谷八幡真是如此。<br>我也决不允许将其他人也说成这样。<br>我也好，她也好，都不是怀着这种仿造品一样的心情，走到今天这一步的。<br>“才不是”<br>连瞪都难得瞪了。<br>我并不是在追求这种半吊子的温柔和同情。样板似的哭个痛快的青春剧什么的真是肤浅恶心地令人作呕。<br>在这种青春剧中，无论何时都存在着失败者，这点是无可回避的。因此，也存在着我身为胜利者的可能性。那时眼前的叶山也是有着成为失败者的可能的。<br>就是这样的零和游戏。在谁拥有着美好回忆的同时，也会有着吞下败果的家伙。不过如此而已。就算讴歌着青春，因为一个错误就会被强行翻盘。<br>既然如此，你们就别给我只是因为一时的快感，就用高高在上的视线给人贴上标签。</p></blockquote><blockquote><p>才不会让人说成是自我牺牲。<br>才不会让人用尽为数不多的手牌，极尽效率化，追求最善之策的人说成是牺牲。这是胜于一切的屈辱。是对拼命活着的人的冒渎。<br>谁会为了你们这些傻逼牺牲啊。<br>就算没有形体，就算无法发作声音，就算不能变为语言。<br>我是有着确实的信念的。<br>恐怕，那是曾经和某人唯一共有的。<br>在现在已经失去了的信念。</p></blockquote><h3 id="⑥-于是，由比滨结衣宣言道"><a href="#⑥-于是，由比滨结衣宣言道" class="headerlink" title="⑥ 于是，由比滨结衣宣言道"></a>⑥ 于是，由比滨结衣宣言道</h3><blockquote><p>只是。<br>只是，即便如此。<br>将事情都推到别人身上，这太过痛苦。<br>想要守护最最重要的事物，却因此而将其放手。看着这样的她们的身姿，是件非常痛苦的事。<br>如果不牺牲什么青春剧就无法成立，我明明知道这些。<br>因为自己并不是牺牲，所以怜悯和同情都是没有必要的，我明明很了不起地宣称着这样的话。<br>这是多么的矛盾啊。</p></blockquote><h3 id="⑦-毫无疑问，比企谷小町的温柔位于此处"><a href="#⑦-毫无疑问，比企谷小町的温柔位于此处" class="headerlink" title="⑦ 毫无疑问，比企谷小町的温柔位于此处"></a>⑦ 毫无疑问，比企谷小町的温柔位于此处</h3><blockquote><p>发生的种种摆在眼前，我第一次有所自觉。<br>只是不想她受到伤害。<br>这份感情大概与怜悯和同情不同吧。<br>所以，将她的行为称为牺牲，我绝对不会这么做，也不会让人这么做。</p></blockquote><h3 id="⑧-一鼓作气，比企谷八幡诉说着"><a href="#⑧-一鼓作气，比企谷八幡诉说着" class="headerlink" title="⑧ 一鼓作气，比企谷八幡诉说着"></a>⑧ 一鼓作气，比企谷八幡诉说着</h3><blockquote><p>雪之下那时的话语至今没有消散。<br>为人所理解，这一幻想是多么地让人心旷神怡。是一旦沉浸其中就难以自拔的泥沼。索性完全委身其中一定会十分轻松吧，又会是多么的舒适啊。<br>彼此理解——这份错觉是无情的欺骗。<br>当从这份幻觉中醒来之时，真不知会有多么的失望。<br>细小的违和感和疑念，化为棘刺，化为芥蒂，总有一天会将一切都摧毁掉。<br>我应该察觉到的。<br>我想要的，并不是相互勾结。<br>我想要的一定是真正的某物。除此之外都不需要。<br>什么都不说也能够传达，什么都不做也能够理解，无论发生什么都不会毁坏。<br>那种与现实相去甚远的，愚蠢而又美丽的幻想。<br>那种真正的某物，我和她都在追求着。</p></blockquote><h3 id="⑨-房间之中，红茶的香气已不复存在"><a href="#⑨-房间之中，红茶的香气已不复存在" class="headerlink" title="⑨ 房间之中，红茶的香气已不复存在"></a>⑨ 房间之中，红茶的香气已不复存在</h3><p>无</p><h2 id="第九卷"><a href="#第九卷" class="headerlink" title="第九卷"></a>第九卷</h2><h3 id="①-再一次，一色彩羽叩响了那门扉"><a href="#①-再一次，一色彩羽叩响了那门扉" class="headerlink" title="① 再一次，一色彩羽叩响了那门扉"></a>① 再一次，一色彩羽叩响了那门扉</h3><blockquote><p>比企谷八幡的幸福、比企谷八幡的愿望、比企谷八幡的欲求。<br>我从未深刻思考过这些东西。<br>所以，我的幸福究竟是什么？我想要的究竟是什么东西？这些我也都不曾知晓。</p></blockquote><blockquote><p>已经失去的东西要怎么才能粉饰？<br>叶山他们一定会教给我该如何做，我总有种这样的感觉。</p></blockquote><blockquote><p>或许，我的视线之所以会朝向叶山他们，是因为意识到他们之间的人际关系也存在着虚饰和欺瞒，不由得把这一情况和现在得的自己重叠在了一起吧。</p></blockquote><blockquote><p>我也是一样，并不想去部室。<br>但即便如此还毫不缺席的每天过去，我是不是有点嗜虐啊。想来我们三个人，都不是很想去那里吧。<br>又或者，我们几个只是为了保全，为了维持，就像生物想要留下自己的种子，就像自己想要保全住自己一样，只是基于使命感、义务感才会去那里的么》<br>为了不逃开而继续的日常。<br>为了凭吊逝者而继续的日常。<br>为了不让那些已经失去的东西成为自己的借口。为了不承认自己已经屈服于这无理的现实。所以才会比一往更加努力，比以往更加装出一副毫无变化的样子吧。<br>但这毫无疑问只是欺瞒。<br>然而，做出这种选择的也正是我自己。<br>已经无法重来一次了。时间就是如此的不可逆，无法挽回的东西更是常常存在。不停的叹息毫无疑问只是对过去自己的一种背叛。<br>会感到后悔，正说明了那是如此重要的一件事。所以，我不会悲叹。我已经得到过本来所没有的东西了。这就应该足够让我满足了。<br>幸运、幸福是什么的，如果习惯了也只是会变成普通的日常而已。但一旦突然失去了这些东西，却又会感到不幸。<br>所以即便之后再也没法得到什么东西，我也觉得这是理所当然的，人生经验也是这样逐渐变得丰富。<br>至少不要去否定过去的自己。<br>以后的日子，我也仍会这么度过吧。</p></blockquote><h3 id="②-顺利地，会议进行着，却毫无进展"><a href="#②-顺利地，会议进行着，却毫无进展" class="headerlink" title="② 顺利地，会议进行着，却毫无进展"></a>② 顺利地，会议进行着，却毫无进展</h3><p>无</p><h3 id="③-反复地，比企谷八幡自问"><a href="#③-反复地，比企谷八幡自问" class="headerlink" title="③ 反复地，比企谷八幡自问"></a>③ 反复地，比企谷八幡自问</h3><blockquote><p>失去之物无法失而复得。<br>若是想要抵偿，就唯有获得更好的事物。失去之物本身与由于失去产生的损害，两者都必须得到抵偿才行。赎罪就是这样的东西。</p></blockquote><h3 id="④-因此，户塚彩加怀抱憧憬"><a href="#④-因此，户塚彩加怀抱憧憬" class="headerlink" title="④ 因此，户塚彩加怀抱憧憬"></a>④ 因此，户塚彩加怀抱憧憬</h3><p>无</p><h3 id="⑤-平塚静祈愿着将来。"><a href="#⑤-平塚静祈愿着将来。" class="headerlink" title="⑤ 平塚静祈愿着将来。"></a>⑤ 平塚静祈愿着将来。</h3><blockquote><p>“你的话，一个人应该也能解决吧。一直以来也都是那样。”<br>我觉得其实并非如此。一直以来我所做的事情都不是解决。一色也好，留美也好，都是留下了半吊子的邋遢结果而已。如果要问她们是否已经被拯救了？绝非如此。<br>“我可没解决什么…只是，因为我本来就是一个人，所以就一个人做了而已。”<br>自己的事情就要自己来干。我只是做了如此理所当然的事情而已。无论是否只是被卷进去，无论是否是突然降临在我身上的事情，但既然与之相关联，那结果还都是我自己的问题吧。所以我才会自己去做那些事。<br>如果不小心养成这样一种习惯，不去好好了解其他的做法，就随便拜托他人，肯定会变成无聊的结果吧。而已经搞错的人就算采取正经的手段，最后也不会得到正确的结果吧。<br>所以我才自己一个人行动，仅此而已。<br>就这一点来说，和我一起进行了半年以上社团活动的雪之下，也肯定是一样的。<br>“你也是一样的吧。”<br>我怀着确信，不，我怀着期待这么说着。然而，雪之下的回应却有些纠结。<br>“我…并不是这样的。”<br>她低着头，抿着嘴唇，用力握紧了外套的袖口。从已经有些松落的围巾中可以窥见她雪白色的喉咙轻轻动了一下。就像在风中痛苦喘息似的。我或许是第一次见到这样的雪之下吧。<br>雪之下仍旧面朝下，像是要绞出话语似的说道。<br>“只是，一直都觉得能做到…觉得能理解而已。”<br>这是在指谁？是指她自己？又或者是，我？两者应该都是一样的吧。一直觉得都能互相理解的，到底是谁？<br>所以，我才会还没有好好思考清楚，就觉得一定要说些什么地开了个口。<br>“那个，雪之下…”<br>虽然我开了口，但却没法继续说下去，雪之下啪地抬起头，用一如既往的镇静语气打断了我。<br>“社团活动，暂时休息一段时间吧？如果你在特意顾虑我们的话，我只能说那是完全不必要的多心。”<br>滔滔不绝的说完，她脸上的表情还是那个透明的微笑。那是如同在玻璃盒子里的精巧人偶般的沉稳微笑。<br>“我并不是在顾虑你们。”<br>我也知道我现在该说的话绝非这些。但我已经理解到，如果我还保持沉默的话，连那个空虚的部室都会失去。<br>但是，错误已经是错误，不管用什么样的说法，也不会把它变正确。<br>雪之下轻轻摇了摇头。她肩上的书包背带因为失去支撑力而落了下来。<br>“你一直在顾虑我们…从那个时候开始一直到是…所以…”<br>我拼命想要听清那随时都会消失似的声音，等待着她继续说下去。但那继续却再也没有从她嘴中出现，雪之下说出了其他的话语。<br>“其实，没必要勉强自己的。如果是这样就会被破坏，那就说明这就是仅此而已的东西吧…不对么？”<br>面对这个问题，我只能沉默。<br>这也是我一直想要坚信，却没能一直相信下去的东西。<br>然而，雪之下还仍旧相信着。她仍旧相信着在那次修学旅行中我没能相信下去的东西。<br>那个时候，我撒了一个谎。用谎言扭曲了那个不想改变，不想被改变的愿望。<br>海老名同学和三浦，以及叶山。<br>他们几个想要追求毫无变化的幸福日常。所以，他们甚至会愿意稍微撒个谎，稍微瞒一下，也想要保住那时的关系吧，既然已经理解了这一心情，我就无法简单地将其否定。<br>我并不觉得，我所做的，为了守住他们所得到的那个结论而做出的选择是错误的。<br>我把他们与我自己重合，想要认同他们的做法。我自己也十分中意那些日子，也开始觉得如果失去就会非常悔恨。<br>明明我自己也知道那是迟早会失去的东西。<br>所以我才会扭曲了自己的信条，开始对自己撒谎。重要的东西是无法替代的。而一旦失去无法替代的东西的话就再也没法得到了。所以必须要守护它才行，我对自己这么撒谎。<br>但我并没有在守护它，只是因为变得想要守护，所以才将那些东西拽住不放而已。<br>刚才，雪之下投向我的那个问题，一定是最后通牒了吧。<br>只有表面功夫的东西，是没有意义的。这是我与她所共有的一个的信念。<br>——你现在还留有这样的信念么？<br>我无法回答。现在的我，已经感觉到了，就算只有表面功夫，也不是完全没用的。我已经理解到了，这种做法也是存在着的。所以，我无法否定。<br>雪之下用寂静的眼神盯着一句话都不说的我。她沉默着，等待着我的回答。然而，她大概理解了我无声的回答，轻轻地叹了口气，露出了虚幻般的微笑。<br>“你，不用勉强自己来了哦…”<br>说出这话语的声音，非常非常温柔。<br>不只是砖头还是什么制的阶梯上响起了啪嗒啪嗒的脚步声。在这混乱的人群中，无论多么远去，她的足音也仍旧一直缠绕在我的耳边。<br>雪之下消失在了车站前的人群中。虽然我离得并不是很远，但却又让人觉得无比遥远。<br>一句话都没说地目送她离开之后，我就这么坐在了广场的阶梯上。<br>回过神来的时候，进出的一家店里传来了圣诞歌曲的音乐。广场上的圣诞树也已经亮起了灯光，上面缀着各种小礼物小玩具的包装盒。<br>那些盒子里面应该是空无一物的吧。<br>简直就像那间部室一样。<br>但即便如此，我仍在试着将那个空箱子抓在手上。<br>明明我不可能希冀着这样的东西。</p></blockquote><blockquote><p>平塚老师的脸被橘色的街灯以及来往车辆的车灯所照亮，她的表情看起来总是有些寂寥。接着，她用温柔的、暖暖的声音轻声说道。<br>“不过呢，比企谷。不伤害任何人这种事，根本是做不到的哦。一个人的存在本身，就会在不自觉中伤害到谁。活着也好，死了也罢，都会持续不停伤害别人。与他人扯上关联就会受伤，但不与他人关联也会让人受伤…”<br>说到这里，平塚老师又抽出一根烟，却只是盯着那根烟看着，继续说了下去。<br>“如果是写随便怎样都好的对象的话，伤害到他也不会让人很在意。所以这里重要的正是自觉。正因为是非常重要的东西，所以才会感受到伤害。”<br>说完这些话，她总算叼起了手里的香烟。接着嚓的一声点燃了手中的打火机，微弱的火光照亮了平塚老师的脸。她像是睡着似的闭着眼睛，表情非常的稳重。然后，她呼的吐了口烟，继续说道。<br>“如果想要把某人看的非常重要的话，也意味着要做好伤害此人的觉悟。”</p></blockquote><h3 id="⑥-尽管如此，比企谷八幡他"><a href="#⑥-尽管如此，比企谷八幡他" class="headerlink" title="⑥ 尽管如此，比企谷八幡他"></a>⑥ 尽管如此，比企谷八幡他</h3><blockquote><p>谁都可以说出【不说出来就不会明白】这句话。谁都可以在不清楚说出话语或者是传达想法有多么困难的情况下，生搬硬套这种不知从哪儿听到的别人的话语。<br>明明有的话，就算说出来也无法到达别人心里。明明有的东西，只要说出来就会分崩离析。<br>“因为说了所以会明白，这种说法是很傲慢的。说话人的自我满足，听话人的自以为是…，各种各样的因素混杂起来，就算是说了，双方也不一定能够互相理解。所以说，我想要的并不是话语。”</p></blockquote><blockquote><p>我并不是想要话语。我想要的东西，是确确实实存在的。<br>我想要的，一定不是想要互相理解、想要变得融洽、想要一起交谈、想要待在身边这种东西。我并不想要被理解。我明白自己并不被理解，也并没有想去得到理解。我所追求的，是更加严苛而残酷的东西。我想要去理解。想理解。想明白，想要得到安宁。因为不明白的东西非常让人恐惧。想要完全理解——这是非常自以为是的、独断专行的、傲慢自负的愿望。真是浅薄地令人厌恶。心怀这种愿望的自己实在是恶心得无以复加。<br>但是，万一，万一彼此都这么想的话。<br>如果双方可以互相强加这种丑恶的自我满足的话，如果真的存在能够容许这种傲慢的关系的话。<br>我知道这绝对是做不到的。我明白这种东西是无绝对无法触及的。<br>吃不到的葡萄，一定是酸的。<br>但是，我并不想要什么如同谎言一样甘甜的果实。充斥着虚妄的理解和欺瞒的关系，我并不需要。<br>我想要的，就是那酸味的葡萄。<br>就算满是酸涩，就算苦似黄连，就算味同嚼蜡，就算苛毒无比，就算如同空中楼阁，就算只是镜花水月，就算仅仅是期待也不被允许。</p></blockquote><h3 id="⑦-总有一天，由比滨结衣她"><a href="#⑦-总有一天，由比滨结衣她" class="headerlink" title="⑦ 总有一天，由比滨结衣她"></a>⑦ 总有一天，由比滨结衣她</h3><p>无</p><h3 id="⑧-在这之后，雪之下雪乃她"><a href="#⑧-在这之后，雪之下雪乃她" class="headerlink" title="⑧ 在这之后，雪之下雪乃她"></a>⑧ 在这之后，雪之下雪乃她</h3><p>无</p><h3 id="⑨-自然而然地，一色彩羽踏出一步"><a href="#⑨-自然而然地，一色彩羽踏出一步" class="headerlink" title="⑨ 自然而然地，一色彩羽踏出一步"></a>⑨ 自然而然地，一色彩羽踏出一步</h3><blockquote><p>“你又不像话地当了坏人的角色啊。”<br>啊啊，她那个时候已经来了吗…。被看到那样实在是有些不好意思。在我害臊的时候，平塚老师环顾讲习室。她的视线落在了雪之下身上。<br>“不过，那孩子竟然会做出那种举动…。稍微有点吃惊啊。”<br>“嘛，的确…”<br>我毫无意义地随声附和着。我理解有人会对雪之下在那个时候说出那种话感到吃惊。只是觉得不太好用言语表达出来。即使如此，平塚老师【嗯】地返以颔首。<br>“一同受伤的话，也许就不算受伤了。这不是协调之美吗。”<br>“啊？”<br>我不明白她低声说着的话的意思，于是问了回去。平塚老师没有看向我，继续说着话语。<br>“看到即使受伤了，变得乖僻了…以及变得扭曲了也还是尝试着的人，也会觉得他们很美。在他们身上有种货真价实的价值。我并不讨厌这样的人。”<br>然后，她转向我。从她的眼神看，彷佛在担忧着什么。<br>“但是，与此同时也有让人害怕的地方。我现在在想，这样真的好吗。因为也有别人无法理解的幸福是封闭了的幸福的说法。”</p></blockquote><h3 id="⑩-各人掌中的灯，所照亮的东西"><a href="#⑩-各人掌中的灯，所照亮的东西" class="headerlink" title="⑩ 各人掌中的灯，所照亮的东西"></a>⑩ 各人掌中的灯，所照亮的东西</h3><p>无</p><h2 id="第十卷"><a href="#第十卷" class="headerlink" title="第十卷"></a>第十卷</h2><h3 id="①-临到头来，比企谷小町也要求神拜佛"><a href="#①-临到头来，比企谷小町也要求神拜佛" class="headerlink" title="① 临到头来，比企谷小町也要求神拜佛"></a>① 临到头来，比企谷小町也要求神拜佛</h3><p>无</p><h3 id="②-一如既往，雪之下阳乃仍在制造混乱"><a href="#②-一如既往，雪之下阳乃仍在制造混乱" class="headerlink" title="② 一如既往，雪之下阳乃仍在制造混乱"></a>② 一如既往，雪之下阳乃仍在制造混乱</h3><blockquote><p>我所知道的雪之下雪乃…<br>只要被由比滨死赖皮脸地要求就没法坚持到底、又最喜欢猫、假日还会抱着潘先生的抱枕在电脑上看猫视频。<br>意外地了解。<br>如果由比滨要送她猫脚室内袜的话，那我也送个与之相应的东西吧。<br>为了让她独自度过的那些时间，能变得更加温暖，更加温和。</p></blockquote><h3 id="③-不知何时，一色彩羽开始久坐不去"><a href="#③-不知何时，一色彩羽开始久坐不去" class="headerlink" title="③ 不知何时，一色彩羽开始久坐不去"></a>③ 不知何时，一色彩羽开始久坐不去</h3><p>无</p><h3 id="④-即使如此，三浦优美子还是想要知晓"><a href="#④-即使如此，三浦优美子还是想要知晓" class="headerlink" title="④ 即使如此，三浦优美子还是想要知晓"></a>④ 即使如此，三浦优美子还是想要知晓</h3><blockquote><p>即使知晓那是无法实现的愿望，她也仍要反抗，仍要持续追求的话。<br>那么，她就和某处的某人是一样的。</p></blockquote><h3 id="⑤-直到那天位置，户塚彩加会一直等待"><a href="#⑤-直到那天位置，户塚彩加会一直等待" class="headerlink" title="⑤ 直到那天位置，户塚彩加会一直等待"></a>⑤ 直到那天位置，户塚彩加会一直等待</h3><p>无</p><h3 id="⑥-飒爽地，雪之下阳乃隐去于黑暗之中"><a href="#⑥-飒爽地，雪之下阳乃隐去于黑暗之中" class="headerlink" title="⑥ 飒爽地，雪之下阳乃隐去于黑暗之中"></a>⑥ 飒爽地，雪之下阳乃隐去于黑暗之中</h3><p>无</p><h3 id="⑦-不论何时，叶山隼人都能顺应期待"><a href="#⑦-不论何时，叶山隼人都能顺应期待" class="headerlink" title="⑦ 不论何时，叶山隼人都能顺应期待"></a>⑦ 不论何时，叶山隼人都能顺应期待</h3><p>无</p><h3 id="⑧-于是，他们她们的过去与未来互相交错，归结于现在"><a href="#⑧-于是，他们她们的过去与未来互相交错，归结于现在" class="headerlink" title="⑧ 于是，他们她们的过去与未来互相交错，归结于现在"></a>⑧ 于是，他们她们的过去与未来互相交错，归结于现在</h3><p>无</p><h3 id="⑨-然而，雪之下阳乃如是说"><a href="#⑨-然而，雪之下阳乃如是说" class="headerlink" title="⑨ 然而，雪之下阳乃如是说"></a>⑨ 然而，雪之下阳乃如是说</h3><p>无</p><h2 id="第十一卷"><a href="#第十一卷" class="headerlink" title="第十一卷"></a>第十一卷</h2><h3 id="①-冬天，在察觉到来之时既已离去"><a href="#①-冬天，在察觉到来之时既已离去" class="headerlink" title="① 冬天，在察觉到来之时既已离去"></a>① 冬天，在察觉到来之时既已离去</h3><h3 id="②-就这样，全是女生的战役打响了"><a href="#②-就这样，全是女生的战役打响了" class="headerlink" title="② 就这样，全是女生的战役打响了"></a>② 就这样，全是女生的战役打响了</h3><blockquote><p>一直操心周围人际关系的这种心情我实在难以理解。然而，却能产生共鸣——对于想要得到这种答案的愿望。<br>大概这点雪之下也是相同的。从雪之下的表情也能看出她对由比滨的阴沉感到担心。</p></blockquote><h3 id="③-出乎意料地，一色彩羽的缺席所带来的是"><a href="#③-出乎意料地，一色彩羽的缺席所带来的是" class="headerlink" title="③ 出乎意料地，一色彩羽的缺席所带来的是"></a>③ 出乎意料地，一色彩羽的缺席所带来的是</h3><blockquote><p>就这样被留下来的三人，比起刚才进一步真实地体会到了怀念的感觉。<br>但是，感觉到怀念，或许也是因为很多事情都已经发生了变化吧。也是因为不知在何处失去了原有的同一性吧。也是因为领悟到再也无法触及与那完全相同的东西这件事吧。<br>所以，才会令人怀念。<br>如果确实开始变动了，那么，一定有一天会迎来停止的结局。<br>脸上满是纯粹的微笑的由比滨，以及彷佛对此感到耀眼而凝望她的雪之下。两个人，聊着毫无内容的空洞内容。<br>明明只是这样的光景，但不可思议的是，心里却装得满满的。</p></blockquote><h3 id="④-于是，男生们的一喜一忧开始了"><a href="#④-于是，男生们的一喜一忧开始了" class="headerlink" title="④ 于是，男生们的一喜一忧开始了"></a>④ 于是，男生们的一喜一忧开始了</h3><p>无</p><h3 id="⑤-没来由地，平塚静讲述起过去时和现在进行时"><a href="#⑤-没来由地，平塚静讲述起过去时和现在进行时" class="headerlink" title="⑤ 没来由地，平塚静讲述起过去时和现在进行时"></a>⑤ 没来由地，平塚静讲述起过去时和现在进行时</h3><p>无</p><h3 id="⑥-他仍未能触及那所求的真货，真货在不停出错"><a href="#⑥-他仍未能触及那所求的真货，真货在不停出错" class="headerlink" title="⑥ 他仍未能触及那所求的真货，真货在不停出错"></a>⑥ 他仍未能触及那所求的真货，真货在不停出错</h3><blockquote><p>不论是谁，一定都一直拥有着被某人所划定的自我，同时却也总是与之相龊龉。不论是我还是她都是如此。我们总是与我们的【样子】有着分歧。<br>这是不需要向任何人确认就能明白的事实。<br>因为，过去的我说过，从前的比企谷八幡一直在号叫。<br>这样真的好吗。这就是你的期望吗。这就是比企谷八幡吗？<br>将那咒骂，那怒号，那咆哮，捂紧耳朵，闭上双眼，拒之身外。代替话语冒出口的，是凝聚着热气的叹息。<br>就连自己都无法断言那就是自己的样子。那么，真货这种东西，真正的我们又到底在于何处呢？为什么，这样的我们呢能够划定关系这种东西呢？<br>【违和感】，一旦将之如此命名，便不得不在这一框架中思考。<br>这份感情，这一关系，这一定是不能被定义的东西。一定是不可以被命名的东西。一定是不应该探寻其意义的东西。因为一旦为止赋予意义，它就会失去所有其他的功能。<br>如果能为其对号入座，一定更加轻松，但之所以没有这样做，是因为我知道：一旦为其定型，再要改变，就只能将其破坏。<br>正因我追求永不磨灭之物，所以我一直避免为其命名。<br>无论是我也好，她也好，是否都在依靠着无形的言语？我的脑中塞满了这样的想法。<br>至少，能让一场雪来覆盖掉各种各样的东西的话，我就不用考虑这种多余的事了吧。<br>但是，这座城市里的雪却是难得一见，而今晚的夜空也澄澈鲜明。<br>星星的光芒如此明亮，将现在的我照耀得原形必露。</p></blockquote><h3 id="⑦-请不自已地，雪之下雪乃的眼瞳澄澈明晰"><a href="#⑦-请不自已地，雪之下雪乃的眼瞳澄澈明晰" class="headerlink" title="⑦ 请不自已地，雪之下雪乃的眼瞳澄澈明晰"></a>⑦ 请不自已地，雪之下雪乃的眼瞳澄澈明晰</h3><blockquote><p>从不积极接近别人，但是，我也从不主动疏远他人。<br>加以意识，划清明确的界限，掩藏的滴水不漏，甚于以往地故作迟钝，不去多想，将贤明的观察者当到极致，一直自觉地将自己置于卑鄙的立场上。<br>为了不去将耿怀于胸的违和感认知为违和感，我选择了保持距离。<br>我非常清楚，这只是为了不犯错才采取的行为，并非那个唯一正确的答案。然而，我却想将其压在心底。<br>所以我才会被那个人看透么。<br>我的心中又传来了苛责之声。<br>比企谷八幡就是这种人么。这种东西就是你所期望的么。</p></blockquote><h3 id="⑧-无论何时，由比滨结衣的眼神都是那么柔和温暖"><a href="#⑧-无论何时，由比滨结衣的眼神都是那么柔和温暖" class="headerlink" title="⑧ 无论何时，由比滨结衣的眼神都是那么柔和温暖"></a>⑧ 无论何时，由比滨结衣的眼神都是那么柔和温暖</h3><blockquote><p>只有从水槽里照出的光，勾勒出了一个静静站在玻璃前的朦胧人影。<br>从那种站姿来看，我并不会认错人。<br>雪之下雪乃。<br>在暗淡的水槽灯光照射下的她彷佛像是一幅画，使我一时无法出声叫她。本该呼出的气无意识地堵在胸口，我不得不在原地停下了脚步。<br>这时听到了断断续续脚步声的雪之下朝这里看了过来。察觉到她有轻微地点头后，我才继续走了过去。<br>“由比滨同学呢？”<br>并不是看着在旁边的我，而是注视着水槽说道。<br>“在拍小蓝企鹅的照片。她说马上来，所以在这里等一会儿就好”<br>“这样…”<br>这之后我们就没有对话，就这样望着水槽。巨大的海藻上打着淡淡的灯光，周围有五颜六色的鱼在游动。<br>在这株晃来晃去不可靠的巨藻之中，无数的小鱼在巨型叶片的空隙里穿梭交错。带着青色鳞片的小鱼在巨藻的暗处藏匿身影，也有特别起眼的红色的鱼旁若无人地悠然游动。<br>视线追着那只鱼看着的雪之下忽然开口。<br>“…也有悠然自得的呢”<br>“啊啊，毕竟那条鱼很大啊”<br>雪之下的声音小得像是自言自语，不过因为我们看的是同一条鱼，所以我还是如此答道。<br>“没有依靠也没有容身之处…。只好四处躲藏，随波逐流，跟着某些东西向前走…最后撞到无形的墙壁。”<br>雪之下像是要触摸玻璃似的伸出手，然而却无力地放了下来。我在旁边窥视到她的瞳孔，似乎并没有焦距在一点，仅仅是对着水槽而已。<br>“你说的是那条鱼？”<br>因为不知道她在看哪条，所以这样问道。<br>雪之下并没有马上回答，而是安稳地呼出一口气。<br>“…是我自己”</p></blockquote><h3 id="⑨-春天，积雪之下结一成形，抽枝发芽"><a href="#⑨-春天，积雪之下结一成形，抽枝发芽" class="headerlink" title="⑨ 春天，积雪之下结一成形，抽枝发芽"></a>⑨ 春天，积雪之下结一成形，抽枝发芽</h3><blockquote><p>“我不赞成你的提议。雪之下的问题应该由雪之下自己解决”<br>我握紧了拳头正视两人。由比滨一言不发，凛然又严肃地注视着我。<br>由比滨结衣是个温柔的女孩，我如此擅自贴上了标签。<br>雪之下雪乃是一个坚强的女孩，我如此擅自强加了理想。<br>就这样自我麻痹着，自以为然地承蒙了她们带给我的一切。所以只有这次，不能再委托他人的决定，不能再逃避至他人的温柔，不能在对他人的善良还以谎言。<br>因为，由比滨结衣是温柔的女孩，雪之下雪乃是坚强的女孩。<br>“…而且，那样的话，仅仅是欺瞒而已吧”<br>吐露出的心声如波涛退潮一般消逝，只剩海浪轻轻拍打上岸又回归海中的声音，周而复始。<br>雪之下眼眶湿润地颤动着嘴唇，由比滨则露出温暖的眼神继续点头，等待我话语的后续。<br>“什么模棱两可的答案，串通一气的关系…这些都不需要”<br>我想要的东西不是这样的东西。<br>虽然真是有够愚蠢的。<br>明明知道没有那种东西，明明知道要是钻牛角尖的话，最终会落得一无所获得下场。<br>然而。<br>“即使如此，也要左思右想，经历痛苦，不断挣扎。我要…”<br>从口中挤出得话语已然算不上话语。<br>我知道这样做并不正确。我知道感到开心的话就该知足。如果想象着五光十色的将来就能日复一日的度过，那任谁都不会感到痛苦了吧。<br>即使如此我也想强加上自私的愿景。因为我没有坚强到能半睁着眼就度过一生，因为不想怀疑自己之后再对重要的人撒下谎言。<br>所以我要一个像样的答案。一个没有敷衍虚饰的，我期望的答案。</p></blockquote><h2 id="第十二卷"><a href="#第十二卷" class="headerlink" title="第十二卷"></a>第十二卷</h2><h3 id="①-不久，季节轮转，雪消冰融"><a href="#①-不久，季节轮转，雪消冰融" class="headerlink" title="① 不久，季节轮转，雪消冰融"></a>① 不久，季节轮转，雪消冰融</h3><blockquote><p>无法放任那个名为鹤见留美的人不管，也是因为她的样子和某人重叠了吧。明明【大家】这种概念只是个暧昧的存在，但要和大家同步的压力却强迫而来，差一点就把她压垮，或许我只是无法允许这种事情发生吧。<br>那最后的结果也并不能说是好的。<br>然而，对于明知那只是假货却仍旧向其伸出双手的她的身姿，我还是抱有着些许的期望，或者是祈愿吧。这也是个只有我还记得就好的事情。<br>但，回忆东西不管本人怎么想，是一种只要共同经历的人都会共有的东西。</p></blockquote><blockquote><p>雪乃这个名字和她十分相衬。优美、短暂，读音中还有这一丝寂寥。不可思议的，我心中并没有浮现那些冰寒冷彻的形容词。</p></blockquote><blockquote><p>这种自己决定的事情是必须做到的。我一直以来都是如此。虽然会随波逐流，虽然会被携卷而走，虽然会被强拉硬拽，但最后的判断都必须由自己做出。<br>这就是我的性格。完全算不上是有决断力之类的值得褒扬值得自夸的品性，只是单纯的习性。所谓的独行正是因为只有自己一人，所以全都自己来做。这只是所谓的全能选手，绝非万能，不能说大部分的事情都很不擅长。真要我说有什么特长的话，也就只有哄骗自己让自己接受并放弃吧。<br>然而，现在并不用这些戏言来蒙骗自己的时候。<br>真要说实话的话。<br>其实，我觉得我一直在避开对将来事情的思考。<br>这里用逃开来形容有些不太正确，避开，应该是最接近的词语。<br>或者也可以说是忌避。<br>绝不是逃避。<br>我现在都有些感觉到了悔恨。<br>结果，我并没有冀望着任何的解答、解决、结论。而只是希望着消解。只是等待着眼前的这些课题问题难题在不知不觉中得到暧昧模糊的云消雾散。</p></blockquote><blockquote><p>她的话语中，有着我能够理解认同的部分，或者说是我也有所同感的部分。<br>如果不管过去多久都没有变化的话，如果不管如何放在一边都不会褪色的话，那我并不反对称呼其为真货。这与那写过段时间或者略微放着不管就会损坏的假货是不同的。<br>转过脸庞，撇开视线，假装看不见，已经被遗忘，即便如此都不会消失的话，那把它称为真心的愿望也是可以的吧。<br>如果这是她所期望的结果，那我已无话可说。<br>我所一直拘泥的就只有一点。<br>那就是雪之下雪乃自己所选，自己决定。<br>不是因为谁的意愿或思绪，也不是因压力、气氛、氛围之类的东西而定。就算这个决定会让某些东西崩裂毁坏，我也没有剥夺她这些崇高尊崇的东西的理由。<br>不是为了应和谁的求托，而是从心底发出的话语，这才是真正的冀望。</p></blockquote><blockquote><p>雪之下回过身来，面朝着未曾移步的我们。<br>那流淌的黑发、随风飘起的裙摆、晃动的围巾、以及她站立的身子都非常优美，以至于让我犹豫着是否靠近。<br>但，已经约好了要看着她。<br>所以，我也向着她那边走了过去。<br>即使会有悔恨，但只愿那里有着不掺谎言的话语。我并未向谁祈祷，只是如此冀望着。</p></blockquote><h3 id="②-虽是这模样，雪之下阳乃也没有醉"><a href="#②-虽是这模样，雪之下阳乃也没有醉" class="headerlink" title="② 虽是这模样，雪之下阳乃也没有醉"></a>② 虽是这模样，雪之下阳乃也没有醉</h3><p>无</p><h3 id="③-突然，比企谷小町改变一新"><a href="#③-突然，比企谷小町改变一新" class="headerlink" title="③ 突然，比企谷小町改变一新"></a>③ 突然，比企谷小町改变一新</h3><p>无</p><h3 id="④-至今，一次都未曾碰触到那把钥匙"><a href="#④-至今，一次都未曾碰触到那把钥匙" class="headerlink" title="④ 至今，一次都未曾碰触到那把钥匙"></a>④ 至今，一次都未曾碰触到那把钥匙</h3><p>无</p><h3 id="⑤-果然，一色彩羽是最强的后辈"><a href="#⑤-果然，一色彩羽是最强的后辈" class="headerlink" title="⑤ 果然，一色彩羽是最强的后辈"></a>⑤ 果然，一色彩羽是最强的后辈</h3><p>无</p><h3 id="⑥-蓦然间，由比滨结衣畅想起未来"><a href="#⑥-蓦然间，由比滨结衣畅想起未来" class="headerlink" title="⑥ 蓦然间，由比滨结衣畅想起未来"></a>⑥ 蓦然间，由比滨结衣畅想起未来</h3><p>无</p><h3 id="⑦-就算，知道会后悔这个选择"><a href="#⑦-就算，知道会后悔这个选择" class="headerlink" title="⑦ 就算，知道会后悔这个选择"></a>⑦ 就算，知道会后悔这个选择</h3><p>无</p><h2 id="第十三卷"><a href="#第十三卷" class="headerlink" title="第十三卷"></a>第十三卷</h2><h3 id="①-深切地，平塚静怀念着过去"><a href="#①-深切地，平塚静怀念着过去" class="headerlink" title="① 深切地，平塚静怀念着过去"></a>① 深切地，平塚静怀念着过去</h3><p>无</p><h3 id="②-不论如何，一色彩羽有想确认的东西"><a href="#②-不论如何，一色彩羽有想确认的东西" class="headerlink" title="② 不论如何，一色彩羽有想确认的东西"></a>② 不论如何，一色彩羽有想确认的东西</h3><blockquote><p>但是，要说什么才能理解呢。<br>我的感情和感伤，本来就是无法用语言来表达的，正因为如此，可以形容成任何东西而非常麻烦，是那种肯定不管怎么传达也束缚互相理解的东西。这样不透明，不定型，不鲜明的东西，套用墨守陈规的既存的语言的话，就会从边角开始劣化总有一天会造成很大的错误。更重要的是，用一句话来概括这些我不能接受。</p></blockquote><h3 id="③-直到最后，由比滨结衣继续守望着"><a href="#③-直到最后，由比滨结衣继续守望着" class="headerlink" title="③ 直到最后，由比滨结衣继续守望着"></a>③ 直到最后，由比滨结衣继续守望着</h3><p>无</p><h3 id="④-重新，比企谷八幡诉说着"><a href="#④-重新，比企谷八幡诉说着" class="headerlink" title="④ 重新，比企谷八幡诉说着"></a>④ 重新，比企谷八幡诉说着</h3><p>无</p><h3 id="⑤-不知何时，职员表开始流动了"><a href="#⑤-不知何时，职员表开始流动了" class="headerlink" title="⑤ 不知何时，职员表开始流动了"></a>⑤ 不知何时，职员表开始流动了</h3><p>无</p><h3 id="⑥-暗地里，叶山隼人后悔着"><a href="#⑥-暗地里，叶山隼人后悔着" class="headerlink" title="⑥ 暗地里，叶山隼人后悔着"></a>⑥ 暗地里，叶山隼人后悔着</h3><p>无</p><h3 id="⑦-隔着镜片，海老名姬菜看到的风景是"><a href="#⑦-隔着镜片，海老名姬菜看到的风景是" class="headerlink" title="⑦ 隔着镜片，海老名姬菜看到的风景是"></a>⑦ 隔着镜片，海老名姬菜看到的风景是</h3><p>无</p><h3 id="⑧-至少、拜托不要再弄错了"><a href="#⑧-至少、拜托不要再弄错了" class="headerlink" title="⑧ 至少、拜托不要再弄错了"></a>⑧ 至少、拜托不要再弄错了</h3><p>无</p><h2 id="第十四卷"><a href="#第十四卷" class="headerlink" title="第十四卷"></a>第十四卷</h2><h3 id="①-即便如此，比企谷八幡的日常仍在继续"><a href="#①-即便如此，比企谷八幡的日常仍在继续" class="headerlink" title="① 即便如此，比企谷八幡的日常仍在继续"></a>① 即便如此，比企谷八幡的日常仍在继续</h3><p>无</p><h3 id="②-终有一天，将会习惯这样的关系"><a href="#②-终有一天，将会习惯这样的关系" class="headerlink" title="② 终有一天，将会习惯这样的关系"></a>② 终有一天，将会习惯这样的关系</h3><p>无</p><h3 id="③-每当闻起那阵香气，定会唤起季节的回忆"><a href="#③-每当闻起那阵香气，定会唤起季节的回忆" class="headerlink" title="③ 每当闻起那阵香气，定会唤起季节的回忆"></a>③ 每当闻起那阵香气，定会唤起季节的回忆</h3><p>无</p><h3 id="④-然后，雪之下雪乃静静地挥手"><a href="#④-然后，雪之下雪乃静静地挥手" class="headerlink" title="④ 然后，雪之下雪乃静静地挥手"></a>④ 然后，雪之下雪乃静静地挥手</h3><p>无</p><h3 id="⑤-飒爽地，平塚静走在前面"><a href="#⑤-飒爽地，平塚静走在前面" class="headerlink" title="⑤ 飒爽地，平塚静走在前面"></a>⑤ 飒爽地，平塚静走在前面</h3><p>无</p><h3 id="⑥-像那时一样，由比滨结衣希求到"><a href="#⑥-像那时一样，由比滨结衣希求到" class="headerlink" title="⑥ 像那时一样，由比滨结衣希求到"></a>⑥ 像那时一样，由比滨结衣希求到</h3><p>无</p><h3 id="⑦-只有触碰到的温暖，确切地传达着心意"><a href="#⑦-只有触碰到的温暖，确切地传达着心意" class="headerlink" title="⑦ 只有触碰到的温暖，确切地传达着心意"></a>⑦ 只有触碰到的温暖，确切地传达着心意</h3><blockquote><p>“…除那以外，没有和你关联的办法了”<br>“哈？”<br>雪之下停下脚步，蓦然回头。那表情充满着惊讶，【不明白什么意思】彷佛要从那半张开的嘴中脱口而出。<br>“一旦社团消失了，就不能再有交点了。真的想不到其他的把你拉出来的借口了”<br>“为什么要做那种事…”<br>自远处驶来的汽车的车灯，照亮了呆呆站在天桥中央的雪之下的脸庞。白色的光芒中，我清楚地看到她轻咬着嘴唇。<br>“…约定怎么样了？你明明答应过要实现愿望的”<br>隐含责备之意的声音颤动了起来，她悔恨地低下了视线。<br>我猜到她一定会这么说的，也知道她一定会露出那样的表情。<br>但是，即便如此，我也下定了决心，就算自己的任性给某人带来了麻烦，也绝不反悔。于是，我接着说了下去，<br>“可以说那也是实现愿望的一环”<br>雪之下用稍显困惑的眼神看着我，歪着头无声地向我询问。天桥边的橙色路灯和那天的晚霞一样地耀眼，因此我轻轻地眯起了眼。<br>“…希望普普通通的放学后有你在，收到了这样的话”<br>在我传达了她的话语之后，雪之下的声音一时语塞。然后，背过脸去藏起了湿润的眼睛。<br>“…那样的话，不特地做这种事不是也能做到吗”<br>“不可能吧。熟人、认识的人、朋友、同学，称呼虽然有很多很多种，但是都没有能好好保持这种关系的自信。”<br>“你可能是那样…。但是我会努力的。会做得更好，一定会的。所以，没关系”<br>说完，雪之下既像是要中止对话，又像是要斩断过去一般迈出脚步。<br>那副逞强的样子让我感到了欣慰，于是不禁扬起嘴角露出一丝挖苦的微笑。<br>“这话可难听了点，不过我和你不仅沟通力很低，性格还别扭的不行。此外，也很不会与人相处。事到如今完全不觉得能变得圆滑。拉开了距离以后，别说是保持原样了，我甚至有渐行渐远的自信哦。所以…”<br>在她走了几步之后，我跟了上去。<br>看着远去的背影，我伸出了手，却又不由地犹豫起来。<br>我明白，如果要继续谈话的话，只要叫住她就行了。即使继续像那样走下去，交谈也并不困难。再说了，根本不可能有什么特别的理由就去触碰她的手。<br>但是，理由确实存在。<br>唯一的，不容退让的理由。<br>“…放手了的话，就再也抓不住了啊”<br>脱口而出的话语，就像是说给自己听一样。不对，是为了说给自己听才会说出那样的话。接着，我伸出了手。<br>单手推着自行车我的样子有些狼狈，而且手里还出了很多汗，也不清楚该用多大的力道。<br>即便如此，我还是抓住了雪之下的袖口。<br>把那纤细到令我惊讶的手腕紧紧收入掌中。<br>“…”<br>雪之下吓了一跳，随即停在了原地。她的脸上满是惊讶，她的视线在自己的手腕和我的脸见摇摆不定。<br>我立刻提下自行车的脚蹬，迅速地用单手停下车。彷佛一旦有片刻松手，就会像认生的猫一样逃脱。<br>“虽然说这种话超级羞耻，恨不得马上去死，但是…”<br>说到一半，我将深长的气息倾吐而出。<br>雪之下有些拘束地扭动着身子，像是在为了让我松手而进行轻微的抗议。她的样子宛如不愿意用肉球去碰水的毛一般，别说是松手了，在说完之前我都想抓住不放。</p></blockquote><h3 id="⑧-再一次，那扇门扉被打开"><a href="#⑧-再一次，那扇门扉被打开" class="headerlink" title="⑧ 再一次，那扇门扉被打开"></a>⑧ 再一次，那扇门扉被打开</h3><p>无</p><h3 id="⑨-那片青色，纵然因岁月而褪色也不会改变"><a href="#⑨-那片青色，纵然因岁月而褪色也不会改变" class="headerlink" title="⑨ 那片青色，纵然因岁月而褪色也不会改变"></a>⑨ 那片青色，纵然因岁月而褪色也不会改变</h3><p>无</p><h3 id="⑩于是，比企谷八幡如是说"><a href="#⑩于是，比企谷八幡如是说" class="headerlink" title="⑩于是，比企谷八幡如是说"></a>⑩于是，比企谷八幡如是说</h3><p>无</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>我第一次接触《我的青春恋爱物语果然有问题》是什么时候呢？应该是第一季动漫化的时候，那个时候我是高二和八幡一样的年级，那个时候我对于八幡的孤独理论很是无法认同，因为那个时候我根本没经历过孤独。动漫和小说比较起来，我还是比较喜欢小说，因为文字能够传达的东西更多。</p><p>《我的青春恋爱物语果然有问题》完结了，我也大三了。比起高二的懵懂不知，经历了许许多多的事情后，我重拾了《我的青春恋爱物语果然有问题》，从第一卷看到了第十四卷。</p><p>一系列的作品始终是他与她的故事，故事的发展就是围绕着他和她之间的矛盾。</p><p>雪乃是一个主张遇到问题就应该竭尽自己全力去解决问题的人，而八幡是一个主张遇到问题把问题消灭掉从而解决问题的人。从故事的一开始，他和她的观点就充满着矛盾。然而，他和她却是相似的，都是孤独的人，都是贯彻自己内心中的想法的人。哪怕不被理解也依然坚持自己的人。都是认为比起那些虚伪的关系，在这个世界上有着更真实的、值得追求的东西。</p><p>他和她完全不像，却又如此相像。</p><p>八幡在文章的前半部分奠定了一个基调：他是孤独的。但其实就我个人理解看，他也是渴望的，虽然口口声声说不被他人理解也无妨。但他也确确实实渴望着某些东西。所以他憧憬着雪之下雪乃，因为他从雪乃的身上看到了哲学意义上的个人主义。</p><p>八幡帮助鹤见留美以及在校园祭上对相模南说的话，采取的是自己认为是正确的做法，将问题消灭掉。在这期间，他和她的矛盾并没有很深刻地激烈化起来，相反八幡通过这些事情逐渐让雪之下雪乃认同他这种做法。</p><p>八幡其实也在不知不觉中和别人产生了联系，与这个社团的羁绊也逐渐加深，与她产生了联系。因为，人是社会的人。我们都无法脱离这个社会生活，然而我们总会找到一些方式坚持自己。八幡对社会的看法着实是过于偏激了，但是对于大家的看法我是超级认同的。大家其实是一个对于个人意志的束缚。</p><p>因此，当他看见了另一个和他社团类似的东西，也就是现充组也希望维持这种日常的时候，他也选择了他惯有的方式来消灭了这个问题。就是因为这件事，他和她的矛盾爆发了。她认为这种虚伪的日常是不值得的。而且，她也心疼起了八幡，并且对自己产生了疑问，她以为他和她是能互相理解的，但是为什么八幡会做出这个选择了。</p><p>其实很简单，因为他从别人的日常里看到了自己。他也怕他的日常会这样失去，对于孤独的人来说，就是如此。</p><p>然而，学生会的事情再次让矛盾升级了，雪乃或许自己是相当学生会会长的，但是却没能被理解。他开始怀疑自己了。平塚先生曾告诉过八幡：用你的方式是拯救不了对你来说很重要的人的。因为八幡总是在消灭问题。</p><p>其实，后面的文章一直在解决一个问题，八幡直面内心的问题，他是一个过于别扭的人，她是一个过于直率的人，他和她都无法好好表达自己的感情。他认为无论怎么说都是无法互相理解的，这是一种傲慢。而她也无法好好表达自己的情感。</p><p>所谓的真货，应该就是虽然说了也可能无法理解，但是不说就一定不会明白，我们就是在不断伤害他人的过程中逐步成长的。因为失去的东西是无法回来的，一个人能把握的只有现在。</p><p>八幡也在最终卷成长了，学会了直面自己的内心。</p><p>一直都是他和她的故事，团子输是必然的。</p><p>看完之后，不禁感慨，孤独之人遇上了另一个孤独之人相互救赎的故事是多么地美好。然而小说毕竟是小说，真正的孤独之人怎会得到救赎了。</p><p>我还是比较喜欢《cross channel》得出的答案：孤独者唯一的救赎就是接受孤独。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轻小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZStack OSAL分析</title>
      <link href="/2021/03/06/ZStack-OSAL%E5%88%86%E6%9E%90/"/>
      <url>/2021/03/06/ZStack-OSAL%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="OSAL的思想起源"><a href="#OSAL的思想起源" class="headerlink" title="OSAL的思想起源"></a>OSAL的思想起源</h2><p>本部分拟通过研究相关文献总结出OSAL (Operating System Abstraction Layer) 的产生原因以及思想起源。</p><h3 id="早期WSN的架构"><a href="#早期WSN的架构" class="headerlink" title="早期WSN的架构"></a>早期WSN的架构</h3><p>在早期WSN的软件架构中，开发环境是极其轻量的 (Lightweight)，开发者直接操控硬件进行开发：</p><pre class="mermaid">graph BT  A("硬件(Hardware)") -->  B("应用端 (Application)")  B --> A</pre><p>在这种软件架构下，存在以下四种限制：</p><ul><li><strong>与硬件依赖 (Hardware dependent)的应用端程序</strong><br>开发者直接面向硬件底层，应用端程序的代码与低级硬件细节相耦合。例如，操纵硬件寄存器来进行网络控制。在这种情况下，当硬件提供的接口发生了变化将会影响开发者专注于应用端程序的开发，强迫开发者深入硬件细节。</li><li><strong>没有分离开的独立进程 (Independent process)</strong><br>在这种架构下，只存在一个进程。这样就迫使开发者组合不同应用程序代码，这样就导致组合出来的程序在<strong>数据请求</strong>、<strong>数据处理</strong>、<strong>时间同步</strong>会相互关联，使得程序可读性变差，难以调试。</li><li><strong>无法对时间进行控制</strong><br>由于在一个程序里组合了不同的应用代码，使得对于时间进行精确的掌控变得尤为困难。只要改变了一部分涉及到延迟的代码，整个系统的时间将会发生变化。</li><li><strong>无处理器分配机制</strong><br>程序始终顺序执行不同的应用代码，处理器无法获得任何优先权。</li></ul><p>随着发展，WSN的架构在硬件上为开发者提供了一些十分重要的抽象：</p><pre class="mermaid">graph TB  A("应用端(Application)")--> B("操作系统API")  B --> A  B --> E  B --> F  D("基本函数层(Basic function)")  C("硬件(Hardware)")  D --> C  E("中断服务程序 (ISR) ")  F("硬件表示层 (HPL)")  E-->D  F-->D  style B fill:#f96</pre><ul><li><p><strong>基本函数 (Basic function) 层</strong><br>是一个功能十分简单的层，提供以下基础功能：</p><ul><li>对寄存器进行读、写功能</li><li>产生硬件中断，将中断信息传递给上层</li></ul></li><li><p><strong>中断服务程序 (Interrupt Service Routines ISR) 层</strong><br>用于处理中断，并且能够对信号量 (semaphore) 进行管理，对硬件进行基本的处理。</p></li><li><p><strong>硬件表示层 (HPL)</strong><br>提供一个完整的接口用于硬件和应用之间的交互。</p></li></ul><p>我们下面介绍操作系统的使用，WSN社区广泛使用了一系列操作系统 (OS, Operating System)，尽管这些不同的操作系统几乎都提供具有相同功能的服务，但是它们使用了不同的应用编程接口 (API, Application Programming Interface)，从而使可移植性 (Portability) 变得更加困难，对于不同平台，提供的API 不相同，导致代码的兼容性较差。</p><h3 id="OSAL的提出"><a href="#OSAL的提出" class="headerlink" title="OSAL的提出"></a>OSAL的提出</h3><p>通过上述分析可知，对于不同的硬件平台以及操作系统提供的不同API 都会导致软件的可移植性变差。因此，人们提出了一个新的想法：<strong>在操作系统API与应用端之间的交互上，再提供一层抽象</strong>，这个抽象就是OSAL：</p><pre class="mermaid">graph BT  A("应用端(Application)")--> C("OSAL(操作系统抽象层)")  C --> A  C -.->B("操作系统API")  B -.->C  style C fill:#f96</pre><p>OSAL为应用端提供了对操作系统API的一个抽象，就是为了解决不同操作系统提供功能相同的服务但却不具备相同API的问题。这样当软件代码要移植到不同的操作系统时，仅仅只需要重新定义OSAL的相关功能，但并不改变OSAL为用户提供的接口，也就是OSAL API。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过上述分析可知，我们可以得出以下结论：</p><ul><li>OSAL 的产生的根本目的是为了提高<strong>代码的可移植性</strong></li><li>OSAL 在严格意义上并不是操作系统，只是对于不同操作系统的API 进行了<strong>一层抽象</strong>，统一了用户接口</li></ul><h2 id="TI-OSAL"><a href="#TI-OSAL" class="headerlink" title="TI OSAL"></a>TI OSAL</h2><p>本部分拟对TI公司的 Z-Stack 中的OSAL 进行一个大致的介绍。首先通过查阅TI公司相关手册，给出TI公司文档中对于OSAL API的一些解释：</p><blockquote><p>The purpose of this document is to define the OS Abstraction Layer (OSAL) API. This API allows the software components if a TI stack product, such as Z-Stack, RemoTI, and BLE, to be written independently of the specifics of the operating system, kernel of tasking environment.</p></blockquote><p>通过上述引用可知，TI 公司设计OSAL API的目的也是在于开发者使用不同的协议栈面对的接口是一致的。实际上Z-Stack 协议栈并不具备实际的操作系统，但是TI 公司有三个协议栈均提供的是相同的OSAL API。可见TI 公司也是通过抽象的方式统一了提供给开发者的接口。</p><p>所以严格来讲，Zigbee 使用TI 公司的Z-Stack，而Z-Stack 中的OSAL 提供的仅仅是一层抽象，并不是严格意义上的操作系统。下面，从不同的角度通过对Z-Stack 的OSAL 进行一个系统化以及模块化的大致分析。</p><h3 id="Zigbee总体架构"><a href="#Zigbee总体架构" class="headerlink" title="Zigbee总体架构"></a>Zigbee总体架构</h3><p>首先，根据查阅相关资料，绘出Zigbee的总体架构如下图所示：</p><pre class="mermaid">graph TB  A(Z-Stack)  B(Application)  A --> C(OSAL APIS)  B --> C  C--> D(OSAL)  E(HAL)  F(ISR)  D --> E  D --> F  E --> G(Hardware)  F --> G(Hardware)  style C fill:#f96</pre><p>从图中我们可以认为，OSAL 就是Zigbee的一个“操作系统”给开发者提供了一些接口也就是OSAL API ，在下面的部分我们会对OASL 进行一个整体分析。</p><h3 id="OSAL概述"><a href="#OSAL概述" class="headerlink" title="OSAL概述"></a>OSAL概述</h3><p>OSAL 提供了如下的功能：</p><ul><li><strong>任务注册、初始化以及开始 (Task registration, initialization, starting)</strong></li><li><strong>任务之间的消息交换 (Message exchange between tasks)</strong></li><li><strong>任务同步 (Task synchronization)</strong></li><li><strong>中断处理 (Interrupt handling)</strong></li><li><strong>定时器 (Timers)</strong></li><li><strong>内存分配 (Memory allocation)</strong></li></ul><p>下面对OSAL 中的一些基本概念进行阐述。</p><p>首先给出任务 (Tasks)、事件 (Events) 与 消息 (Messages)之间的关系：</p><pre class="mermaid">graph LR  A(用于触发任务运行)  B(完整的代码块或一个线程)  A --> B  C(用于触发任务运行)  D(完整的代码块或一个线程)  C --> D  E(用于任务之间的信息交流)  E --- B  E --- D</pre><p>接下来，我们对这三个基本概念进行阐述。</p><p>任务具有如下的性质 (property)：</p><ul><li>任务是由初始化段 (initialization section)和运行段 (run-time section)组成的</li><li>一旦任务开始执行，任务将会<strong>运行到结束 (run to completion)</strong></li><li>事件使任务执行运行段代码</li></ul><p>事件是整个架构中的最底层的实现。</p><p>消息定义为<strong>内部任务的通信 (Inter-Task Communication)</strong>：</p><pre class="mermaid">graph LRA[任务1] --> B["消息：我已经完成了"]B --> C[任务2]style B fill:#f96</pre><ul><li>消息是由OSAL 管理的</li><li>用于触发任务之间的通信以及内部命令传递</li></ul><p>任务之间的调度遵循两个原则：</p><ul><li>任务将会运行到结束 (run to completion)</li><li><strong>任务服务的无限循环 (Round-robin task servicing loop)</strong></li></ul><p>标准C语言中 <code>malloc()</code> 和 <code>free()</code> 内存操作并不知晓具体的硬件细节，因此OSAL提供了具有相同功能但是扩展了的函数以方便开发者管理堆上的动态内存。</p><ul><li><code>osal_mem_alloc()</code>：动态分配一个缓存区，返回指向该缓存区的指针。</li><li><code>osal_mem_free()</code>：释放动态分配的缓存区。</li></ul><p>定时器 (Timer) 使得开发者能够轻易地对**内部任务 (Internal tasks)<strong>和</strong>外部任务 (External or application level)**进行时间上的操作，从而解决了在第一部分讲述的缺点：<strong>无法对时间进行控制</strong>。</p><p>时钟 (Clock) 提供了追踪设备日期和时间的功能，从而在一定程度上使得开发者能够对时间进行一个更好的管理。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>通过上述对OSAL 的一些基本功能介绍，我们大致地了解了OSAL 的一个基本架构，可以看出OSAL 的提出解决了我们在第一部分提出的相应的问题：对时间、任务管理以及软件与硬件分离问题。</p><p>下面我们将通过对Z-Stack 中具体代码的分析，加深对OSAL 的理解。</p><h2 id="消息-Messages"><a href="#消息-Messages" class="headerlink" title="消息 (Messages)"></a>消息 (Messages)</h2><p>本部分，我们深入探讨<strong>消息 (Messages)</strong>。我们将研究OSAL 中与消息部分相对应的源代码，通过对源代码的研究一步一步揭示消息在OSAL中的重要作用及其实现机制。</p><h3 id="消息数据结构的实现"><a href="#消息数据结构的实现" class="headerlink" title="消息数据结构的实现"></a>消息数据结构的实现</h3><p>一个消息的基本数据结构定义在文件 <code>OSAL.h</code> 中，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sturct &#123;</span><br><span class="line">    <span class="type">void</span> *next;    <span class="comment">// 用于链表的基本实现</span></span><br><span class="line">    uint16 len;    <span class="comment">// 元数据 (meta data)：消息的长度</span></span><br><span class="line">    uint8 dest_id; <span class="comment">// 元数据 (meta data)：消息的目的地</span></span><br><span class="line">&#125; <span class="type">osal_msg_hdr_t</span>;</span><br></pre></td></tr></table></figure><p>其中 <code>uint16</code> 和 <code>uint8</code>的定义在 <code>hal_types.h</code> 文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>   uint8;  <span class="comment">// 1个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  uint16; <span class="comment">// 2个字节</span></span><br></pre></td></tr></table></figure><p>若读者接触过数据结构，可以发现这是一个链表中的结点。</p><p>消息的数据结构只保存了一些<strong>元数据 (meta data)</strong>：消息的长度 <code>len</code> 以及目的地 <code>dest_id</code> 并没有保存消息的内容。在消息这一部分内容中，我们并不会深入消息的内容是怎么产生的，我们的关注点在于消息数据结构及算法的实现。</p><p>下面，我们开始分析与消息相关的算法操作。</p><h3 id="消息的创建"><a href="#消息的创建" class="headerlink" title="消息的创建"></a>消息的创建</h3><p>消息的创建是通过 <code>osal_msg_allocate()</code> 实现的，定义在 <code>OSAL.c</code> 文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint8 * <span class="title function_">osal_msg_allocate</span><span class="params">(uint16 len)</span> &#123;</span><br><span class="line">    <span class="type">osal_msg_hdr_t</span> *hdr; <span class="comment">// 定义了一个结构体指针。</span></span><br><span class="line">    <span class="keyword">if</span>( len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ( <span class="literal">NULL</span> ); <span class="comment">// 若长度为0，则返回空指针。</span></span><br><span class="line">    <span class="comment">// 利用osal_mem_alloc() 动态分配内存。</span></span><br><span class="line">    hdr = (<span class="type">osal_msg_hdr_t</span> *)osal_mem_alloc((<span class="type">short</span>)(len + <span class="keyword">sizeof</span>( <span class="type">osal_msg_hdr_t</span> )));</span><br><span class="line">    <span class="keyword">if</span> (hdr) &#123; <span class="comment">// 如果动态分配内存成功</span></span><br><span class="line">        hdr -&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        hdr -&gt;len = len;</span><br><span class="line">        hdr -&gt;dest_id = TASK_NO_TASK;</span><br><span class="line">        <span class="keyword">return</span> ((uint8 *) (hdr + <span class="number">1</span>));</span><br><span class="line">    &#125;<span class="comment">// 进行相应的赋值操作并返回指针。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果动态分配内存失败</span></span><br><span class="line">        <span class="keyword">return</span> ( <span class="literal">NULL</span> ); <span class="comment">// 返回空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可知，消息的创建过程与传统的链表结点的创建过程是比较类似的，但是有一些特别的地方如下：</p><ul><li>定义一个 <code>osal_msg_hdr_t</code> 结构体指针，为其动态分配内存。分配的动态内存大小为 <code>len+sizeof(osal_msg_hdr_t)</code>。</li><li>返回的指针为 <code>(uint8 *) (hdr +1)</code>。</li></ul><p>可见，消息包含了两个部分：</p><ul><li><strong>元数据</strong>：<code>sizeof(osal_msg_hdr_t)</code> 部分</li><li><strong>内容</strong>：<code>len</code> 部分</li></ul><p>上述的表述可以用下图表示：</p><p><img src="https://s2.loli.net/2022/11/08/YwW8qlZML6pXhra.png" alt="消息示意图"></p><p>我们可以看出，消息的创建对消息的元数据部分进行了处理，并提供了一个缓存区用于保存消息的内容，在与消息相关的API中并不会进行对消息实际内容的处理，<strong>因此调用创建消息的API会返回一个指向缓存区的指针，用于保存消息的内容</strong>。在此，我们得出了一个重要结论：从数据结构的角度来看，<strong>消息是一个指针，指向的是缓存区，也就是消息的内容，在其前有一个元数据区，队列是通过元数据区的指针相连接的</strong>。</p><h3 id="消息的释放"><a href="#消息的释放" class="headerlink" title="消息的释放"></a>消息的释放</h3><p>由于消息是通过动态内存分配的方式，故必须有对应的函数用于释放内存，消息的释放是通过 <code>osal_msg_deallocate()</code> 函数实现的，定义在<code>OSAL.c</code> 文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint8 <span class="title function_">osal_msg_deallocate</span><span class="params">(uint8 *msg_ptr)</span> &#123;</span><br><span class="line">    uint8 *x;</span><br><span class="line">    <span class="keyword">if</span>(msg_prt == <span class="literal">NULL</span>) <span class="comment">// 如果消息指向空指针</span></span><br><span class="line">        <span class="keyword">return</span> (INVALID_MSG_POINTER); <span class="comment">//指针不合法</span></span><br><span class="line">    <span class="keyword">if</span>(OSAL_MSG_ID( msg_ptr )!= TASK_NO_TASK) &#123;</span><br><span class="line">         <span class="keyword">return</span> (MSG_BUFFER_NOT_AVAIL ); <span class="comment">// 不能释放进入队列的消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只释放内容区，也就是buffer区。</span></span><br><span class="line">    x = (uint8 *)((uint8 *)msg_ptr - <span class="keyword">sizeof</span>( <span class="type">osal_msg_hdr_t</span> ));</span><br><span class="line">    osal_mem_free( (<span class="type">void</span> *)x );</span><br><span class="line">    <span class="keyword">return</span> ( SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们可以得到如下的结论：</p><ul><li><strong>不能释放已经进入队列的消息</strong>，因为进入了队列的消息是要进行处理的。（原因将会在后面描述）</li><li>释放的内存仅仅释放消息的内容，不会释放消息的元数据。</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>通过上述的分析，我们已经介绍了消息的数据结构、消息的创建及释放。下面，我们介绍消息队列的实现。在数据结构中，队列的实现需要两个特殊的指针，<strong>队首指针 (front pointer)<strong>和</strong>队尾指针 (rear pointer)</strong>。在OSAL中，只采用了<strong>队首指针</strong>。</p><p>队首指针定义在 <code>OSAL.c</code> 中，是一个全局变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">osal_msg_q_t</span> osal_qHead;</span><br></pre></td></tr></table></figure><p>在初始化的过程中，会被设置为 <code>NULL</code>。</p><h4 id="与消息队列操作有关的宏变量"><a href="#与消息队列操作有关的宏变量" class="headerlink" title="与消息队列操作有关的宏变量"></a>与消息队列操作有关的宏变量</h4><p>在 <code>OSAL.h</code> 中定义了一些与消息队列操作有关的宏变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向下一个消息结点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSAL_MSG_NEXT(msg_ptr)    ((osal_msg_hdr_t *) (msg_ptr) - 1)-&gt;next</span></span><br><span class="line"><span class="comment">// 得出消息的元数据：长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSAL_MSG_LEN(msg_ptr)     ((osal_msg_hdr_t *) (msg_ptr) - 1)-&gt;len</span></span><br><span class="line"><span class="comment">// 得出消息的元数据：目的地</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSAL_MSG_ID(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)-&gt;dest_id</span></span><br><span class="line"><span class="comment">// 取得消息队列的队首指针的值，即位于队首的消息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSAL_MSG_Q_HEAD(q_ptr)    (*(q_ptr))</span></span><br><span class="line"><span class="comment">// 将队首指针进行初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSAL_MSG_Q_INIT(q_ptr)     *(q_ptr) = NULL</span></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OSAL_MSG_Q_EMPTY(q_ptr)   (*(q_ptr) == NULL)</span></span><br></pre></td></tr></table></figure><p>我们可以看出OSAL 对开发者屏蔽了一些细节，所有对于消息结点的操作，均会对指针进行减1操作。所以实际上OSAL消息队列操作的是元数据区，对于开发者而言，开发者总是在控制消息的内容。上述的观点可用下图表示：</p><p><img src="https://s2.loli.net/2022/11/08/ysi3Sgr1cOQe8uE.png" alt="消息队列数据结构的实现"></p><h4 id="进队的实现"><a href="#进队的实现" class="headerlink" title="进队的实现"></a>进队的实现</h4><p>进队的操作是由函数 <code>osal_msg_enqueue()</code> 实现的，定义在 <code>OSAL.c</code> 文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">osal_msg_enqueue</span><span class="params">(<span class="type">osal_msg_q_t</span> *q_ptr, <span class="type">void</span> *msg_ptr)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *<span class="built_in">list</span>;</span><br><span class="line">    halIntState_t intState;</span><br><span class="line">    HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">// 进入临界区，关中断，实现同步与互斥。</span></span><br><span class="line">    OSAL_MSG_NEXT( msg_ptr ) = <span class="literal">NULL</span>; <span class="comment">// 消息的元数据指向NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (*q_ptr == <span class="literal">NULL</span>) &#123; <span class="comment">// 当队列空的时候，直接入队，并将对首指针指向消息</span></span><br><span class="line">        *q_ptr = msg_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历，找到队尾指针。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span> = *q_ptr; OSAL_MSG_NEXT( <span class="built_in">list</span> ) != <span class="literal">NULL</span>; <span class="built_in">list</span> = OSAL_MSG_NEXT( <span class="built_in">list</span> ));</span><br><span class="line">        <span class="comment">// 将消息插入队尾。</span></span><br><span class="line">        OSAL_MSG_NEXT( <span class="built_in">list</span> ) = msg_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启中断，退出临界区。</span></span><br><span class="line">    HAL_EXIT_CRITICAL_SECTION(intState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述代码可知，进队的实现是比较基本的算法实现，此处我们并不深入讲述 <code>HAL_ENTER_CRITICAL_SECTION(intState)</code>以及 <code>HAL_EXIT_CRITICAL_SETCION(intState)</code>，我们将在后面专门阐述OSAL 同步与互斥的实现。</p><h4 id="出队的实现"><a href="#出队的实现" class="headerlink" title="出队的实现"></a>出队的实现</h4><p>出队的操作是由函数 <code>osal_msg_dequeue()</code> 函数实现的，定义在 <code>OSAL.c</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">osal_msg_dequeue</span><span class="params">(<span class="type">osal_msg_q_t</span> *q_ptr)</span> &#123;</span><br><span class="line">  <span class="type">void</span> *msg_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  halIntState_t intState;</span><br><span class="line">    HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">// 进入临界区，关中断。</span></span><br><span class="line">    <span class="keyword">if</span> ( *q_ptr != <span class="literal">NULL</span> ) &#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        msg_ptr = *q_ptr; <span class="comment">// 指向队首结点。</span></span><br><span class="line">        *q_ptr = OSAL_MSG_NEXT( msg_ptr ); <span class="comment">// 队首指针指向其下一个结点。</span></span><br><span class="line">        OSAL_MSG_NEXT( msg_ptr ) = <span class="literal">NULL</span>; <span class="comment">// 删除其指向的结点。</span></span><br><span class="line">        OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK; <span class="comment">// 置其不在队列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    HAL_EXIT_CRITICAL_SECTION(intState); <span class="comment">//退出临界区，开中断。</span></span><br><span class="line">    <span class="keyword">return</span> msg_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息的传递"><a href="#消息的传递" class="headerlink" title="消息的传递"></a>消息的传递</h3><p>我们已经讲述了消息队列的数据结构实现和其对应的某些操作，下面我们介绍消息的传递的实现，在这里我们并不会给出具体的代码实现，更不会结合事件和任务进行分析，我们只给出这两个重要的API，并在后面专门阐述这两个API的代码实现。</p><ul><li>消息的发送：<code>osal_msg_send()</code></li><li>消息的接收：<code>osal_msg_receive()</code></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>在这一节中，我们介绍了消息的数据结构，以及消息的数据结构的实现。我们在这一节并没有深入讨论消息的传递，原因是读者对于任务和事件的概念并没有一个深刻的理解，在讲述了任务和事件的概念后，我们会深入消息的传递。</p><h2 id="任务-Tasks-与事件-Events"><a href="#任务-Tasks-与事件-Events" class="headerlink" title="任务 (Tasks) 与事件 (Events)"></a>任务 (Tasks) 与事件 (Events)</h2><p>这一节中，我们深入OSAL 中的<strong>任务 (Tasks) 和事件 (Events)</strong>。在讲述任务之前，我们先介绍循环机制的实现。</p><h3 id="循环机制的实现"><a href="#循环机制的实现" class="headerlink" title="循环机制的实现"></a>循环机制的实现</h3><p>在 <code>Zmain.c</code> 文件中，<code>main()</code> 函数出现了一个OSAL提供的API：<code>osal_start_system()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      其他初始化操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    osal_start_system(); <span class="comment">// 永不返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TI 公司给出的官方文档解释如下：</p><blockquote><p>This function is the main loop function of the task system, repeatedly calling osal_run_system(), from an infinite loop. This function never returns.</p></blockquote><p>从官方文档可以看出，OSAL 是一个**死循环 (Forever loop)**机制，下面对相关代码进行研究：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">osal_start_system</span><span class="params">( <span class="type">void</span> )</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ;) <span class="comment">// 死循环&#123;</span></span><br><span class="line">        unit8 idx = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 其他操作</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( tasksEvents[idx]) <span class="keyword">break</span>; <span class="comment">// 如果某个任务有事件发生</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(++idx &lt; tasksCnt);</span><br><span class="line">      <span class="keyword">if</span> (idx &lt; tasksCnt) &#123;</span><br><span class="line">          uint16 events; <span class="comment">// 定义一个事件作为临时变量</span></span><br><span class="line">          HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">// 进入临界区，关中断</span></span><br><span class="line">          events = tasksEvents[idx]; <span class="comment">// 读事件</span></span><br><span class="line">          tasksEvents[idx] = <span class="number">0</span>; <span class="comment">// 置为0</span></span><br><span class="line">          HAL_EXIT_CRITICAL_SECTION(intState); <span class="comment">// 退出临界区，开中断</span></span><br><span class="line">          events = (tasksArr[idx])( idx, events ); <span class="comment">// 执行事件处理函数</span></span><br><span class="line">          HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">// 进入临界区，关中断</span></span><br><span class="line">          tasksEvents[idx] |= events; <span class="comment">// 加入没有处理的事件</span></span><br><span class="line">          HAL_EXIT_CRITICAL_SECTION(intState);<span class="comment">// 退出临界区，开中断</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述的代码可以看出，当程序一旦进入了  <code>osal_start_system()</code>, 将会产生以下的操作过程：</p><ul><li>idx 从 <code>0~tasksCnt</code> 进行扫描，发现 <code>tasksEvents[idx]</code> 的值不为0，停止扫描</li><li>然后读取 <code>tasksEvents[idx]</code> 的值，并执行 <code>events = (tasksArr[idx])( idx, events )</code></li><li>最后再执行一步操作：<code>tasksEvents[idx] |= events</code></li></ul><h4 id="tasksEvents"><a href="#tasksEvents" class="headerlink" title="tasksEvents[]"></a>tasksEvents[]</h4><p><code>tasksEvents</code> 定义在文件 <code>OSAL_GenericApp.c</code> 中，是一个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint16 *tasksEvents; <span class="comment">// 定义了一个指向2个字节的指针</span></span><br></pre></td></tr></table></figure><p>其初始化定义在该文件中的 <code>osalInitTasks</code> 函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasksEvents = (uint16 *)osal_mem_alloc( <span class="keyword">sizeof</span>( uint16 ) * tasksCnt); <span class="comment">// 动态分配内存</span></span><br></pre></td></tr></table></figure><p>从这里，我们可以看出 <code>tasksEvents</code> 是一个动态分配的数组，在 <code>osal_start_system()</code> 中对其索引值不断进行扫描，若发现对应的值不为零，停止扫描，然后去做相应的处理。在上述的函数中，出现了 <code>tasksCnt</code> 这个变量，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> uint8 tasksCnt = <span class="keyword">sizeof</span>( tasksArr ) / <span class="keyword">sizeof</span>( tasksArr[<span class="number">0</span>] );</span><br></pre></td></tr></table></figure><p>从这个代码可以看出，<code>tasksEvents[]</code> 的长度是由 <code>tasksArr</code> 这个变量决定的，下面我们研究 <code>tasksArr</code>。</p><h4 id="tasksArr"><a href="#tasksArr" class="headerlink" title="tasksArr[]"></a>tasksArr[]</h4><p><code>tasksArr</code> 定义在文件 <code>OSAL_GenericApp.c</code> 中，是一个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> pTaskEventHandlerFn tasksArr[] = &#123;</span><br><span class="line">  macEventLoop,</span><br><span class="line">  nwk_event_loop,</span><br><span class="line">  Hal_ProcessEvent,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined( MT_TASK )</span></span><br><span class="line">  MT_ProcessEvent,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  APS_event_loop,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ( ZIGBEE_FRAGMENTATION )</span></span><br><span class="line">  APSF_ProcessEvent,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ZDApp_event_loop,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span></span><br><span class="line">  ZDNwkMgr_event_loop,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  GenericApp_ProcessEvent</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>pTaskEventHandlerFn</code> 定义在 <code>OSAL_Tasks.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="title function_">short</span><span class="params">(*pTaskEventHandlerFn)</span></span><br><span class="line">    <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> task_id, <span class="type">unsigned</span> <span class="type">short</span> event )</span>;</span><br></pre></td></tr></table></figure><p>可见 <code>taksArr</code> 保存的数据类型为<strong>函数指针，即指向函数的指针</strong>。我们可以看出，当确定了 <code>idx</code> 的值以后，读取 <code>tasksArr[idx]</code> 的值，然后执行相应的函数。</p><h3 id="任务的概念"><a href="#任务的概念" class="headerlink" title="任务的概念"></a>任务的概念</h3><p>任务到底是什么？在OSAL中，任务是一个抽象的概念，是OSAL 最顶层的抽象。我们通过代码对任务的概念一步步进行探究：</p><p>任务是由**初始化段 (initialization section)<strong>和</strong>运行段 (run-time section)**组成的。所以任务在运行之前必然先进行初始化，初始化的工作是在 <code>OSAL_GenericApp.c</code> 中定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">osalInitTasks</span><span class="params">( <span class="type">void</span> )</span> &#123;</span><br><span class="line">    uint8 taskID = <span class="number">0</span>;</span><br><span class="line">    tasksEvents = (uint16 *)osal_mem_alloc( <span class="keyword">sizeof</span>( uint16 ) * tasksCnt);</span><br><span class="line">    osal_memset( tasksEvents, <span class="number">0</span>, (<span class="keyword">sizeof</span>( uint16 ) * tasksCnt));</span><br><span class="line">    macTaskInit( taskID++ );</span><br><span class="line">    nwk_init( taskID++ );</span><br><span class="line">    Hal_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined( MT_TASK )</span></span><br><span class="line">    MT_TaskInit( taskID++ );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    APS_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ( ZIGBEE_FRAGMENTATION )</span></span><br><span class="line">    APSF_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ZDApp_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ( ZIGBEE_FREQ_AGILITY ) || defined ( ZIGBEE_PANID_CONFLICT )</span></span><br><span class="line">    ZDNwkMgr_Init( taskID++ );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    GenericApp_Init( taskID );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从任务的初始化代码中，我们可以看到，每一个任务有一个与其对应的初始化函数，传入了一个 <code>taskID</code>。由此可知，OSAL 可以拥有很多个不同的任务，任务通过 <code>taskID</code> 进行标识，这一部分是与 <code>idx</code> 索引值相对应的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tasksEvents[idx]) <span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(++idx &lt; tasksCnt);</span><br></pre></td></tr></table></figure><p>所以，这一段代码的意义我们就可以进行解释：遍历不同任务的 <code>taskEvents</code> 的值，如果 <code>taskEvents</code> 的值不为零则停止遍历。在前面，我们已经讲述了 <code>tasksEvents</code> 的数据类型，但是并没有讲述其意义。下面我们引入事件的概念。</p><h3 id="事件的概念"><a href="#事件的概念" class="headerlink" title="事件的概念"></a>事件的概念</h3><p>事件的概念：<strong>一个需要通过任务来完成的动作</strong>。通俗地说，事件<strong>驱动着任务</strong>。一个事件必须具有标识的功能，OSAL 定义了<code>event_flag</code> 是由2个字节也就是16位组成的，每一位代表了一个事件，1代表有事件产生，0代表没有事件产生，如图2 所示：</p><p><img src="https://s2.loli.net/2022/11/08/mTubU3aPdewWNVQ.png" alt="事件的 event_flag"></p><p>事件从代码的角度上，实现尤其简单。下面，我们再次分析  <code>tasksEvents[]</code> 和 <code>tasksArr[]</code>，更深入理解任务和事件。</p><h3 id="任务与事件的关系"><a href="#任务与事件的关系" class="headerlink" title="任务与事件的关系"></a>任务与事件的关系</h3><p>我们先分析 <code>taskEvents[idx]</code>，其中 <code>idx</code> 对应的是任务号，而 <code>tasksEvents[idx]</code> 的值是多少呢？在4.1 节部分我们给出了如下所示的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasksEvents = (uint16 *)osal_mem_alloc( <span class="keyword">sizeof</span>( uint16 ) * tasksCnt); <span class="comment">// 动态分配内存</span></span><br></pre></td></tr></table></figure><p>显然，通过代码可知 <code>taskEvents[idx]</code> 可知其保存的大小为2个字节，正好与事件的 <code>event_flag</code> 相对应。这样我们可以给 <code>tasksEvents[]</code> 数组下定义：<strong>任务事件数组</strong>，用于保存某个任务的事件信息。</p><p>我们再分析 <code>tasksArr[]</code> 数组，我们通过上述的分析，<code>tasksArr[]</code> 数组保存的内容是函数指针，其类型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="title function_">short</span><span class="params">(*pTaskEventHandlerFn)</span></span><br><span class="line">    <span class="params">( <span class="type">unsigned</span> <span class="type">char</span> task_id, <span class="type">unsigned</span> <span class="type">short</span> event )</span>;</span><br></pre></td></tr></table></figure><p>因此，我们可以给  <code>tasksArr[]</code> 数组下定义：<strong>任务处理数组</strong>，当发现任务事件数组不为空的时候，证明有事件产生，于是转向任务处理数组，调用函数，并传递两个参数：</p><ul><li><code>tasks_id</code>：任务标识号</li><li><code>event</code>: 事件的 <code>event_flag</code></li></ul><p>总结如下图所示：</p><p><img src="https://s2.loli.net/2022/11/08/ANiM2c1rCEXqVsY.png" alt="OSAL事件驱动机制"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UINT16 <span class="title function_">GenericApp_ProcessEvent</span><span class="params">( byte x, UINT16 events )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( events &amp; SYS_EVENT_MSG ) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; GENERICAPP_SEND_MSG_EVT ) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，在这个函数中，通过传入的 <code>events</code> 事件分别与已经定义好的宏变量进行<strong>按位与</strong>就可以判断是哪个事件，从而处理该事件。在这里，我们只给出了宏观的一个实现，并没有讲述代码的具体实现。但是通过上述的分析，我们已经明确了<strong>事件驱动任务</strong>。但是，我们仍然有一个十分重要的问题没有处理：</p><ul><li>为何事件的值即  <code>tasksEvents[idx]</code> 会发生改变？也就是说事件是如何被捕获的。</li></ul><h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>这一部分，我们将综合任务、事件和消息，进行一个完整过程的阐述。</p><h3 id="消息的发送与接收"><a href="#消息的发送与接收" class="headerlink" title="消息的发送与接收"></a>消息的发送与接收</h3><p>消息的发送是通过定义 <code>OSAL.c</code> 文件中的 <code>osal_msg_send()</code> 函数定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint8 <span class="title function_">osal_msg_send</span><span class="params">( uint8 destination_task, uint8 *msg_ptr )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg_ptr == <span class="literal">NULL</span>) <span class="comment">// 指针为空返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> (INVALID_MSG_POINTER);</span><br><span class="line">     <span class="comment">// 如果要发送的任务号大于系统定义的最大任务号</span></span><br><span class="line">    <span class="keyword">if</span> (destination_task &gt;= tasksCnt) &#123;</span><br><span class="line">        osal_msg_deallocate( msg_ptr );</span><br><span class="line">        <span class="keyword">return</span> ( INVALID_TASK );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查元数据，是否为错误的消息</span></span><br><span class="line">    <span class="keyword">if</span> ( OSAL_MSG_NEXT( msg_ptr ) != <span class="literal">NULL</span> ||</span><br><span class="line">       OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK ) &#123;</span><br><span class="line">        osal_msg_deallocate( msg_ptr );</span><br><span class="line">        <span class="keyword">return</span> ( INVALID_MSG_POINTER );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置其元数据的目的地址</span></span><br><span class="line">    OSAL_MSG_ID( msg_ptr ) = destination_task;</span><br><span class="line">    <span class="comment">// 将该消息进队</span></span><br><span class="line">    osal_msg_enqueue( &amp;osal_qHead, msg_ptr );</span><br><span class="line">    <span class="comment">// 告知任务有消息需要处理</span></span><br><span class="line">    osal_set_event( destination_task, SYS_EVENT_MSG );</span><br><span class="line">    <span class="keyword">return</span> (SUCCESS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一过程可用下图表示：</p><pre class="mermaid">graph LR  A("做一系列的检查") --> B(设置消息元数据目的地址)  B --> C(将消息进队)  C --> D(告知任务有消息需要处理)  style D fill:#f96</pre><p>注意函数 <code>osal_set_event()</code> 的使用，这是一个十分关键的函数，我们首先分析其源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint8 <span class="title function_">osal_set_event</span><span class="params">( uint8 task_id, uint16 event_flag )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task_id &lt; tasksCnt) &#123;</span><br><span class="line">        halIntState_t   intState;</span><br><span class="line">        HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">// 关中断</span></span><br><span class="line">        tasksEvents[task_id] |= event_flag;</span><br><span class="line">        HAL_EXIT_CRITICAL_SECTION(intState);<span class="comment">// 开中断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (INVALID_TASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有两个参数，一个是 <code>task_id</code>，另一个是 <code>event_flag</code>，执行了一个特别重要的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasksEvents[task_id] |= event_flag; <span class="comment">// 按位或并赋值</span></span><br></pre></td></tr></table></figure><p>这样就通过了这个函数，改变了 <code>tasksEvents[idx]</code> 的值，从而在下一次扫描的时候，处理该事件。<strong>按位或</strong>的目的在于不能够影响其他已经存在的未经处理的事件。</p><p>其次，在消息发送的函数中第二个参数的值为 <code>SYS_EVENT_MSG</code>。其值为 <code>0x8000</code>。从这一点，我们必须认识到<strong>消息</strong>是<strong>系统层次的事件</strong>，也就是说，<strong>消息是只能够存在在系统事件中的，这是消息发送这个函数所规定的。</strong></p><p>消息的接收是通过定义 <code>OSAL.c</code> 文件中的 <code>osal_msg_receive()</code> 函数定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">uint8 *<span class="title function_">osal_msg_receive</span><span class="params">( uint8 task_id )</span> &#123;</span><br><span class="line">    <span class="type">osal_msg_hdr_t</span> *listHdr; <span class="comment">// 定义一个消息结构体指针</span></span><br><span class="line">    <span class="type">osal_msg_hdr_t</span> *prevHdr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">osal_msg_hdr_t</span> *foundHdr = <span class="literal">NULL</span>;</span><br><span class="line">    halIntState_t   intState;</span><br><span class="line">    HAL_ENTER_CRITICAL_SECTION(intState); <span class="comment">// 进入临界区，关中断。</span></span><br><span class="line">    listHdr = osal_qHead; <span class="comment">// 指向队首指针</span></span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="keyword">while</span> ( listHdr != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="comment">// 如果某个消息的目的地是 task_id</span></span><br><span class="line">        <span class="keyword">if</span> ((listHdr - <span class="number">1</span>)-&gt;dest_id == task_id) &#123;</span><br><span class="line">            <span class="comment">// 第一次找到</span></span><br><span class="line">            <span class="keyword">if</span> ( foundHdr == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">                 foundHdr = listHdr;</span><br><span class="line">             &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (foundHdr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存找到的消息之前的消息</span></span><br><span class="line">            <span class="comment">// 方便进行删除操作</span></span><br><span class="line">            prevHdr = listHdr;</span><br><span class="line">        &#125;</span><br><span class="line">        listHdr = OSAL_MSG_NEXT( listHdr ); <span class="comment">// 遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不为空，证明为遍历完，也就是存在多个消息</span></span><br><span class="line">    <span class="keyword">if</span> ( listHdr != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="comment">// 告知任务还有消息在等待处理</span></span><br><span class="line">        osal_set_event( task_id, SYS_EVENT_MSG );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        osal_clear_event( task_id, SYS_EVENT_MSG );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了消息</span></span><br><span class="line">    <span class="keyword">if</span> (foundHdr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 提取出这个消息</span></span><br><span class="line">        osal_msg_extract( &amp;osal_qHead, foundHdr, prevHdr );</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_EXIT_CRITICAL_SECTION(intState);<span class="comment">// 退出临界区，开中断。</span></span><br><span class="line">    <span class="keyword">return</span> ( (uint8*) foundHdr ); <span class="comment">// 返回消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息的接收过程可以用下图表示：</p><pre class="mermaid">graph TB  A[listHdr != NULL] -->|Yes| B  B[判断有无存在要发送给该任务的消息] -->|yes| C[是否第一次找到]  C -->|yes| D["foundHdr = listHdr"]  B -->|No| E[" prevHdr = listHdr"]  E --> F["listHdr = OSAL_MSG_NEXT( listHdr )"]  F --> A  D --> F  A -->|No| G[listHdr != NULL]  C -->|No| G  G -->|Yes| H["osal_set_event( task_id, SYS_EVENT_MSG )"]  G -->|No| I["清除消息"]  H --> 提取消息</pre><p>通过上述的过程，我们已经可以总结出事件是如何捕获的了，事件的捕获是通过函数 <code>osal_set_event()</code> 实现的。</p><h3 id="任务处理函数"><a href="#任务处理函数" class="headerlink" title="任务处理函数"></a>任务处理函数</h3><p>在第4节中，我们仅仅简单地讲述了任务处理函数，下面我们通过一个具体的例子进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">UINT16 <span class="title function_">GenericApp_ProcessEvent</span><span class="params">( byte x, UINT16 events )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( events &amp; SYS_EVENT_MSG ) &#123;</span><br><span class="line">        MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );</span><br><span class="line">        <span class="keyword">while</span> (MSGpkt) &#123;</span><br><span class="line">            <span class="keyword">switch</span>(MSGpkt) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ZDO_CB_MSG:</span><br><span class="line">                      GenericApp_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> ZDO_CB_MSG:</span><br><span class="line">                      GenericApp_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            osal_msg_deallocate( (uint8 *)MSGpkt ); <span class="comment">// 释放消息</span></span><br><span class="line">            <span class="comment">// 处理该事件的下一个消息</span></span><br><span class="line">            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (events ^ SYS_EVENT_MSG) <span class="comment">// 返回未处理的事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从上面的代码可以看出，首先进入了任务处理函数，会去优先处理系统事件，再次强调，<strong>消息只能在系统时间中处理，这是OSAL 规定好了的</strong>。首先利用 <code>osal_msg_receive()</code> 函数从消息队列中获得有关该层任务的消息，然后根据发送的消息提供的信息，作出相应的操作，然后释放该消息并去处理下一个消息。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>至此，我们已经基本讲清了事件驱动机制的一个实现过程，希望对读者了解这个机制有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Narcissu 1 &amp; 2</title>
      <link href="/2021/02/23/Narcissu-1-2/"/>
      <url>/2021/02/23/Narcissu-1-2/</url>
      
        <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>I was at a total loss for words.</p></blockquote><blockquote><p>Underneath the curtain of twilight, I started up the silver coupe again.</p></blockquote><blockquote><p>It had begun to rain all the sudden.<br>A freezing rain falling from the frigid January sky as if it had forgotten how to stop.<br>The countless raindrops spattering on the windshield and obscuring the view from the inside.<br>And when each grew too large for surface tension to hold it up,<br>a few of them gathered, slid down, became rivers.<br>And these rivers swallowed up raindrops underneath them and ran to the bottom.<br>I stared emptily at the rain from inside.</p></blockquote><blockquote><p>Around the time when the sun slowly arced down and dyed the western horizon orange.</p></blockquote><blockquote><p>Inside the car, shrouded in the dark of night.</p></blockquote><blockquote><p>The car shimmered with sunlight underneath the clear winter sky</p></blockquote><blockquote><p>The flickering white specks dancing in the twilight sky.</p></blockquote><blockquote><p>A chilly wind kicked up, scattering a powder snow across the lake’s frozen surface.</p></blockquote><blockquote><p>Around when the high-flying sun slowly started to drop into shadow.</p></blockquote><blockquote><p>In the small room, her sobs hung in the air.</p></blockquote><blockquote><p>Or perhaps, for people… being aware of death, maybe that’s the first time they are also able to become aware of “life”.</p></blockquote><blockquote><p>Even if I could bear my own pain, because I can’t bear another’s. Because the one leaving behind being sad… meant the ones remaining were pained the most…</p></blockquote><blockquote><p>Would I have, in the same way, sincerely wished for those remaining behind?</p></blockquote><h2 id="作者的评价"><a href="#作者的评价" class="headerlink" title="作者的评价"></a>作者的评价</h2><p>下面节选自作者在知乎对自己作品的评价.</p><blockquote><p>因为是兴趣使然的作品，很难做评价。<br>创作这部作品的目的，也并不是为了让读者感觉它“有趣”。<br>关于作品的主题“生死观”，正确答案到底是什么，身为作者我也回答不上来。<br>“死”是一个人们平时不太会去考虑的现象。<br>但它却是最终每个人都会经历的事。<br>我自己，还有在座正在读这段话的人都不例外。<br>小的时候，“死”只存在于远房亲戚的消息和电视里，<br>但随着长大，它逐渐来到了我的身边。<br>自己也有了死&#x3D;“离别”的体会。<br>在为逝者送行过几次、几十次之后，最终自己也会被别人送行。<br>送行的经历可以有很多次，但被送行的经历，只会有1次。<br>而《水仙（narcissu）》可能就是在向大家提出这样的问题——<br>“到那个时候，你会怎么做？”</p></blockquote><h2 id="作者创造作品的背景"><a href="#作者创造作品的背景" class="headerlink" title="作者创造作品的背景"></a>作者创造作品的背景</h2><p>下文摘自作者的原话</p><blockquote><p>1980<br>3月。和跟往常一样的朋友们在山顶游玩。<br>成员里有一个最近才认识的家伙。他的名字叫做I。<br>是个近乎暴走族、纯粹喜欢飞车的家伙。<br>某一天，熟人S偷来了一辆改装得很像赛车的RZ摩托。<br>比起对飞车没有任何兴趣的我们，I有着根本的不同。<br>第二天，I一再向S请求，把RZ借走了。<br>接着两天后，在我们平时一直游玩的山顶上，I遭遇了事故。死了。<br>葬礼只有我们的领头人N参加了。我们不知道要以什么表情来面对，所以没有前去，没能前去。<br>那一晚，大家来到了I遭遇事故的那个转角。<br>路面留着因后轮锁死造成的轮胎痕，路边的防护栏有所凹陷，方向指示灯的碎片散落了一地。<br>往常一直说着无聊话题的我们，在那一晚也只能默然。<br>即使出事的转角就在我们的眼前，但却没有人带着像花束之类的东西。<br>终于，最初把摩托车偷来的S，把吸了半截的香烟供奉在防护栏前。<br>其他人也同样效仿。<br>我和领头的N并不吸烟，于是放下喝过的宝特瓶作为替代。<br>空气非常寒冷，呼出的气息都成了纯白色的烟。夜空中，猎户座美丽异常。<br>就这样，I从我的故事之中消失了。<br>……国道延伸，沿线的柏青哥店不断地建了起来，校园暴力之类的词语开始流行……<br>1980年，少年时代的事情。<br>5月，跟我有点交情的M拨通了我的电话。<br>据他说是被十分为难的事情困扰着。<br>那时他一星期都没有来学校，说不定我多少有点担心他。<br>M自己也不确定我能否回应他，总之就先试着找我商量一下。<br>「老爸还没有回来。」<br>一开口，M就说了这样的事情。<br>本来M的家里就没有母亲，依靠生活保障金度日。<br>所以M从最初就没有依靠父母。<br>我们经常一起打柏青哥，我也知道他还有做着其它的工作。<br>有人一定会认为我们是特殊的，其实不然。我的朋友中并没有依赖父母的家伙。小屁孩就要像小屁孩的样子开始独立地生活。<br>「……其实妹妹她……」<br>接下来的话便是在说M的妹妹小S美的事情。虽然低一个学年，但我还是挺熟悉她的，是个开朗可爱的孩子。<br>「小S美怎么了？」<br>「这次虽然要退院了……」<br>我之前并不知情，似乎是入院了的样子。<br>「是不是住院费不够了？」<br>M摇了摇头。<br>现在我也没详细了解到当时的情况，不过似乎不用担心医疗费用的事情。<br>据M所言，目前的难题是生活陷入了困境。<br>「嘛，老爸不在的确会感到为难吧……」<br>可是，当我嘟哝着发问时，M只是一味沉默。<br>到了现在我就明白了。一定是从那个时候开始，M便知道的。<br>3天后，退院日。<br>总之先找熟人安排好车辆，到稍远的医院里把小S美载了回来。<br>「K同学，谢谢你。」<br>很久不见，小S美看起来瘦了点。<br>但是，羞涩时的笑脸还是一如既往。<br>这时我想既然已经退了院，小S美就会很快地健康起来。<br>那一晚，M找我商量。总之当前的生活非常困窘。<br>对于从最初就不想找父母要钱的我们来说，M的话语显露出软弱的一面。<br>「不想就这样一直呆在家里。」<br>但是听了这句话之后，我也多少理解了M的想法。<br>说不想呆在家里，我想是因为需要看护妹妹的原因。才刚出院，这能充分地想像得到。<br>然后，一直呆在家里，就意味着M没办法去赚取生活费。<br>从来都是自力更生的M在这个问题上很有说服力。<br>第二天，我把自己的零钱收集起来，准备了7万日元。M十分高兴。<br>6月，小S美再次入院。我也坐上急救车跟了过去。<br>那时，M第一次给我详细说了小S美的病情。<br>其实小S美入住的并不是普通的病房，而是临终关怀医院。似乎是M的老爸还在的时候就这样子了。<br>因为胃癌，小S美的整个胃都被摘除掉，但最终癌细胞还是转移了，已被告知无法医治。<br>所以并不是普通的病房，而是临终关怀医院。<br>病情平稳时可以回家，当症状恶化时还得回到医院。<br>如此重复……并不是为了治病。<br>「不知道还可以再回几次家……」<br>M这样说道。<br>「小S美自己知道这事吗？」<br>这个问题M并没有回答。但后来他添上一句，说本人应该察觉到一点。<br>我去探病，小S美就像电视上见到的那样，正带着吸氧面具。<br>她微微睁开双眼，发现是我，便稍微有点害羞地笑了起来。<br>「……还好吗？」<br>没有新鲜感的问候。但那时的我，除了这些话之外什么都说不出来。<br>第二天。<br>我和M发誓要一起合作。<br>晚上我在工地填土，白天M就在附近的柏青哥店打工。<br>当然大家都对雇主隐瞒了年龄。<br>互相有空的时候，我们就会去医院，是一个尽量不让小S美孤身一人的作战。<br>但即使如此，我还会偶尔去去学校，而M则是完全没上过学。<br>不知道去了哪里的M的老爸，依然全无归家的样子。<br>于是，在空闲的时间里我和M交替地出现在病房。<br>每天每天，面对着白色的墙壁，坐着局促的折椅，和小S美聊着些有的没的。<br>普通的病房虽然有探病时间限制，但临终关怀医院却随时可以。<br>我喜欢的时间，是早晨体温检查结束之后的８点左右。<br>我喜欢6月清爽的阳光，还有像是高兴又像是害羞地、浅笑着的她。<br>两个星期后。<br>小S美……不对，这时开始应该称作S美——<br>第二次从临终关怀医院退院了。<br>入院的时候是乘坐救护车，但退院时却没这样的服务。我们也没有多余的钱坐的士。<br>所以只能再次拜托朋友，借了一辆破烂的小四轮回家。<br>然后我和M小心地把她抱上位于住宅区4楼的家。<br>看起来也很瘦的S美非常轻。令人悲哀。<br>7月。<br>那一年也是酷暑。<br>虽然我们用风扇忍耐一下也足够了，但担心这会影响S美的身体。<br>「嗯……没关系的。」<br>像往常一样笑着回答的S美，在我们看来更加显得悲哀。<br>连空调都没有。还是小屁孩的我们为自身的无力感到悔恨，想能尽早地成为大人。<br>第二天，我用螺丝刀和扳手硬把自己房间的空调卸了下来。因为经常搬家见得多，所以就有样学样了。<br>之后和M两人一起把沉重的的室外机搬上4楼，总算给S美的房间装上了。虽然雪种漏了很多，制冷效果马马虎虎。<br>「哇，真凉快～」<br>然而，S美这样笑着说道。她非常开心。<br>那一晚，我们三个人就在这台不怎么好用的空调前庆祝七夕。<br>我和M拿着冷冻的罐装可乐，而S美则喝着橙汁。虽然没有竹枝，也没有许愿签，却是一个愉快的七夕。<br>8月。<br>第三次入院。这回也叫了急救车，当时我不在场。<br>在候诊室和M长谈了一回。<br>老爸不在，也没有别的亲戚，医生似乎只能把情况传达给M。总之医院方面像是没有使用强力抗癌药。<br>也许是因为肉亲里面并没有成年人，医生也很难判断该如何医治。<br>「大概这是最后一次了。」<br>M自言自语道。<br>他所说的“最后”，一定是指S美已经没有回家的机会了。<br>假如可以回家，那么也不会再次来到这家医院。<br>白色的墙壁，局促的折椅。高大的M佝偻着身体，就坐在那张折椅上。<br>带着往常那类似吸氧面具的东西，S美偶尔也会注意到我，眯起眼睛朝我笑。<br>2天后。<br>灼热的阳光和蝉声。<br>去往医院的道路，沥青上热浪摇曳着。<br>我坐在折椅上和S美说话。<br>「呐，K同学……」<br>S美突然露出寂寞的表情。<br>「我已经不行了。」<br>S美自己也一定很清楚的，这是一句我最不想听到的话。<br>但我不想接话，害怕不知道要怎样作答。<br>其实我想说“才没有这样的事”、“很快就会好起来的”，全力否定S美的想法。但是，我没有如此坚强。<br>最终除了沉默着点头之外，我什么都没能说出来。<br>从窗外泻进来的灼热光线使得纯白的病房更显刺眼。<br>S美漏出小小的哭声。大概，我自己同样想哭。<br>9月。<br>在余暑之中，S美第三次退院。<br>我们都很高兴。本来还在担心会不会就这样再也不给退院了。<br>但恐怕再也无法回到医院了。M这样说道。我也有着同样的预感。<br>依然是从熟人那借了辆小四轮回家，然后两人合力把S美抱上4楼，察觉到S美比上次又轻了一点，再次悲从中来。<br>在这段时间里，偶尔会有学校的老师、志愿者和来帮忙的人上门探病。这让我稍微觉得，好心的大人还是存在着的。<br>一天晚上，吹着不太好用的空调，我们三人定下了一个作战计划。<br>虽然花长时间聊了很多，但我们最终确定，要去S美想去的地方，要做S美想做的事情。<br>只是这样的一个“作战”。的确很像小屁孩的想法。<br>月末的晚上。<br>我再拜托上次的熟人，借来了车子。这回并没有司机，只有单单一辆破车。<br>很顺理成章地，我无证驾驶了。首先，我也没到可以考取驾照的年龄。<br>S美和M乘了进来。我操作着不太习惯的离合，深夜驾车出行。<br>目的地是不远处的N海滩。开车15分钟左右的距离。<br>然后我们就在无人的沙滩放起了焰火。<br>将堆成小山的火箭和喷花烟花当成篝火点着。<br>我们也玩了章鱼形状的滑梯。我和M互相用火箭烟花对射。双手都是火药的臭味，而S美开心地笑着。<br>最后我们三人坐在沙滩上喝起了饮料。我和M是罐装可乐，那天S美也是要了橙汁。<br>海浪的声音，潮湿的风。仰望夜空，夏天的星座在闪闪发光。<br>波浪边缘的白色泡沫，到处留下蜿蜒的痕迹。<br>一句交谈都没有，三人一直眺望着。<br>―星期二　午前2点―<br>那天也一起留在M的家里。<br>M在里面的房间躺着。他最近竭力照顾S美，并没有好好休息过，所以现在该轮到我醒着了。<br>想着S美应该口渴了，所以递了点冰给她。<br>然后，她一直在叫唤着我的名字。微微睁开双眼，用无力的声音叫唤着。<br>「T同学……」<br>再一次叫唤我的名字吧。就一会儿，真的就要那么一会儿……<br>她露出了那张一如往常的羞涩笑脸。<br>于是我用力地握住了S美的手。不知为何，就想紧紧地握着。只觉得绝对不能松开。<br>片刻。当我反应过来时，S美已经没有了呼吸。<br>然后我知道了S美已经死去的事实。<br>她叫唤了我的名字。她的手如此温暖。她喜欢喝橙汁。她最后也对我笑了。<br>就这样，S美消失了，却在我的故事里凿下了一笔。<br>……国道延伸，沿线的柏青哥店不断地建了起来，校园暴力之类的词语开始流行……<br>1980年，少年时代的事情。<br>无聊的、暧昧的、冷静的、无情的现实。<br>不会像电视剧和电影那样充满戏剧感，变化总是不被察觉，单调无趣的每一天。<br>明明没有什么值得期待的行程，却又数着手指盼着周末的每一天。<br>轻视无聊的日常，寻找假想的刺激；探求容身之地，建立自身的价值观，人人只会时常关心自己是否身处安全圈内的世界。<br>……但也是尚不能抛弃的世界。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>面对这一部非商业性质的游戏，我更愿意称之为文学作品。死是一个严肃的事情，我在玩这部作品的时候，彷佛一直在接受着作者的拷问：</p><p>我们总会有一天会面临死亡，那个时候我们应该怎么做？</p><p>这部作品让我有感触的地方特别多，即死之人面对死亡的无能为力，Setsumi对于生活一成不变的绝望，既不想在家里去世，也不想就这样死在医院里。当Setsumi选择入海自杀时，让我特别感触的是</p><p>我是应该让她停下呢，还是应该推她一把呢？</p><p>如果我周围有一个人就如Setsumi一般，我该做些什么呢？</p><p>生者在对于即将面临死亡的人的时候的无能为力，什么话也说不出口的无奈。无论是即将离开的人，还是那被留在世间的人都会感到痛苦吧。</p><p>我也有一天也会面临死亡，我无法预测哪一天，或许就在明天。我还是对生命没有足够的敬畏之心，即死之人渴望着生命，我却在浪费着生命。正如同Setsumi天天在医院里面看着地图，幻想自己能驾驶着车去往各种各样的地方，如同生长在野外的水仙花一样，而不是那仅仅只能在医院窗沿边上绽放的水仙花。</p><p>我为自己感到羞愧。我还是无法用语言切实地表达出我的情感，彷佛想从嘴中挤出什么话语，但总觉得空虚不切实际。</p><p>因为有些东西始终无法用语言表达，也无法用文字表达。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.zhihu.com/question/25218784">作者在知乎对于自己作品的评价</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《后来的事》读书笔记</title>
      <link href="/2021/02/23/%E3%80%8A%E5%90%8E%E6%9D%A5%E7%9A%84%E4%BA%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/23/%E3%80%8A%E5%90%8E%E6%9D%A5%E7%9A%84%E4%BA%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><blockquote><p>代助现在就是这样想的：与其费尽心机去把镀金的东西冒充成真金，还不如在黄铜就是黄铜的情况下，去忍受人们对黄铜应有的蔑视来得自在。</p></blockquote><blockquote><p>国民受着这种西方施加的压迫，便无暇用脑子，无法好好工作。教育上的愚民方针，使国民不暇顾地干活，导致了整体性的神经衰弱。你看看大家的言行，基本上是愚蠢的，除了自己的事以及自己眼前的事之外，脑子里什么也不想。因为劳顿使他们无法思想。精神困惫和身体衰弱，不幸同时降临，而且道德的败坏也接踵而至。</p></blockquote><blockquote><p>“这问题很有意思，非常有意思。像我这种只看到某个局部而与现实苦苦较量的人，是无暇思及这些问题的。不管日本如何贫穷和仰人鼻息，我干活的时候都丢在了脑后了。社会再怎么堕落，我视而不见，干我自己的活儿。在你这样的有闲人士看来，也许会替日本的贫困和像我这样一类人的堕落操心，不过，那也只能在成了对这个社会没有用处的旁观者之后，才会这样说的。换句话说，因为有了闲功夫去照镜子里的尊容，才会出现这种情况，而忙忙碌碌时，不论是谁，大概连自己的音容都忘却了。”<br>平冈在唠叨中，不期然而然地冒出了这么一个比喻，心里觉得自己的观点得到了有力的靠山，便踌躇满志地暂时停了停。代助无可奈何地微笑着。这时，平冈立即补充道：<br>“你不曾尝过没有钱的滋味，当然无法理会。不知生活的窘困，就没有要干活的想法。总而言之，当一个富家阔少爷，当然光会说一些冠冕堂皇的话”<br>“为什么吗？因为为了生活而劳动，就不是为了劳动而劳动。”<br>“我不懂这种伦理学方面的概念，是不是请你要浅近一些的语言来解释一下呢？”<br>“换句话来说就是：为吃饭活命而干的职业，很难有什么诚实可言。”<br>“这同我的想法完全相反哪。我认为，正是吃饭活命这一动力在使人竭力地干活。”<br>“竭力地干活也许并不难，诚实地干活却不容易哪。若说为吃饭活命而干活，那么吃饭活命同干活这二者中，哪一个是目的呢？”<br>“当然是吃饭活命呀。”<br>“按照这一逻辑，吃饭活命是目的，可见干活乃是一种手段，那么势必造成去追求容易吃饱肚子的活儿干。换句话说，干什么活以及怎么干都不在乎了。一句话，只要能获得面包就行。你看是不是这么一回事？既然劳动在内容、方向上以至顺序上无一不受到其他因素的牵制，这种劳动就是堕落的劳动。”<br>“我说的都是正经话，不过一点没有关系，我们不会吵起架来的。可是，像你这样不可一世的人，怎么会来找我这样的人借钱呢？这不是太反常了吗？哟，你会觉得我在吹毛求疵而生气吧？请你别那样。我认为，你再怎么了不起，一旦没有钱，也只得像我这样的人低头。”</p></blockquote><blockquote><p>平冈终于离去了。每次相见，代助无不觉得两人是咫日千里。说实在的，岂止是对平冈如此，他觉得，与谁相见都有同样的感觉。现在这个社会，无非是一个个孤立的人的集合体。大地是自然相连的整体，但是建起房子后，大地便顿时被分成一个一个的。代助的结论是：所谓文明，无非是使人们各自孤立起来的东西。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这部小说不仅仅只讲的爱情。代助是一个充满了理想主义色彩的人，然而他的经济来源是靠着他的父亲和哥哥。这也是他的最大的悲哀。人永远都是社会的人，无论如何都不得不社会关系所左右。代助通过家庭拒绝了社会关系，但是不得不因此承担家庭关系。他认为工作不应该为了面包，而是应该为了更加神圣的东西。</p><p>代助在我看来只是拥有了表面上的自由，他最失败的就是没有意识到所谓的自由必定要承受一定的不自由。如果他是经济独立的，他完全可以不结婚，不必去看父亲和哥哥的脸色行事。命根子都被别人抓住的，何谈自由？</p><p>我们无非都是社会上的螺丝钉，给政客、资本家创作那些映在显示器上的漂亮的数据。大多数的工作就是枯燥无比的、不断重复的，所谓的有创造性的工作终究是少数。然而，无论是拥有什么的理想、心态以及对这个世界的看法，必须做到经济独立，否则永远会受到致命的制约。理想主义和现实主义根本不是对立的，我们永远在现实中追求理想，在理想中反思现实。</p><p>但是，人觉得悲哀。如同头脑被烈火灼烧一样。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动物庄园》读书笔记</title>
      <link href="/2021/02/23/%E3%80%8A%E5%8A%A8%E7%89%A9%E5%BA%84%E5%9B%AD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/23/%E3%80%8A%E5%8A%A8%E7%89%A9%E5%BA%84%E5%9B%AD%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>可我们又为什么总是活得这样窝窝囊囊、可怜巴巴呢？那是因为我们的劳动成果几乎全部被人类从我们身边偷走了。</p></blockquote><blockquote><p>人使唤动物干活，却只给动物少得不能再少的一点回报，仅仅为了不让他们饿死，而其余的部分悉数被人据为己有。</p></blockquote><blockquote><p>这三口猪把老少校的教导阐发成为一套完整的思想体系，他们名之曰动物主义。</p></blockquote><blockquote><p>猪头头们解释道，通过过去三个月的学习，他们已成功地把动物主义的原理精简为《七诫》。这七条戒律现在就要题在墙上；它们将构成一部不可变更的法典，动物农场全体动物往后的生活必须永远以这部法典为准绳。</p></blockquote><blockquote><p>七 诫<br>1.凡用两条腿行走的都是敌人。<br>2.凡用四条腿行走或长翅膀的，都是朋友。<br>3.凡动物都不可穿衣服。<br>4.凡动物都不可睡床铺<br>5.凡动物都不可饮酒。<br>6.凡动物都不可杀任何别的动物。<br>7.凡动物一律平等。</p></blockquote><blockquote><p>雪球曾解释说，绿色的旗帜代表英格兰的田野，白色的蹄子和头角标志着未来的动物共和国，这个共和国将在人类最终被推翻后兴起。</p></blockquote><blockquote><p>“光勇敢是不够的，”吱嘎说。“忠诚和服从更为重要。既然谈到了牛棚战役，我相信总有一天我们会发现雪球在其中所起的作用被夸大得厉害。纪律，同志们，铁的纪律！那才是今天的口号。只要走错一步，我们的敌人又会骑到我们头上来。同志们，你们总不要琼斯回来吧？”</p></blockquote><blockquote><p>动物们对于“策略”这个词儿还不甚了了，但吱嘎说起来却是那么富有说服力，而碰巧也在吱嘎身边的三条狗叫起来又如此显示其威胁力，于是动物们没有再问什么便认可了他的解释。</p></blockquote><blockquote><p>那一年动物们自始至终像奴隶一般在干活。但他们干得舒心；他们舍得出力，不怕牺牲，清楚地意识到自己做的一切无不为了他们自己的福祉，也是为了他们同类及其后代的福祉，而不是为了一帮不劳而获、专事偷盗的人。</p></blockquote><blockquote><p>如果说紫苜蓿在心中为自己设计过什么关于未来的蓝图的话，那幅蓝图上将是一个摆脱了饥饿和鞭子的动物社会，大家一律平等，工作各尽所能，强者卫护弱者，就像在听少校演讲之夜紫苜蓿用她的前腿卫护一窝失恃的小鸭那样。可是，理想的动物社会没有盼到，而他们反倒落入了这样一个时代：谁也不敢说出自己的想法，动辄狂吠不止的恶犬到处横行，你不得不眼睁睁看着你的同志在招认了丑恶罪行后被撕成碎片——她不知道怎么会闹成这样的。</p></blockquote><blockquote><p>所有动物的口粮再次被削减，只有猪和狗的口粮定额不变。吱嘎的解释是，口粮问题上缺乏灵活性的平均主义做法是与动物主义的原则背道而驰的。</p></blockquote><blockquote><p>不知怎么的，虽然农场比过去富了，可是动物们自己似乎并没有什么富裕起来的迹象——当然，猪和狗不在此例。也许，部分原因就在于有那么多的猪和那么多的狗。倒不是说这两种动物不劳动——这是他们的做派。问题在于，就像吱嘎从来不厌其烦地解释的那样，在农场的管理和组织方面有干不完的工作。这些工作中有许多属于其他动物过于无知而理解不了的。例如，吱嘎曾告诉他们，猪不得不每天耗费大量劳动在叫做“档案”、“报告”、“议事录”、“备忘录”的神秘事务上头。那都是大张大张的纸，必须在上面密密麻麻地写上字，一旦这些纸写满了字，就会放到炉子里烧掉。这对农场的福祉都是至关重要的，吱嘎说。但迄今为止，猪也罢，狗也罢，都还没有用他们自己的劳动生产过任何食物；而他们的数量却非常之多，他们的胃口又始终非常之好。</p></blockquote><blockquote><p>凡动物一律平等 但是有些动物比别的动物更加平等</p></blockquote><blockquote><p>这下弄明白了，猪们的脸究竟出了什么问题。敢情动物们从窗外朝里望，目光从猪移到人，再从人移到猪，又重新从猪移到人，要分清哪张脸是猪的，哪张脸是人的，已经不可能了。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>作为人类，我们往往是要去努力追求公平与正义的。所以当我们面临压迫和不公的对待的时候，我们应该竭尽全力去反抗不公。实际上，第一代开辟革命的人总是最真诚的，他们都是抱着伟大的革命精神以及高尚的思想去做为人类幸福谋利的事情。</p><p>但是，人是会变的，当一个人掌握了权力，他的欲望就会无限的膨胀，如果他的权力得不到监督，必然会造成腐败。本书中的七诫本是一个共同的规定，却被当权者一次又一次地修改，当动物们想要反抗的时候，不是被羊所谓的口号麻痹就是害怕当权者身边的暴力机关：狗。<br>最让我感到毛骨悚然的地方在于，为什么猪能够坐上王座，成为那更加平等的动物。原因在于猪是完整地接受了教育的。而其他动物要么就只会几个字母、要么就停留在字母A上了。拳击手是一个勤劳刻苦的动物，然而拳击手并没有知识，他原本打算退休后学习文化知识的，因为他觉得他要为动物庄园做出自己应有的贡献，一个认真踏实的人却沦为了权力的牺牲品。最终被猪送往了屠宰场卖了一笔钱喝酒去了。</p><p>可以说除了猪以外的动物，他们都被洗脑了，他们以为自己获得了自由，拥有了追求幸福生活的权利，但是他们又落入了一个新的不自由，最悲哀的是他们甚至以为自己是处于自由之中的。</p><p>这让我想到了教育的重要性，我始终觉得人类社会的平等需要教育的平等，让每一个人都能够接受到平等的教育，让每一个人能学会独立思考，分辨真伪，只有这样权力的轮子才不会压在我们的身上，这样才能限制政府的权力。猪通过接受教育在动物中获得了压倒性的地位，篡改历史，麻痹群众，让动物认为他们生活在幸福之中。</p><p>然而，从目前看来，任重道远。正如《美丽新世界》一样，我们所喜爱的东西正在摧毁我们。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《三四郎》读书笔记</title>
      <link href="/2021/02/23/%E3%80%8A%E4%B8%89%E5%9B%9B%E9%83%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/23/%E3%80%8A%E4%B8%89%E5%9B%9B%E9%83%8E%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>三四郎凝视着池面，只见好几棵大树映现在水底，底上还出现了青天。这时，三四郎感到自己的心绪已远离电车，远离东京，远离日本了。然而不一会儿，一团像薄云似的落寞感在他的内心弥漫开来，宛如进入野野宫君的地窖而独自坐着时的那种寂寞。在熊本的高级中学时，三四郎登过更为寂静的龙田山，也在夜来香丛生的运动场上躺过，他多次处于完全忘机的情绪中，然而现在的这种孤独感却是第一次尝到。</p></blockquote><blockquote><p>三四郎发现，无论借哪一本书，这书一定有谁先看过了，因为书中到处都有铅笔划的印子。</p></blockquote><blockquote><p>三四郎听了这四个人对乞丐的议论，感到自己迄今为止养成的道义观念受到了几分创伤；不过自己从乞丐面前走过的时候，不仅没有产生过扔一个子儿的想法，老实说，还一味地感到很不愉快呢！从这一事实来反省一下，三四郎觉得这四个人反而要比自己表里一致，而且认识到：他们都是能在个人表里一致的广阔天地里驰骋的那种大都会里的人物。</p></blockquote><blockquote><p>确如美祢子所言，自己与野野宫相比，是相差一大截呢。自己刚从乡下出来进入大学，既没有像样的学问，也没有真正的识见。自己当然得不到美祢子对野野宫的那种尊敬。那么说来，自己在她眼里，似乎是不屑一顾的了。先前自己说”运动会没什么意思，所以来到了这儿”，而美祢子在冈上答话的时候，竟然一本正经地问道：”那上面有什么有趣的东西吗？”自己当时没有在意，现在分析一下的话，也许这话是在故意嘲弄自己。<br>三四郎注意到这一点后，便把迄今为止美祢子对自己的态度和说话一一回顾一遍，发现每一次都是别有不良用意的。三四郎便在路中央涨红了脸，便低着脑袋朝前走。</p></blockquote><blockquote><p>三四郎走上住所的二楼，进入自己的房间，坐下试试，依然有刮风的声音。三四郎每次听见这种风声，就会想起”命运”二字。而每次听到这呼啸着的风声便不寒而栗，他自己也认为自己绝不是一个坚强的人。静心一想，自从上东京以来，自己的命运大体上被与次郎操纵，而且在某种程度上像是受到了和和气气的愚弄；与次郎是一位可爱的恶作剧者，今后，自己的命运也将被这个可爱的恶作剧者左右，风不停地吹，这风确实比与次郎更强大些。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>读完的瞬间感受就是：一把无形的刀刃无形地刺入内心。</p><p>三四郎是一个善良、有道德、有原则之人。或许他是懦弱的，但是他是值得尊敬的。他是一只迷途的羔羊，面对三个世界，他也感到了迷茫，感到了格格不入。但是，他从来没有去伤害别人。在文章的开始，他也坚持了自己的原则（或许女方希望他主动）。我不认为这样的人懦弱。但最终他也成长了，不断地认识他所谓的好朋友与次郎的真面目，了解美祢子这个人。</p><p>不得不说一下与次郎，这个人无不做尽卑鄙之事。他真的是真心想帮助广田先生吗？我估计是为了报社的销量。打着善良之名做尽卑鄙之事，却还死皮赖脸装好人。赌马浪费了钱，骗三四郎没有钱，希望三四郎能借钱。利用别人的善意做卑鄙之事，把不还钱说得头头是道。文末的时候，还揭露了他欺骗女人的感情，还把女人骗得头头是道。</p><p>美祢子，也是迷途的羔羊，因为她深深地被野野宫吸引了，喜欢着野野宫。但是野野宫的世界在于他的研究，对于婚嫁他并不感兴趣。美祢子视作男主为工具人，希望通过男主让野野宫吃醋。但实际上，野野宫对美祢子就没有那方面的感情。然后心灰意冷，嫁给了准备娶良子的男人。</p><p>在本文中，始终存在着光辉的便是广田先生和野野宫。他们两个都关注于自己的内心世界。去关注自己感兴趣的东西。或许，这种世界才是我所向往的。</p><p>从现在的角度看，这本书仍有现实意义。正因为没有刀刃，所以处处锋芒。世界仍然是那么地疯狂。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《心》读书笔记</title>
      <link href="/2021/02/23/%E3%80%8A%E5%BF%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/23/%E3%80%8A%E5%BF%83%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><blockquote><p>我才明白，先生从一开始就没有讨厌我，他偶尔对我表现出的看似冷淡恩典寒暄和举动，并不是想疏远我的不快表现，而是内心有着创伤的先生，对于想要接近自己的人发出的警告——自己不值得接近，不要过来。拒绝别人亲近的先生，似乎在轻视别人之前早已轻视了自己。</p></blockquote><blockquote><p>“我是个孤独的人，”那天晚上，先生又说了一遍前几天的那句话，“我是个孤独的人，也许你也是个孤独的人吧。我虽然孤独，但上了年纪，闷在家里也无所谓，可你还年轻，不会这样下去的吧？你一定是精力充沛得无处发泄吧？想要跟什么较较劲吧…”</p></blockquote><blockquote><p>“我一点儿也不觉得孤独。”<br>“没有比年轻的时候更让人觉得孤独的了，否则你为什么老往我家跑呢？”<br>这时，先生又重复了前几天说过的话。<br>“虽然你到我家来，但你仍感到孤独吧。因为，我没有力量让你从根本上摆脱这种孤独。很快，你就会朝别的方向去扩展你的空间；很快，你就不会到我这里来了。”先生这样说着，凄然地笑了。</p></blockquote><blockquote><p>因为曾经跪拜在对方面前的屈辱回忆，将使你把脚踏在他的头上。我是为了不受将来的屈辱，才拒绝现在别人的尊敬的。我宁愿忍受现在的孤独，也不愿忍受将来更深的孤独。我们生在充满自由、独立和自我的现代社会，就必须忍受符出品尝这种孤独的代价。</p></blockquote><blockquote><p>夫人不是现代人，因而才会通过显示自己是个有头脑的人，寻求某种自尊。比起争论来，夫人似乎更珍视内心深处的安宁。</p></blockquote><blockquote><p>你认为世上会有一种叫做坏人的人吗？那种用模子刻出来的坏人，世上当然是没有的。平时都是好人，至少是一般人，可是一到关键时刻，有可能突然变成坏人，所以才可怕。因此绝不能掉以轻心。</p></blockquote><blockquote><p>因为我想，这种个性可能会影响一个人的所作所为，使得我日后越发怀疑起了他人的道义之心。毫无疑问，正是我的个性促使我走向了烦闷、苦恼的深渊。请你务必记住这一点。</p></blockquote><blockquote><p>我总觉得朝夕相处的男女之间，会失去相爱所需的刺激引发的清新感觉。正如在焚香的一瞬间才闻得到香味一样，品酒只有在刚入口的一刹那才最有味道。以此类推，爱情的冲动也只存在于顷刻之间，一旦没有感觉地度过那个瞬间，那么越熟悉就只会越亲密，只会使爱情的神经渐渐麻痹下来。</p></blockquote><blockquote><p>尽管在金钱上我怀疑人性，但在爱情方面却不怀疑人性。即便别人无法理解，自己也觉得自相矛盾，它们却在我胸中和平共处着。</p></blockquote><blockquote><p>假如爱这个神奇的东西有两端，那高的一端是神圣感，低的一端是是性欲在起作用的话，那么我的爱是立足于高的一端的。</p></blockquote><blockquote><p>无论是肉体上还是精神上，我们的一切能力都会因外部条件的刺激而提高或受到破坏。当然，无论提高还是破坏，都必须逐渐加强刺激，所以，如果不仔细思考的话，便会朝着非常危险的方向滑下去，而没有人——更不用说自己了——能够察觉得到。</p></blockquote><blockquote><p>我总是怀有一种信念，不管世人如何，本人必定要洁身自好。但是当我意识到，这种信念已由于K的自杀而幻灭，自己也和叔叔是一样的人时，我突然感到困惑了。一向厌恶别人的我，对自己也厌恶起来，从而陷入了绝望。</p></blockquote><blockquote><p>当我想到，连这世上自己最亲近的人都不能理解自己时，便悲伤起来，一想到尽管有办法使她理解自己时，便悲伤起来，一想到尽管有办法使她理解自己，却又拿不出勇气时，就越发悲伤。我感到异常孤独，常常觉得只有我一个人住在这荒无人烟的世界上。</p></blockquote><blockquote><p>我尽心竭力地护理岳母，这样做既是为了病人，也是为了我的爱妻，但从更高的意义上来说，乃是为了人。</p></blockquote><blockquote><p>抱着已死之心苟活于世的我，时常由于外界的刺激而跳动起来。但是，每当我决心朝某个方向冲去的时候，便有一股可怕的力量从某处钻出来，紧紧地攥住我的心，使我丝毫动弹不得。而且，那个奇怪的力量似乎在对我说：你是个没有资格做任何事情的人。</p></blockquote><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>《心》，正如标题所说的那样。这一部小说讲述的内容，是关于心的。</p><p>对于先生来说，叔叔给他造成了无与伦比的影响。让他突然明白了坏人，开始怀疑起他人。其实怀疑他人并不是一件扭曲的事情，但是过度地怀疑以及对无法人都无法信任并使先生走向扭曲甚至是一个封闭的空间，先生永远也出不去，同时什么事情也无法走进先生。</p><p>先生的遗书可谓是本书的精华部分，先生喜欢上了寄宿家的小姐。为了帮助K，先生将K带到了寄宿家。先生不断猜疑K是不是喜欢上了小姐，而当K给先生坦白了对于小姐的爱意的时候，先生直接给夫人坦白了自己对小姐的爱意，然后K自杀了。</p><p>K是一个坚韧、坚持自己想法的人。文中不断地暗示他是一个孤独的、了然一身的人。因此他选择了走向自我灭亡的道路。不仅仅是因为被朋友背叛，而是本以为能互相理解的人，怎料到如此下场，或许K也对自己产生了怀疑。</p><p>先生一辈子都活在对于K的愧疚之中，让他逐渐地走向更加封闭的空间，对于先生来说，时间和空间均是静止的，先生在狭小的空间苟活着，太太也无法走进他的内心。因此，先生感觉到了悲哀，他觉得连世上最亲近的人都无法理解自己。</p><p>终究其根本的原因，先生每当想要说出真相的时候，却提不起这个勇气。先生已完全将自己封闭了，对于未来的可能性。先生是孤独的吗？其实，先生只能说是不幸的，因为他对他重要的朋友撒了谎，对重要之事撒了谎。这让他走向了自我厌恶，认为自己成为了叔叔那样的人，那种最令人厌恶的人。</p><p>往往善恶总在一念之间。先生一念之间做的恶让先生愧疚了一辈子，先生不仅对不起K，也对不起他的太太。太太可谓是本作品里面最不知情的人，在我看来，是最悲哀的人。哪怕先生死去之后，太太恐怕也无法得知真相，哪怕面对她怎么样也无法走进内心的丈夫，她也曾尽自己的一份力去尽可能地理解丈夫，太太难道不孤独吗？先生的自杀在我看来更是一种逃避，至少他又通过这种方式抛弃了自己的妻子，死确实能解脱一切，摆脱自己对于朋友K的愧疚之情。</p><p>死难道就可以一了百了吗？与先生如此相关联的太太，难道不会因此受到伤害吗？</p><p>这些作者并没有给出答案，我的这些思考也不知道是否偏离了文章的主题。但是，我想告诫我自己，一定不要对重要的人、重要的事撒谎，一旦撒下谎言，只能用一个谎言去弥补另一个谎言，又或是一辈子活在愧疚之中，无法得到救赎。</p><p>因为先生本可以光芒万丈。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《论自由》读书笔记</title>
      <link href="/2021/02/20/%E3%80%8A%E8%AE%BA%E8%87%AA%E7%94%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/20/%E3%80%8A%E8%AE%BA%E8%87%AA%E7%94%B1%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><p>开篇一开始，明确本书的主旨：</p><blockquote><p>意志之自由一直被误认为是哲学的必然论域，而本文的旨趣恰恰与之相反，是关于公民或社会的自由，即讨论社会合法地作用于个人之力量的属性和界限。</p></blockquote><p>随后开始讲述自由与威权（Authority）的斗争：</p><p>在过去，斗争存在于国民或国民中的某些阶级与政府之间，自由也就意味着保护大家免受来自统治者的暴政。爱国者的目的就是对统治者被允许施加于群众的力量作出限定（对自由的理解）：</p><ul><li>使得某种豁免权获得承认，可以称作政治自由或政治权利。</li><li>建立宪法制衡。</li></ul><p>密尔对这种自由的看法：</p><blockquote><p>只要人类还满足于以毒攻毒，让一个主人来统治自己，并对这个主人的暴政或多或少能进行有效的抵抗，那么他们对自由的渴望就还没迈过这个坎。</p></blockquote><p>随着人类的进步，人们不再认为统治者是与人民对立的。因为统治者由选举产生且有任期。此刻，有些人开始认为对统治力量的种种限制被看得过重，因为统治者是由人民选举出来的，统治者的利益是与人民的利益一致的。</p><p>密尔提出了批评，进而提出了多数人的暴政的观点：</p><blockquote><p>那些行使公共权利的”人民”与那些被权利控制的”人民”并不相同；”自治”也并不意味着自己统治自己，而是自己被其他人管束。人民的意愿实际上意味着在人数上占大多数的人或者是最活跃的那部分人的意愿。而所谓的”多数人”可能也只是那些成功地使自己被认作是代表多数人的那些人。</p></blockquote><p>多数人的暴政因其运行在公共权利之中，从而始终平庸地伴随着恐怖：</p><blockquote><p>因为，尽管多数人的暴政很少诉诸极端的惩罚，但却使人无所逃遁，它更深入地渗透到生命的细枝末节并且奴役灵魂本身。</p></blockquote><p>故密尔认为集体观点干涉个人独立性的合法性是有界限的，发现并维持这个界限不受侵蚀与防止政治专制破坏人类事务的良好状态是同等重要的。有两种实践方式：</p><ul><li>由法律手段实现。</li><li>观念上加以确立。</li></ul><p>然而这两种实践方式需要相应的原则，密尔对当时道德原则提出了批判：</p><blockquote><p>不管在哪，只要存在着优势阶层，大部分的道德就都是从此阶层的利益和优越感出发的。</p></blockquote><p>密尔提出了自己的原则：</p><blockquote><p>社会以强迫和控制的手段对个人的干预，无论其方式是法罚下的强制还是公共舆论下的道德压制都要受此原则管辖。这个原则就是：人们获准个别地或集体地对他人的行为自由进行干涉，其目的只能是自我防卫。也就是说，保护自身不受他人伤害是权力正当施用于文明社会一分子并违抗其意志的唯一目的。一个人本身精神上或物质上的利益得失并不足以成为干涉他人的正当理由。人们不能因为这会使他更好，这使他更幸福，这在别人看来更明智，就强迫此人做或者不做什么。这些尽管是规劝、争论、说服、恳求他的良好理由，却不是强迫他的借口，更不是为了防止他反向而行就加害于他的借口。这种强迫被证明是正当的唯一可能，只能是需要被阻止的行为将伤及他人。一个人的行为，只有在关系到他人的情况下才需要对社会负责，在仅关乎自身的部分，个人的独立性无疑是绝对的。对于自身，对于自己的肉体和精神，个人是自主的。</p></blockquote><p>提出了自己的自由观：</p><blockquote><p>唯一名副其实的自由，是我们按自己的方式追求自身的幸福，只要我们不剥夺他人的自由，不阻碍他人为获得自由而付出努力。</p></blockquote><h2 id="第二章-论思想自由和言论自由"><a href="#第二章-论思想自由和言论自由" class="headerlink" title="第二章 论思想自由和言论自由"></a>第二章 论思想自由和言论自由</h2><p>密尔提出了一个情景：</p><blockquote><p>试想所有人都持一种观点而只有一人持有异议，那么所有人让这一人闭嘴，并不比这一人将所有人禁言来得更加正义。</p></blockquote><p>当压制的观点可能是正确的。密尔认为人是具有不可靠性的，人对于自己的不可靠性在实践中的重视远远不及理论。密尔认为人是拥有判断力的，不能因为判断力可能出错，就不允许发表观点。人类判断力的全部力量和价值取决于知错就改。人类了解某一事物整体面貌的唯一途径就是广泛听取不同观点者的评论，并且研究不同的头脑看待这一事物的模式。</p><p>然而，人们承认自由讨论的必要性，却又推至极端。因为通常的自由讨论，有些信条和原则是毋庸置疑的，原因是这些信条和原则是可靠的。正如上面所说，忽略了人本身的不可靠性。密尔认为人害怕失去自己的观点变得无所适从，而非自己的观点是否多么正确。</p><p>密尔进而对如果这个观点有害，我们就要禁止它进行讨论，密尔不同意这个说法，密尔认为判断一个观点是否有害，这本身也是一个观点，需要通过开放讨论才知道，当认为这个观点是有害的，本身就是一种臆测，是不可靠的。这样会造成很大的危害，例如历史上被法律所消灭的高尚的人和学说。</p><p>实际上，第二章对于例子的描述比较多，此处就忽略了。</p><h2 id="第三章-论个性——作为幸福的一大要素"><a href="#第三章-论个性——作为幸福的一大要素" class="headerlink" title="第三章 论个性——作为幸福的一大要素"></a>第三章 论个性——作为幸福的一大要素</h2><p>开篇直接论述本章主题：</p><blockquote><p>接下来我们将要考察的是同样的理由是否支持人类拥有按自己的意愿行动并践行自己主张的自由而不受其同胞在肉体上或道德上的阻挠，当然前提是他们自己承担一切后果。</p></blockquote><p>密尔认为秉承这一原则的最大困难在于人们对这一目标根本毫无关心：</p><blockquote><p>然而谬误在于普遍观念很少能承认个人的自主性有其内在价值，也不认为其本质值得被尊重。</p></blockquote><p>密尔进而论述了威廉的核心思想：</p><blockquote><p>人的目的并不由短暂多变的欲望决定，而是由永恒不变的理性支配，这个目的就是使他的生命力获得高度和谐的发展并臻于一个完全统一的整体；因此，能力与发展的个性化是每个人必须为之不懈奋斗的目标，也是那些意图影响他人的人所尤其关注的；而这又有两个前提条件，即自由与情景的多样性，从中产生的是个人的活力与丰富的差异性，二者结合便是创造性。</p></blockquote><p>密尔认为人们无法接受威廉的观点仅仅是在于人们对这个观点认识的程度不同，基于以下两个理由：</p><ul><li>没有人会认为完美的举止就是全盘照抄别人。</li><li>没有人能断言人们的生活方式和切己的行为不应受个人的选择和个性的影响。</li></ul><p>密尔接下来论述经验给人带来的影响并批判过度依赖经验是不可取的：</p><ul><li>经验是有限的、有条件的以及可能被误读的。</li><li>人的观察力、判断力、辨识力、智力活动甚至是道德倾向方面的水平只能通过做选择来锻炼。</li><li>人需要依从生命的内在动力去发展自己。</li></ul><p>密尔紧接着论述欲望与冲动：</p><ul><li>欲望与冲动是一个完整的人的一部分。</li><li>人犯错的原因并不是欲望太强，而是缺乏良知。</li><li>在人类早期社会，欲望和冲动或许强于教化的力量。而如今人类面临的不是冲动和喜好的泛滥，而是不足。</li></ul><p>密尔总结：</p><blockquote><p>要使人类成为高尚而美好的思想者，靠消灭一切有个性的东西绝不可行，而是应当顾及他人权益的前提下培养与发展这些东西。</p></blockquote><p>接而论述个性：</p><ul><li>个性的发展使得人本身更为重要，为社会的贡献也就更多。</li><li>个性的发展需要一定的限制措施避免伤害他人。</li><li>天才总是比他人更有个性。</li></ul><p>接着论述如今的政治环境以及自己观点方面的阐述：</p><blockquote><p>如今，个体已经淹没在集体里了。在政治上，人们总是轻浮地说：民意统治世界。唯一名副其实的力量就是民众，以及作为民众的喜好和本能的代言人——政府机关。</p><p>那些打着民意旗号的人未必代表全体民众。在美国，民众是指全体白人；在英国，民众是指中产阶级。但他们总归是一群人，即一群平庸之辈的集合。</p><p>当下的舆论方向有一个特点，就是被刻意设计得排斥个性的彰显。</p><p>人们理想的特质就是没有任何显著特质，就好像中国女人裹小脚一样，用压力来戕害人性中与众不同的部分，让那些明显不太一样的人们变得平凡无奇。</p></blockquote><p>密尔接下来论述民族兴衰与这个民族是否尊重个性有关，主要是通过中国论述的，首先密尔承认了中国的优点：</p><blockquote><p>这是一个拥有如此多的天赋，或者从某种意义上说，如此多智慧的国家。它的成功都要归功于它在很早以前就有幸获得了一套优良的习俗以及那些连最文明的欧洲人都钦佩的圣人和智者们所创造的丰功伟业。</p></blockquote><p>他认为中国在近代走下落寞的原因是在于不尊重个性，同化所有人，认为欧洲的发展是无序的从而取得了较好的发展，密尔同时也表达了自己的担忧：</p><blockquote><p>欧洲正变得越来越像中国，即同化所有人。</p></blockquote><h2 id="第四章-论社会之于个人的权力限度"><a href="#第四章-论社会之于个人的权力限度" class="headerlink" title="第四章 论社会之于个人的权力限度"></a>第四章 论社会之于个人的权力限度</h2><p>在论述了个性的重要性后，密尔进而论述社会对个人的权利限度。本章仍然是开篇提出问题：</p><blockquote><p>个人之于他自身的主权可以伸张到何种程度？社会权力又当从何处着手管辖？一个人的生命有多少是该被划归个人的，又有多少是属于社会的？</p></blockquote><p>密尔首先承认人对社会的必要义务：</p><blockquote><p>每个接受了社会庇护的人都欠着社会的情，而生活在社会当中的这一事实也使得我们必须在乎他人的事务上遵守一系列的行为准测。</p></blockquote><p>密尔通过论述提出了自己的观点：</p><blockquote><p>在此处我要争取的是，一个人在不影响他人与之相关的利益基础之上，在仅仅关乎他自己的事务上所允许受到的唯一影响，只能是因为不受他人欢迎而直接导致的不便。</p></blockquote><p>也就是说，密尔认为对于不影响他人的利益的个人行为，只有当他的行为因为不受欢迎进而<strong>直接</strong>导致了不便，才能对他的行为进行干涉。例如，如果一个人因为不够聪明，我们可以表示厌恶，或者直接逃离，但不能<strong>泄愤</strong>。也就是密尔对个人行为进行了区分，分为直接违反他人利益的，应该直接惩罚。而对于上述的行为,应区别对待。</p><p>然而，很多人会对上述的东西提出反对意见：</p><ul><li>一个社会成员的行为怎么可能有任何一部分与其他成员无关呢？</li><li>没有谁是完全孤立的个体，因而不可能说一个人做了害自己的事而不波及其他人。</li></ul><p>对于这些意见，密尔首先承认了其一定的正确性，但密尔认为只要人忽略了他人的利益和感受去做一些不是必须要做的事情，他所犯下的错误必然是不道德的。而他的行为，也就是能够伤害他人行为的涉己事物不一定是造成不道德的原因。例如一个人因为挥霍而不能偿还债务或是不能养家糊口，他就理应接受批评和责罚。但这些批评和责罚是<strong>针对他背弃了对债主和家人的责任而并非因为挥霍</strong>。</p><p>故密尔认为个人的涉己行为固然可能给他人造成伤害或是不便，但这种伤害是非必然的、偶发的。所以应当给予宽容，并给予充分的自由。</p><h2 id="第五章-自由原则的应用"><a href="#第五章-自由原则的应用" class="headerlink" title="第五章 自由原则的应用"></a>第五章 自由原则的应用</h2><p>本章开篇说明两个原则：</p><ul><li>个人的行为如果只关乎自身，就无须向社会作出解释。他人的建议、指导、劝告与回避如果是出于对他人自身利益的必要考虑，才得以成其为社会公正地表达对此人行为不悦或谴责的必要方式。</li><li>对于伤害他人利益的行为，如果舆情认为采取惩罚是保卫其他人的必需条件，那么个人就当负责，服从社会或法律的惩罚。</li></ul><p>进而具体论述：</p><p>不能因为对他人利益的侵害可能使社会干预正当化。原因在于：</p><ul><li>由于糟糕的社会制度存在的原因，冲突不可避免。</li><li>无论哪种社会制度都存在的冲突，例如考试。</li></ul><p>对个别特例进行了分析：</p><blockquote><p>卖身为奴是对自由的放弃，一旦这么做就从此告别了自由的使用权。自由原则不允许他有选择不自由的自由，被允许放弃自由不是一种自由。</p></blockquote><p>密尔对生儿育女提出了自己的看法，对于密尔来说生儿育女并不是自由的：</p><blockquote><p>生儿育女是人生中最富有责任的行为之一，要承担这份职责，为一个生命的福祸负责，就必须保证他至少有最一般的机会可以理想地生存。否则就是对这个生命的犯罪。</p></blockquote><p>最后的总结：</p><blockquote><p>从长远看，国家的价值在于其国民的价值。国家如果把国民精神发展进步的利益摆在它的治术之后，或者类似的由实践产生的细枝末节的事务之后；如果弱其国民，使之成为国家手中温驯的傀儡，即便是出于好意，到头来也会发现，国民弱则一事无成，而那牺牲万千换来的完美国家机器，终将一无是处。因为为了使这机器运转良好，它的代价是这个国家的生命力。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
