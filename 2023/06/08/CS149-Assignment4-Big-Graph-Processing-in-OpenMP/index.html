<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="CS149-Assignment4 Big Graph Processing in OpenMP" />


<!-- Website keywords -->

<meta name="keywords" content="技术, 学习, 洛的藏书阁" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="洛的藏书阁" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://luolibrary.com/2023/06/08/CS149-Assignment4-Big-Graph-Processing-in-OpenMP/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7M238H24L4"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-7M238H24L4');
</script>

  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>CS149-Assignment4 Big Graph Processing in OpenMP - 洛的藏书阁</title>

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">洛的藏书阁</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">洛的藏书阁</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      CS149-Assignment4 Big Graph Processing in OpenMP
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-06-08
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/CS149/">CS149</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-1"><span class="toc-number">1.</span> <span class="toc-text">Part 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-2"><span class="toc-number">2.</span> <span class="toc-text">Part 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-Down-BFS"><span class="toc-number">2.1.</span> <span class="toc-text">Top Down BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bottom-Up-BFS"><span class="toc-number">2.2.</span> <span class="toc-text">Bottom Up BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hybrid-BFS"><span class="toc-number">2.3.</span> <span class="toc-text">Hybrid BFS</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>Before we use openMP to parallelize the code. We just first write the serial form. It is easy.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pageRank</span><span class="params">(Graph g, <span class="type">double</span>* solution, <span class="type">double</span> damping, <span class="type">double</span> convergence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> numNodes = <span class="built_in">num_nodes</span>(g);</span><br><span class="line">  <span class="type">double</span> equal_prob = <span class="number">1.0</span> / numNodes;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; ++i) &#123;</span><br><span class="line">    solution[i] = equal_prob;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>* tempArray = <span class="keyword">new</span> <span class="type">double</span>[g-&gt;num_nodes];</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> converged = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!converged) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> Vertex* iv = <span class="built_in">incoming_begin</span>(g, v); iv != <span class="built_in">incoming_end</span>(g, v); ++iv) &#123;</span><br><span class="line">        tempArray[v] += solution[*iv] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">outgoing_size</span>(g, *iv));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = tempArray[v] * damping + (<span class="number">1.0</span> - damping) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> t = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">outgoing_size</span>(g, v) == <span class="number">0</span>) &#123;</span><br><span class="line">          t += damping * solution[v] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] += t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> globalDiff = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      globalDiff += <span class="built_in">abs</span>(tempArray[v] - solution[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      solution[v] = tempArray[v];</span><br><span class="line">    &#125;</span><br><span class="line">    converged = globalDiff &lt; convergence;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] tempArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now we can use openMP to parallelize the code above.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pageRank</span><span class="params">(Graph g, <span class="type">double</span>* solution, <span class="type">double</span> damping, <span class="type">double</span> convergence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> numNodes = <span class="built_in">num_nodes</span>(g);</span><br><span class="line">  <span class="type">double</span> equal_prob = <span class="number">1.0</span> / numNodes;</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numNodes; ++i) &#123;</span><br><span class="line">    solution[i] = equal_prob;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>* tempArray = <span class="keyword">new</span> <span class="type">double</span>[g-&gt;num_nodes];</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> converged = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!converged) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g, solution)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> Vertex* iv = <span class="built_in">incoming_begin</span>(g, v); iv != <span class="built_in">incoming_end</span>(g, v); ++iv) &#123;</span><br><span class="line">        tempArray[v] += solution[*iv] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="built_in">outgoing_size</span>(g, *iv));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g, damping, numNodes)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] = tempArray[v] * damping + (<span class="number">1.0</span> - damping) / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> t = <span class="number">0.0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) reduction(+: t) shared(solution, g, numNodes, damping)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">outgoing_size</span>(g, v) == <span class="number">0</span>) &#123;</span><br><span class="line">        t += damping * solution[v] / <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numNodes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, g, t)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      tempArray[v] += t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> globalDiff = <span class="number">0.0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) reduction(+: globalDiff) shared(tempArray, solution, g)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      globalDiff += <span class="built_in">abs</span>(tempArray[v] - solution[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for default(none) shared(tempArray, solution, g)</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex v = <span class="number">0</span>; v &lt; g-&gt;num_nodes; ++v) &#123;</span><br><span class="line">      solution[v] = tempArray[v];</span><br><span class="line">    &#125;</span><br><span class="line">    converged = globalDiff &lt; convergence;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] tempArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><h3 id="Top-Down-BFS"><a href="#Top-Down-BFS" class="headerlink" title="Top Down BFS"></a>Top Down BFS</h3><p>The easiest idea for implementing top-down bfs is to use two variables, one is for the current frontier, and another is for the next frontier. And when we add the new node to the next frontier, we should use <code>#pragma omp critical</code> to protect the next frontier. However, this method is too slow.</p>
<p>However, we could let each thread use its local next frontier. Thus we could avoid critical section and make the code faster.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">top_down_step</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Graph g,</span></span></span><br><span class="line"><span class="params"><span class="function">    vertex_set* frontier,</span></span></span><br><span class="line"><span class="params"><span class="function">    vertex_set* localList,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* distances)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;frontier-&gt;count; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> node = frontier-&gt;vertices[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> start_edge = g-&gt;outgoing_starts[node];</span><br><span class="line">        <span class="type">int</span> end_edge = (node == g-&gt;num_nodes - <span class="number">1</span>)</span><br><span class="line">                           ? g-&gt;num_edges</span><br><span class="line">                           : g-&gt;outgoing_starts[node + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// attempt to add all neighbors to the new frontier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor=start_edge; neighbor&lt;end_edge; neighbor++) &#123;</span><br><span class="line">            <span class="type">int</span> outgoing = g-&gt;outgoing_edges[neighbor];</span><br><span class="line">            <span class="keyword">if</span> (distances[outgoing] == NOT_VISITED_MARKER &amp;&amp;</span><br><span class="line">            __sync_bool_compare_and_swap(&amp;distances[outgoing], NOT_VISITED_MARKER, distances[node] + <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="type">int</span> index = localList[<span class="built_in">omp_get_thread_num</span>()].count++;</span><br><span class="line">                  localList[<span class="built_in">omp_get_thread_num</span>()].vertices[index] = outgoing;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">      count[i] = totalCount;</span><br><span class="line">      totalCount += localList[i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    frontier-&gt;count = totalCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parallel copy the data from `localList` to `frontier`</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(frontier-&gt;vertices + count[i], localList[i].vertices,</span><br><span class="line">                localList[i].count * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bottom-Up-BFS"><a href="#Bottom-Up-BFS" class="headerlink" title="Bottom Up BFS"></a>Bottom Up BFS</h3><p>The Top Down BFS is an easy job to do actually. Because it is a prior algorithm. However, in the code, we would do many logical operations especially the frontier size is large and its ancestors’ size is small. Look at the following code snippet, which would cause so many logical operations.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distances[outgoing] == NOT_VISITED_MARKER &amp;&amp;</span><br><span class="line">  __sync_bool_compare_and_swap(&amp;distances[outgoing], NOT_VISITED_MARKER, distances[node] + <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="type">int</span> index = localList[<span class="built_in">omp_get_thread_num</span>()].count++;</span><br><span class="line">    localList[<span class="built_in">omp_get_thread_num</span>()].vertices[index] = outgoing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Well, I cannot understand the principle of Bottom Up BFS. So I decide to read an essay which is called <a target="_blank" rel="noopener" href="https://downloads.hindawi.com/journals/sp/2013/702694.pdf">Direction-optimizing breadth-first-search</a>.</p>
<p>I think the paper is enough. So I omit detail here. You should carefully read the paper. And I record some information here.</p>
<blockquote>
<p>The majority of the computational work in BFS is checking edges of the frontier to see if the endpoint has been visited. The total number of edge checks in the conventional top-down algorithm is equal to the number of edges in the connected component containing the source vertex, as on each step every edge in the frontier is checked.</p>
</blockquote>
<p>Well, at now the bottom-up way is clear. For every step, we just traverse all the vertices. And we have the current <code>frontier</code> information. From Top Down BFS, we need to check for every vertex’s neighbor to add it to the <code>next_frontier</code>. In the Bottom Up BFS, we just find whether the <code>child</code> is the ancestor of the vertices in the <code>frontier</code>. Thus every child would only can be visited once.</p>
<p>Now we can code.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">bottom_up_step</span><span class="params">(Graph g, <span class="type">bool</span>* frontier, <span class="type">bool</span>* new_frontier, <span class="type">int</span>* distances)</span> </span>&#123;</span><br><span class="line">    uint count = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for reduction(+: count)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g-&gt;num_nodes; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distances[i] == NOT_VISITED_MARKER) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> Vertex* incoming = <span class="built_in">incoming_begin</span>(g, i); incoming != <span class="built_in">incoming_end</span>(g, i); ++incoming) &#123;</span><br><span class="line">                <span class="keyword">if</span> (frontier[*incoming]) &#123;</span><br><span class="line">                    distances[i] = distances[*incoming] + <span class="number">1</span>;</span><br><span class="line">                    new_frontier[i] = <span class="literal">true</span>;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs_bottom_up</span><span class="params">(Graph graph, solution* sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> *frontier = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line">    <span class="type">bool</span> *new_frontier = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> *current = frontier;</span><br><span class="line">    <span class="type">bool</span> *next = new_frontier;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">        current[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set for the root node</span></span><br><span class="line">    current[ROOT_NODE_ID] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="comment">// initialize all nodes to NOT_VISITED</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;graph-&gt;num_nodes; i++)</span><br><span class="line">        sol-&gt;distances[i] = NOT_VISITED_MARKER;</span><br><span class="line">    sol-&gt;distances[ROOT_NODE_ID] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    uint count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">            next[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">bottom_up_step</span>(graph, current, next, sol-&gt;distances);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Swap the pointer</span></span><br><span class="line">        <span class="type">bool</span> * temp = next;</span><br><span class="line">        next = current;</span><br><span class="line">        current = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] frontier;</span><br><span class="line">    <span class="keyword">delete</span>[] new_frontier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, the result is illustrated below.</p>
<p><img src="https://s2.loli.net/2023/06/08/GM7OjLKNf98ipeq.png" alt="bottom_up_first"></p>
<p>As you can see, I cannot get the full grades. I am wondering the reason. You could look at this <a target="_blank" rel="noopener" href="http://www.nic.uoregon.edu/~khuck/ts/acumem-report/manual_html/ch06s07.html">article</a>.</p>
<p>And the article provides some tips:</p>
<ul>
<li>Avoid writing to global data that is accessed from multiple threads.</li>
<li>Align shared global data to cache line boundaries.</li>
<li>Don’t store temporary, thread specific data in an array indexed by th thread id or rank.</li>
<li>When parallelizing an algorithm, partition data sets along cache lines, not across cache lines.</li>
</ul>
<p>The last tip is what we could do. So we could use <code>schedule(dynamic, chunk_size)</code> for openMP to improve efficiency.</p>
<h3 id="Hybrid-BFS"><a href="#Hybrid-BFS" class="headerlink" title="Hybrid BFS"></a>Hybrid BFS</h3><p>The pairing of the top-down approach with the bottom-up approach is complementary, since when the frontier is its largest, the bottom-up approach will be at its best whereas the top-down approach will be at its worst, and vice versa.</p>
<p>So the idea is simple. Uses the Top Down BFS for steps when the frontier is large. We begin each search with the Top Down BFS and continue until the frontier becomes too large, at which point we switch to the Bottom Up BFS.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs_hybrid</span><span class="params">(Graph graph, solution* sol)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A flag</span></span><br><span class="line">    <span class="type">bool</span> isUpDownBFS = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> switchFlag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up for Bottom Up BFS</span></span><br><span class="line">    <span class="type">int</span> chunk_size = MACHINE_CACHE_LINE_SIZE * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">while</span> (graph-&gt;num_nodes &lt; <span class="built_in">omp_get_max_threads</span>() * chunk_size) &#123;</span><br><span class="line">        chunk_size /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> *frontier_bottom_up_bfs = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line">    <span class="type">bool</span> *new_frontier_bottom_up_bfs = <span class="keyword">new</span> <span class="type">bool</span>[graph-&gt;num_nodes];</span><br><span class="line">    <span class="type">bool</span> *current = frontier_bottom_up_bfs;</span><br><span class="line">    <span class="type">bool</span> *next = new_frontier_bottom_up_bfs;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">        current[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current[ROOT_NODE_ID] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up for Top Down BFS</span></span><br><span class="line">    vertex_set list;</span><br><span class="line">    <span class="built_in">vertex_set_init</span>(&amp;list, graph-&gt;num_nodes);</span><br><span class="line">    <span class="type">int</span> maxThreadNum = <span class="built_in">omp_get_max_threads</span>();</span><br><span class="line">    vertex_set localList[maxThreadNum];</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxThreadNum; ++i) &#123;</span><br><span class="line">        <span class="built_in">vertex_set_init</span>(&amp;localList[i], graph-&gt;num_nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count[maxThreadNum];</span><br><span class="line">    vertex_set* frontier_top_down_bfs = &amp;list;</span><br><span class="line">    frontier_top_down_bfs-&gt;vertices[frontier_top_down_bfs-&gt;count++] = ROOT_NODE_ID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global configuration</span></span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="comment">// initialize all nodes to NOT_VISITED</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;graph-&gt;num_nodes; i++)</span><br><span class="line">        sol-&gt;distances[i] = NOT_VISITED_MARKER;</span><br><span class="line">    sol-&gt;distances[ROOT_NODE_ID] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    uint frontier_length = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (frontier_length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUpDownBFS) &#123;</span><br><span class="line">            <span class="comment">// We come from Bottom Up BFS</span></span><br><span class="line">            <span class="keyword">if</span> (!switchFlag) &#123;</span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxThreadNum; ++i) &#123;</span><br><span class="line">                    <span class="built_in">vertex_set_clear</span>(&amp;localList[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We need to copy the information from `current`</span></span><br><span class="line">                <span class="comment">// to the `frontier_top_down, it is trivial.</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current[i]) &#123;</span><br><span class="line">                        <span class="type">int</span> index = localList[<span class="built_in">omp_get_thread_num</span>()].count++;</span><br><span class="line">                        localList[<span class="built_in">omp_get_thread_num</span>()].vertices[index] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> totalCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">                    count[i] = totalCount;</span><br><span class="line">                    totalCount += localList[i].count;</span><br><span class="line">                &#125;</span><br><span class="line">                frontier_top_down_bfs-&gt;count = totalCount;</span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">omp_get_max_threads</span>(); ++i) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(frontier_top_down_bfs-&gt;vertices + count[i], localList[i].vertices,</span><br><span class="line">                    localList[i].count * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                switchFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxThreadNum; ++i) &#123;</span><br><span class="line">                <span class="built_in">vertex_set_clear</span>(&amp;localList[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">top_down_step</span>(graph, frontier_top_down_bfs, localList, count, sol-&gt;distances);</span><br><span class="line">            frontier_length = frontier_top_down_bfs-&gt;count;</span><br><span class="line">            <span class="keyword">if</span> (frontier_length != <span class="number">0</span> &amp;&amp; graph-&gt;num_nodes / frontier_length&lt; UP_THRESHOLD) &#123;</span><br><span class="line">              isUpDownBFS = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We come from Top Down BFS</span></span><br><span class="line">            <span class="keyword">if</span> (switchFlag) &#123;</span><br><span class="line">                <span class="comment">// We should first clear the `current` because it has</span></span><br><span class="line">                <span class="comment">// some dirty data.</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">                    current[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Transfer the information from `frontier_top_down_bfs` to</span></span><br><span class="line">                <span class="comment">// `current`. It is easy for converting from Top Down BFS to</span></span><br><span class="line">                <span class="comment">// Bottom Up BFS</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; frontier_top_down_bfs-&gt;count; ++i) &#123;</span><br><span class="line">                    current[frontier_top_down_bfs-&gt;vertices[i]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                switchFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;num_nodes; ++i) &#123;</span><br><span class="line">                next[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontier_length = <span class="built_in">bottom_up_step</span>(graph, current, next, sol-&gt;distances, chunk_size);</span><br><span class="line">            <span class="type">bool</span> * temp = next;</span><br><span class="line">            next = current;</span><br><span class="line">            current = temp;</span><br><span class="line">            <span class="keyword">if</span> (frontier_length != <span class="number">0</span> &amp;&amp; graph-&gt;num_nodes / frontier_length &gt; BOTTOM_THRESHOLD ) &#123;</span><br><span class="line">              isUpDownBFS = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] frontier_bottom_up_bfs;</span><br><span class="line">    <span class="keyword">delete</span>[] new_frontier_bottom_up_bfs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://luolibrary.com">shejialuo</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://luolibrary.com/2023/06/08/CS149-Assignment4-Big-Graph-Processing-in-OpenMP/">https://luolibrary.com/2023/06/08/CS149-Assignment4-Big-Graph-Processing-in-OpenMP/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
      
      <a href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2023/08/16/%E7%BC%93%E5%AD%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">缓存基础知识</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2023/06/07/CS149-Assignment3-A-Simple-CUDA-Renderer/">  
        <span class="next-text nav-default">CS149-Assignment3 A Simple CUDA Renderer</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="utterances-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:shejialuo@gmail.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://twitter.com/luo_hope" class="iconfont icon-twitter" title="twitter"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/jialuo-she-913873289/" class="iconfont icon-linkedin" title="linkedin"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/shejialuo" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2020 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">shejialuo</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
  
<script>
  var container = document.getElementById('utterances-container');
  var script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', 'shejialuo/shejialuo.github.io');
  script.setAttribute('issue-term', 'pathname');
  script.setAttribute('theme', 'github-light');
  script.setAttribute('label', 'Comment');
  script.crossorigin = 'anonymous';
  script.async = true;

  container.appendChild(script);
</script>
  
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



<!-- mermaid -->

  <script src='https://unpkg.com/mermaid@9.2.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>