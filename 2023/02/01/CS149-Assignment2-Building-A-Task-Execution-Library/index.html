<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="CS149-Assignment2 Building A Task Execution Library" />


<!-- Website keywords -->

<meta name="keywords" content="技术, 学习, 洛的藏书阁" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="洛的藏书阁" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://luolibrary.com/2023/02/01/CS149-Assignment2-Building-A-Task-Execution-Library/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });  
  </script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7M238H24L4"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'G-7M238H24L4');
</script>

  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":true};
</script>
  
  <title>CS149-Assignment2 Building A Task Execution Library - 洛的藏书阁</title>

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">洛的藏书阁</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">洛的藏书阁</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      CS149-Assignment2 Building A Task Execution Library
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-02-01
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/CS149/">CS149</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-A"><span class="toc-number">1.</span> <span class="toc-text">Part A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Program"><span class="toc-number">1.1.</span> <span class="toc-text">Serial Program</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-1"><span class="toc-number">1.2.</span> <span class="toc-text">Step 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-2"><span class="toc-number">1.3.</span> <span class="toc-text">Step 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-3"><span class="toc-number">1.4.</span> <span class="toc-text">Step 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conclusion-for-Part-A"><span class="toc-number">1.5.</span> <span class="toc-text">Conclusion for Part A</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-B"><span class="toc-number">2.</span> <span class="toc-text">Part B</span></a></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>First, we should understand the file <code>itasksys.h</code>. It defines two abstract classes <code>IRunable</code> and <code>ITaskSystem</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IRunable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">IRunnable</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">runTask</span><span class="params">(<span class="type">int</span> task_id, <span class="type">int</span> num_total_tasks = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>It is obvious that the user should define the <code>IRunable</code> class. And the <code>runTask</code> is provided by the user. And the core class is <code>ITaskSystem</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ITaskSystem</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ITaskSystem</span>(<span class="type">int</span> num_threads);</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ITaskSystem</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> TaskID <span class="title">runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For <code>ITaskSystem::run()</code>, it executes a bulk task launch of <code>num_total_tasks</code>. Task execution is synchronous with the calling thread, so it will return only when the execution of all tasks is complete.</p>
<p>For <code>ITaskSystem::runAsyncWithDeps</code>, Executes an asynchronous bulk task launch of <code>num_total_tasks</code>, but with a dependency on prior launched tasks.</p>
<p>In part A, we do not consider about the <code>ITaskSystem::runAsyncWithDeps</code>.</p>
<h3 id="Serial-Program"><a href="#Serial-Program" class="headerlink" title="Serial Program"></a>Serial Program</h3><p>We first look at class <code>TaskSystemSerial</code>. The function <code>run</code> is defined as follow.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemSerial::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_total_tasks; i++) &#123;</span><br><span class="line">    runnable-&gt;<span class="built_in">runTask</span>(i, num_total_tasks);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>The simplest answer is just to make the <code>run</code> function as the master, and create the threads to do the job. And join the thread at last. (However, I use C++14 for better lambda function).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelSpawn::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> thread_func = [runnable_ = runnable, num = _num_threads, total = num_total_tasks](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; total) &#123;</span><br><span class="line">            runnable_-&gt;<span class="built_in">runTask</span>(i, total);</span><br><span class="line">            i += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::thread threads[_num_threads];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">      threads[i] = std::<span class="built_in">move</span>(std::<span class="built_in">thread</span>(thread_func, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">      threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Well, it is not so easy to write a thread loop. There are so many details we need to deal with. The most important thing here is do remember <code>join</code> all the threads when the class’s lifetime ends.</p>
<p>It may seem that we need to accept every index to dynamic choose what to do. This is a stupid idea. Remember, we should reduce the size of synchronization. So we use the idea of step 1.</p>
<p>And you could see the following code for details. First we should add some private members.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> _num_threads; <span class="comment">// to store the threads</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads; <span class="comment">// thread poll</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> jobs = <span class="number">0x00</span>; <span class="comment">// bitmap value for indicating whether there is a job</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bitmap_init_value = <span class="number">0x00</span>; <span class="comment">// initialized bitmap value with 0x1111</span></span><br><span class="line">  IRunnable* runnable_; <span class="comment">// we need to record the runnable</span></span><br><span class="line">  std::mutex queue_mutex; <span class="comment">// the big lock</span></span><br><span class="line">  <span class="type">bool</span> terminate = <span class="literal">false</span>; <span class="comment">// Whether we should terminate the thread</span></span><br><span class="line">  <span class="type">int</span> total_tasks = <span class="number">0</span>;    <span class="comment">// we should record the total task</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> num_threads)</span></span>; <span class="comment">// start the thread pool</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">threadLoop</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// thread functionality</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">busy</span><span class="params">()</span></span>; <span class="comment">// whether the threads are busy doing their jobs</span></span><br></pre></td></tr></table></figure>

<p>For constructor, we need to initialize the <code>bitmap_init_value</code> and start the thread pool.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSpinning::<span class="built_in">TaskSystemParallelThreadPoolSpinning</span>(<span class="type">int</span> num_threads)</span><br><span class="line">  : <span class="built_in">ITaskSystem</span>(num_threads), _num_threads(num_threads) &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> init = <span class="number">0x01</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">    bitmap_init_value |= init;</span><br><span class="line">    init &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">start</span>(_num_threads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For <code>start</code>, it is easy to understand.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::start</span><span class="params">(<span class="type">int</span> num_threads)</span> </span>&#123;</span><br><span class="line">  threads.<span class="built_in">resize</span>(num_threads);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    threads[i] = std::<span class="built_in">move</span>(std::<span class="built_in">thread</span>(&amp;TaskSystemParallelThreadPoolSpinning::threadLoop, <span class="keyword">this</span>, i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, we come to the most important part. For how to tell whether there is a job for the thread, we use <code>jobs</code> as a bit map. And when the job is finished, we make the corresponding to 0.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::threadLoop</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span> &amp;&amp; !terminate) &#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      std::lock_guard&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">      flag = (jobs &gt;&gt; i) &amp; <span class="number">0x01</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="type">int</span> taskId = i;</span><br><span class="line">      <span class="keyword">while</span>(taskId &lt; total_tasks) &#123;</span><br><span class="line">        runnable_-&gt;<span class="built_in">runTask</span>(taskId, total_tasks);</span><br><span class="line">        taskId += _num_threads;</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">        jobs &amp;= ~(<span class="number">0x01</span> &lt;&lt; i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the other calls <code>run</code>, it first initialize <code>jobs</code> to <code>bitmap_init_value</code>. And set the corresponding <code>runnable_</code> and the number of tasks. And if the <code>jobs</code> becomes 0, all the threads have competed their jobs. Thus, we can return.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSpinning::run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span> </span>&#123;</span><br><span class="line">  total_tasks = num_total_tasks;</span><br><span class="line">  runnable_ = runnable;</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">    jobs = bitmap_init_value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">busy</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Do remember join the threads at the destructor:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSpinning::~<span class="built_in">TaskSystemParallelThreadPoolSpinning</span>() &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Here, we don&#x27;t need to synchronize the code, because</span></span><br><span class="line"><span class="comment">    * the thread will never write `terminate`. No matter</span></span><br><span class="line"><span class="comment">    * the thread may read some corrupted value, this doesn&#x27;t matter.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  terminate = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; ++i) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>In the step 2, we have pushed all the threads and <code>run</code> spin, which is inefficient. So we should make them sleep. The idea here is simple. We just use condition variables to achieve that. It is just consumer and producer problem. So I omit detail here.</p>
<h3 id="Conclusion-for-Part-A"><a href="#Conclusion-for-Part-A" class="headerlink" title="Conclusion for Part A"></a>Conclusion for Part A</h3><p>I wanna say sometimes spin is better than sleep. Because sleep would cause context switch, which may be inefficient when cpu speed is high.</p>
<h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>For part B, the most interesting thing is how should we solve the dependency.</p>
<p>When the user calls <code>runAsyncWithDeps</code>, it will pass a bunch of task ids. So there is an important question: how can we find an efficient data structure to represent the dependency.</p>
<p>For every task, it will have dependencies, so I use <code>unordered_map&lt;TaskID, unordered_set&lt;Task*&gt;&gt;</code> to represent dependencies for the following several reasons:</p>
<ol>
<li>We can find the dependencies of a specified task.</li>
<li>Because the dependencies are represented as <code>unordered_set</code>, it is efficient to insert or delete.</li>
</ol>
<p>Because there are different tasks, I define a helper class <code>Task</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TaskID id;</span><br><span class="line">  IRunnable* runnable;</span><br><span class="line">  <span class="type">int</span> processing = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> finished = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> total_tasks;</span><br><span class="line">  <span class="type">size_t</span> dependencies;</span><br><span class="line">  std::mutex task_mutex;</span><br><span class="line">  <span class="built_in">Task</span>(TaskID id_, IRunnable* runnable_, <span class="type">int</span> total_tasks_, <span class="type">size_t</span> deps)</span><br><span class="line">    :<span class="built_in">id</span>(id_), <span class="built_in">runnable</span>(runnable_), <span class="built_in">total_tasks</span>(total_tasks_), <span class="built_in">dependencies</span>(deps) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As you can see, the <code>processing</code> filed is to indicate the next job for this task we should handle, the <code>finished</code> field is used to indicate how many tasks we have finished. We need to protect the variable, so for each task, there is a <code>mutex</code>.</p>
<p>If a task’s dependencies (<code>Task::dependencies</code>) are not zero, we should not run this task. So I use the following data structures:</p>
<ul>
<li><code>vector&lt;Task*&gt; ready</code>: the tasks which are ready, so we can handle.</li>
<li><code>unordered_set&lt;Task*&gt; blocked</code>: the tasks which should not run at now.</li>
</ul>
<p>The whole idea is when user calls <code>runAsyncWithDeps</code>, we should update the <code>dependency</code> and just sends the task to <code>blocked</code>. And in the thread loop, we first check whether there is a task in the <code>ready</code>. If so, we random choose one task of the <code>ready</code> to handle, if the task is all finished, we should update the <code>dependency</code> again. When all tasks are finished, we should terminate.</p>
<p>It may sound easy, however the correct implementation is hard.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskSystemParallelThreadPoolSleeping</span>: <span class="keyword">public</span> ITaskSystem &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> terminate = <span class="literal">false</span>; <span class="comment">// To indicate whether to stop the thread pool</span></span><br><span class="line">  <span class="type">int</span> _num_threads = <span class="number">0</span>; <span class="comment">// To indicate how many threads</span></span><br><span class="line">  <span class="type">int</span> sleepThreadNum = <span class="number">0</span>; <span class="comment">// The number of thread which is sleeping</span></span><br><span class="line">  std::unordered_map&lt;TaskID, Task*&gt; finished &#123;&#125;; <span class="comment">// To record the finished task</span></span><br><span class="line">  std::vector&lt;Task*&gt; ready &#123;&#125;; <span class="comment">// The task is ready to be processed</span></span><br><span class="line">  std::unordered_set&lt;Task*&gt; blocked &#123;&#125;; <span class="comment">// The task is blocked</span></span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  std::unordered_map&lt;TaskID, std::unordered_set&lt;Task*&gt;&gt; dependency &#123;&#125;; <span class="comment">// The dependency information</span></span><br><span class="line">  TaskID id = <span class="number">0</span>;</span><br><span class="line">  std::mutex queue_mutex;</span><br><span class="line">  std::condition_variable consumer;</span><br><span class="line">  std::condition_variable producer;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">int</span> num_threads)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">threadLoop</span><span class="params">(<span class="type">int</span> index)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deleteFinishedTask</span><span class="params">(Task* task)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">moveBlockTaskToReady</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signalSync</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskSystemParallelThreadPoolSleeping</span>(<span class="type">int</span> num_threads);</span><br><span class="line">  ~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>();</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks)</span></span>;</span><br><span class="line">  <span class="function">TaskID <span class="title">runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sync</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Then we first look at <code>runAsyncWithDeps</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For simplicity and easy-handling, we just make the new task to the `blocked`, and record</span></span><br><span class="line"><span class="comment"> * the dependency information and notify all the producers, and immediately return to the</span></span><br><span class="line"><span class="comment"> * user for async operation. And also we make the implementation more easily.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TaskID <span class="title">TaskSystemParallelThreadPoolSleeping::runAsyncWithDeps</span><span class="params">(IRunnable* runnable, <span class="type">int</span> num_total_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> std::vector&lt;TaskID&gt;&amp; deps)</span> </span>&#123;</span><br><span class="line">  Task* task = <span class="keyword">new</span> <span class="built_in">Task</span>(id, runnable, num_total_tasks, deps.<span class="built_in">size</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">    <span class="comment">// We just simply add the task to the blocked.</span></span><br><span class="line">    blocked.<span class="built_in">insert</span>(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record dependency information for later processing</span></span><br><span class="line">    <span class="keyword">for</span> (TaskID dep : deps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependency.<span class="built_in">count</span>(dep)) &#123;</span><br><span class="line">        dependency[dep].<span class="built_in">insert</span>(task);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dependency[dep] = std::unordered_set&lt;Task*&gt;&#123;task&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We should notify the producer to continue processing</span></span><br><span class="line">    producer.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> id++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The main functionality is in the <code>threadLoop</code> function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::threadLoop</span><span class="params">(<span class="type">int</span> id_)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    Task* task = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">      <span class="keyword">if</span>(ready.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!blocked.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          <span class="comment">// We should check to move the blocked to the ready.</span></span><br><span class="line">          <span class="built_in">moveBlockTaskToReady</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If ready is still empty, we should sleep the thread.</span></span><br><span class="line">        <span class="keyword">if</span>(ready.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            sleepThreadNum++;</span><br><span class="line">            producer.<span class="built_in">wait</span>(guard);</span><br><span class="line">            sleepThreadNum--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Here, we must tell whether the ready is empty,</span></span><br><span class="line"><span class="comment">        * when ready.size() == 0, rand() % 0 will cause</span></span><br><span class="line"><span class="comment">        * float point exception. It sucks.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span>(!ready.<span class="built_in">empty</span>()) &#123;index = <span class="built_in">rand</span>() % ready.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// Here, we use random to choose the task for each thread</span></span><br><span class="line">        <span class="comment">// for simplicity.</span></span><br><span class="line">        task = ready[index];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(terminate) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(task == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> processing = <span class="number">-1</span>, finished = <span class="number">-1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;task-&gt;task_mutex&#125;;</span><br><span class="line">      processing = task-&gt;processing;</span><br><span class="line">      <span class="comment">// There are some situations `processing` will exceed</span></span><br><span class="line">      <span class="comment">// the total number, because we don&#x27;t know when the</span></span><br><span class="line">      <span class="comment">// `deleteFinishedTask` is finished. We may choose the</span></span><br><span class="line">      <span class="comment">// task which is actually finished (or just only one)</span></span><br><span class="line">      <span class="keyword">if</span>(processing &gt;= task-&gt;total_tasks) <span class="keyword">continue</span>;</span><br><span class="line">      task-&gt;processing++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(processing &lt; task-&gt;total_tasks) &#123;</span><br><span class="line">      task-&gt;runnable-&gt;<span class="built_in">runTask</span>(processing, task-&gt;total_tasks);</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;task-&gt;task_mutex&#125;;</span><br><span class="line">      task-&gt;finished++;</span><br><span class="line">      finished = task-&gt;finished;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(finished == task-&gt;total_tasks) &#123;</span><br><span class="line">      std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">      <span class="built_in">deleteFinishedTask</span>(task);</span><br><span class="line">      <span class="comment">// When we signalSync, there are may be some threads which</span></span><br><span class="line">      <span class="comment">// are processing useless. So it may just return to the</span></span><br><span class="line">      <span class="comment">// destructor. So in the destructor we must wait for all</span></span><br><span class="line">      <span class="comment">// the thread going to sleep. And we call `notify_all` to</span></span><br><span class="line">      <span class="comment">// make all the threads stop. The design here should be</span></span><br><span class="line">      <span class="comment">// optimized. However, I don&#x27;t have enough time...</span></span><br><span class="line">      <span class="built_in">signalSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And the other part is some auxiliary functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::deleteFinishedTask</span><span class="params">(Task* task)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;i &lt; ready.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready[i] == task) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  finished.<span class="built_in">insert</span>(&#123;ready[i]-&gt;id ,ready[i]&#125;);</span><br><span class="line">  ready.<span class="built_in">erase</span>(ready.<span class="built_in">begin</span>() + i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dependency.<span class="built_in">count</span>(task-&gt;id)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t: dependency[task-&gt;id]) &#123;</span><br><span class="line">      t-&gt;dependencies--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Move blocked task to the ready when the task&#x27;s dependency is</span></span><br><span class="line"><span class="comment"> * all finished.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::moveBlockTaskToReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Task*&gt; moved &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> task : blocked) &#123;</span><br><span class="line">    <span class="keyword">if</span>(task-&gt;dependencies == <span class="number">0</span>) &#123;</span><br><span class="line">      ready.<span class="built_in">push_back</span>(task);</span><br><span class="line">      moved.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> task: moved) &#123;</span><br><span class="line">    blocked.<span class="built_in">erase</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When all the tasks are finished, which means `ready` and `blocked`</span></span><br><span class="line"><span class="comment"> * are are empty, we could signal the ONLY ONE consumer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskSystemParallelThreadPoolSleeping::signalSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(ready.<span class="built_in">empty</span>() &amp;&amp; blocked.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    consumer.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And for the destructor:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TaskSystemParallelThreadPoolSleeping::~<span class="built_in">TaskSystemParallelThreadPoolSleeping</span>() &#123;</span><br><span class="line"></span><br><span class="line">  terminate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It may seem why here we need to use spin to test the sleepThreadNum</span></span><br><span class="line">  <span class="comment">// Because of the design, there may be some threads who is not sleeping at</span></span><br><span class="line">  <span class="comment">// this time, in order to make there is no dead-lock. See the `threadLoop`</span></span><br><span class="line">  <span class="comment">// for more detail.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; guard&#123;queue_mutex&#125;;</span><br><span class="line">    <span class="keyword">if</span>(sleepThreadNum == _num_threads) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We should notify all the threads to return</span></span><br><span class="line">  producer.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num_threads; i++) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We should free the memory</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> task : finished) &#123;</span><br><span class="line">   <span class="keyword">delete</span> task.second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://luolibrary.com">shejialuo</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://luolibrary.com/2023/02/01/CS149-Assignment2-Building-A-Task-Execution-Library/">https://luolibrary.com/2023/02/01/CS149-Assignment2-Building-A-Task-Execution-Library/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
      
      <a href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2023/03/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SMTP%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">手把手教你写一个简单的SMTP服务器（一）</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2023/01/31/CS149-Assignment1-Performance-Analysis-on-a-Quad-Core-CPU/">  
        <span class="next-text nav-default">CS149-Assignment1 Performance Analysis on a Quad-Core CPU</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
      <div id="utterances-container"></div>  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  <a href="mailto:shejialuo@gmail.com" class="iconfont icon-email" title="email"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://twitter.com/luo_hope" class="iconfont icon-twitter" title="twitter"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/jialuo-she-913873289/" class="iconfont icon-linkedin" title="linkedin"></a>
  
  
  
  
  
  
  
  
  
  <a target="_blank" rel="noopener" href="https://github.com/shejialuo" class="iconfont icon-github" title="github"></a>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2020 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">shejialuo</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
  
<script>
  var container = document.getElementById('utterances-container');
  var script = document.createElement('script');
  script.src = 'https://utteranc.es/client.js';
  script.setAttribute('repo', 'shejialuo/shejialuo.github.io');
  script.setAttribute('issue-term', 'pathname');
  script.setAttribute('theme', 'github-light');
  script.setAttribute('label', 'Comment');
  script.crossorigin = 'anonymous';
  script.async = true;

  container.appendChild(script);
</script>
  
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



<!-- mermaid -->

  <script src='https://unpkg.com/mermaid@9.2.0/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>